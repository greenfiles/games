'use strict';

function switOnLoad() {
    if (!navigator.isCocoonJS) {
        if (!window.SwitEntryPoint.isSupported) return;
        if (!navigator.cookieEnabled) {
            var a = document.createElement("div");
            a.setAttribute("align", "center");
            document.body.appendChild(a);
            var b = new Image;
            b.onload = function() {
                b.setAttribute("width", "100%");
                b.setAttribute("height", "100%");
                a.appendChild(b)
            };
            b.src = "media/images/ui_images/cookiesrequired.jpg";
            return
        }
    }
    document.onkeydown = function(a) {
        if (!window.USE_SANBOX) return a.preventDefault(), !1
    };
    if (navigator.isCocoonJS) {
        var c =
            "IPHONE_4 IPAD_2 IPAD_MINI_1 IPOD_ NABIJR KINDLE KFOT KFTT KFJWA KFJWI KFSOWI KFAPWA KFAPWI KFTHWA KFTHWI KFARWI KFASWI KFSAWA KFSAWI".split(" "),
            d = [],
            e = window.CocoonJS && window.CocoonJS.App ? window.CocoonJS.App.getDeviceInfo() : null;
        if (e) {
            var f = e.model;
            f || (f = "[UNKNOWN]");
            for (var f = f.toUpperCase(), g = !1, h = 0; h < c.length; h++)
                if (0 === f.indexOf(c[h])) {
                    g = !0;
                    break
                }
            g ? (Application.warn("Using texture reduction on device: " + f), window.CocoonJS.App.setTextureReduction(128, null, d)) : Application.warn("Model device: " +
                f);
            "android" === e.os && (c = e.version.split("."), 4 >= parseInt(c[0], 10) && 3 > parseInt(c[1], 10) && (window.config.settings.RENDER_MODE = Application.RENDER_CANVAS))
        } else Application.warn("No found API >>> window[CocoonJS][App]")
    } else {
        var k = "",
            c = "";
        "undefined" !== typeof document.hidden ? (k = "hidden", c = "visibilitychange") : "undefined" !== typeof document.mozHidden ? (k = "mozHidden", c = "mozvisibilitychange") : "undefined" !== typeof document.msHidden ? (k = "msHidden", c = "msvisibilitychange") : "undefined" !== typeof document.webkitHidden &&
            (k = "webkitHidden", c = "webkitvisibilitychange");
        document.addEventListener(c, function() {
            if (Application.instance)
                if (document[k]) Application.isShowingPage = !1, Application.instance.onLostFocus();
                else if (Application.isShowingPage = !0, !(window.innerHeight > window.innerWidth)) Application.instance.onGotFocus()
        }, !1)
    }
    Application.strings = {};
    Application.strings = window.switStrings;
    Application.strings.STR_EMPTY = "";
    window.switStrings = null;
    window.switBoot()
}

function switBoot() {
    window.SwitEntryPoint.infoBrowser.isLowDefinition && Application.warn("Detecting low definition device");
    window.SwitEntryPoint.infoBrowser.useAssetsSD && Application.warn("Using SD assets");
    window.globalAnimations = [];
    new Application
}
window.onpagehide = function() {
    Application.isShowingPage = !1;
    if (Application.instance) Application.instance.onLostFocus()
};
window.onpageshow = function() {
    Application.isShowingPage = !0;
    if (!(window.innerHeight > window.innerWidth) && Application.instance) Application.instance.onGotFocus()
};
window.onblur = function() {
    Application.isShowingPage = !1;
    if (Application.instance) Application.instance.onLostFocus()
};
window.onfocus = function() {
    Application.isShowingPage = !0;
    if (!(window.innerHeight > window.innerWidth) && Application.instance) Application.instance.onGotFocus()
};
window.onresize = function(a) {
    Application.instance && (Application.instance.onResize(a.target.innerWidth, a.target.innerHeight), Application.instance.hideAddressBar())
};
window.onorientationchange = function(a) {
    if (Application.instance && !Application.instance.isAndroidChrome) Application.instance.onOrientationchange(a)
};
window.onkeydown = function(a) {
    if (Application.instance) Application.instance.onKeyDown(a)
};
window.onkeyup = function(a) {
    if (Application.instance) Application.instance.onKeyUp(a)
};
window.onerror = function(a, b, c, d, e) {
    Application.instance && Application.instance.isMobileDevice && Application.error("Error: " + a + "  File: " + b + "  Line: " + c + "  Column: " + d)
};

function Application() {
    Application.instance = this;
    Application.config = window.config;
    Application.MAX_DELTA_TIME = Application.config.settings.MAX_DELTA_TIME;
    Application.SAFE_AREA_WIDTH = Application.config.settings.SAFE_AREA_WIDTH;
    Application.APP_WIDTH = Application.config.settings.APP_WIDTH;
    Application.APP_HEIGHT = Application.config.settings.APP_HEIGHT;
    Application.APP_FPS = Application.config.settings.APP_FPS;
    Application.SOUND_PERCENT = Application.config.settings.SOUND_PERCENT;
    Application.LOG = Application.config.settings.LOG;
    Application.ASSETS_PATH = Application.config.settings.ASSETS_PATH;
    Application.USE_TILT = Application.config.settings.USE_TILT;
    Application.USE_CHEATS = Application.config.settings.USE_CHEATS;
    Application.RENDER_MODE = Application.config.settings.RENDER_MODE;
    Application.CONSOLE_MODE = Application.config.settings.CONSOLE_MODE;
    Application.WIDE_SCREEN = Application.config.settings.WIDE_SCREEN;
    Application.RIGHT_TO_LEFT = Application.config.settings.RIGHT_TO_LEFT;
    Application.SHOW_SOCIAL_BUTTONS = Application.config.settings.SHOW_SOCIAL_BUTTONS;
    Application.USE_ONLY_SOUNDJS = Application.config.settings.USE_ONLY_SOUNDJS;
    Application.isShowingPage = !0;
    Application.USE_ONLY_SOUNDJS = Application.config.settings.USE_ONLY_SOUNDJS;
    Cheats.enabled = Application.USE_CHEATS;
    this.updateable = !0;
    this.soundManager = null;
    this.effectManager = new SEffectManager;
    this.guiManager = new GuiManager;
    for (var a in window.Assets) {
        if (Array.isArray(window.Assets[a])) {
            if (0 < a.indexOf("_rtl"))
                if (Application.RIGHT_TO_LEFT) window.Assets[a.replace("_rtl", "")] = window.Assets[a];
                else continue;
            if (0 < a.indexOf("_ltr"))
                if (Application.RIGHT_TO_LEFT) continue;
                else window.Assets[a.replace("_ltr", "")] = window.Assets[a]
        }
        Application.filesQuality(a)
    }
    this.tweenManager = new TweenManager;
    this.isMobileDevice = window.SwitEntryPoint.infoBrowser.touchDevice;
    this.isMobileDevice = navigator.isCocoonJS ? !0 : this.isMobileDevice;
    this.isAndroidChrome = "Android" === window.SwitEntryPoint.infoBrowser.platformType && "Chrome" === window.SwitEntryPoint.infoBrowser.browserName;
    a = navigator.userAgent;
    this.iOS7 = -1 < a.indexOf("OS 7") &&
        (-1 < a.indexOf("iPhone") || -1 < a.indexOf("iPod"));
    this.lastHeight = this.lastWidth = 0;
    window.USE_SANBOX_NANO && (Application.WIDE_SCREEN = !1);
    this.m_fpsOldTime = this.m_fpsFrameCounter = this.fps = 0;
    this.stage = new window.PIXI.Container;
    a = {
        antialias: !1,
        transparent: !1,
        resolution: 1,
        preserveDrawingBuffer: !0
    };
    window.USE_SANBOX && (Application.RENDER_MODE = Application.RENDER_CANVAS, Cheats.enabled = !0);
    switch (Application.RENDER_MODE) {
        case 0:
            this.renderer = PIXI.autoDetectRenderer(Application.APP_WIDTH, Application.APP_HEIGHT,
                a);
            Application.RENDER_MODE = this.renderer.type;
            break;
        case Application.RENDER_CANVAS:
            this.renderer = new PIXI.CanvasRenderer(Application.APP_WIDTH, Application.APP_HEIGHT, a);
            break;
        case Application.RENDER_WEBGL:
            this.renderer = new PIXI.WebGLRenderer(Application.APP_WIDTH, Application.APP_HEIGHT, a)
    }
    this.videoRenderer = new window.PIXI.CanvasRenderer(Application.APP_WIDTH, Application.APP_HEIGHT, {
        transparent: !0
    });
    window.USE_SANBOX ? (document.getElementById("contentGame").appendChild(this.renderer.view), document.getElementById("contentGame").appendChild(this.videoRenderer.view)) :
        (document.body.appendChild(this.renderer.view), document.body.appendChild(this.videoRenderer.view));
    window.USE_SANBOX_NANO ? (Layout.align = Layout.ALIGN_TOP_LEFT, new window.SandboxNano) : window.USE_SANBOX && (new window.SandboxGui, Application.sandbox = new window.SandboxGame);
    this.renderer.view.setAttribute("id", "MainCanvasDraw");
    this.renderer.view.style.position = "absolute";
    this.videoRenderer.view.setAttribute("id", "VideoCanvasDraw");
    this.videoRenderer.view.style.visibility = "hidden";
    this.renderVideoView = !1;
    Application.RIGHT_TO_LEFT && this.renderer.view.setAttribute("dir", "rtl");
    this.renderer.plugins.interaction.autoPreventDefault = this.isMobileDevice;
    this.canvas = this.addDisplayContainer();
    this.stage.addChild(this.canvas);
    this.videoCanvas = this.addDisplayContainer();
    this.rotateScreen = null;
    navigator.isCocoonJS || (this.canvasRotateScreen = this.addDisplayContainer(), this.stage.addChild(this.canvasRotateScreen), this.rotateScreen = new RotateScreen(this.canvasRotateScreen), this.onOrientationchange(null));
    (a = document.getElementById("fontssamples")) &&
    a.parentElement && a.parentElement.removeChild(a);
    this.canvasEvents = document.createElement("canvas");
    this.canvasEvents.width = window.innerWidth;
    this.canvasEvents.height = window.innerHeight;
    this.canvasEvents.style.top = "0px";
    this.canvasEvents.style.left = "0px";
    document.body.appendChild(this.canvasEvents);
    this.canvasEvents.setAttribute("id", "MainCanvasEvents");
    this.canvasEvents.addEventListener("mousemove", this.renderer.plugins.interaction.onMouseMove, !0);
    this.canvasEvents.addEventListener("mousedown", this.renderer.plugins.interaction.onMouseDown, !0);
    this.canvasEvents.addEventListener("mouseout", this.renderer.plugins.interaction.onMouseOut, !0);
    this.canvasEvents.addEventListener("touchstart", this.renderer.plugins.interaction.onTouchStart, !0);
    this.canvasEvents.addEventListener("touchend", this.renderer.plugins.interaction.onTouchEnd, !0);
    this.canvasEvents.addEventListener("touchmove", this.renderer.plugins.interaction.onTouchMove, !0);
    this.socialShareObject = null;
    Application.SHOW_SOCIAL_BUTTONS && window.gameObj && (this.socialShareObject = window.gameObj);
    this.activeAgePopUp = !1;
    this.m_timeElapse = this.m_oldTime = 0;
    Application.instance.update();
    this.guiManager.gotoScreen(GuiManager.SC_PRELOAD);
    window.SwitEntryPoint.infoBrowser.isLowDefinition && (Application.isLowDevice = !0);
    navigator.isCocoonJS && Application.RENDER_MODE == Application.RENDER_WEBGL && (a = window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI || 1, this.renderer.resolution = a, this.renderer.renderTarget.resolution = a, this.renderer.plugins.interaction.resolution = 1)
}
Application.MAX_DELTA_TIME = 0;
Application.SAFE_AREA_WIDTH = 0;
Application.APP_WIDTH = 0;
Application.APP_HEIGHT = 0;
Application.APP_FPS = 0;
Application.SOUND_PERCENT = 0;
Application.LOG = !1;
Application.ASSETS_PATH = "";
Application.USE_TILT = !1;
Application.USE_CHEATS = !1;
Application.RIGHT_TO_LEFT = !1;
Application.RENDER_WEBGL = 1;
Application.RENDER_CANVAS = 2;
Application.RENDER_MODE = Application.RENDER_CANVAS;
Application.DPI = 1;
Application.SHOW_SOCIAL_BUTTONS = !1;
Application.jsonFiles = {};
Application.instance = null;
Application.strings = null;
Application.config = null;
Application.sandbox = null;
Application.isLowDevice = !1;
Application.subclass = function(a, b) {
    function c() {}
    c.prototype = b.prototype;
    a.prototype = new c;
    a.prototype.constructor = a
};
Application.prototype.onKeyDown = function(a) {
    if (this.guiManager) this.guiManager.onKeyDown(a.keyCode)
};
Application.prototype.onKeyUp = function(a) {
    if (this.guiManager) this.guiManager.onKeyUp(a.keyCode)
};
Application.prototype.onLoadingError = function(a) {
    Application.error("onLoadingError: " + a)
};
Application.prototype.onSoundsLoaded = function() {
    Application.info("onSoundsLoaded");
    SndManager.instance.callbackBug && Application.instance.guiManager.gotoScreen(GuiManager.SC_MAIN_MENU)
};
Application.prototype.onErrorSndManagerIE = function() {
    Application.info("onErrorSndManagerIE");
    Application.instance.soundManager = new SndManagerWeb(Application.config.sounds, Application.instance.onSoundsLoaded)
};
Application.prototype.onLoaderReady = function() {
    Application.info("onLoaderReady");
    if (window.USE_SANBOX_NANO) Application.instance.guiManager.gotoScreen(GuiManager.SC_SANBOX_NANO_VIEW);
    else if (Application.instance.guiManager.gotoScreen(GuiManager.SC_SOUND_LOADER), Application.instance.onResize(window.innerWidth, window.innerHeight), navigator.isCocoonJS) Application.instance.soundManager = new SndManagerSimple, Application.instance.guiManager.gotoScreen(GuiManager.SC_MAIN_MENU);
    else {
        var a = window.SwitEntryPoint.infoBrowser.isIE,
            b = -1 != navigator.userAgent.indexOf("Firefox"),
            c = -1 != navigator.userAgent.indexOf("Safari"),
            d = -1 != navigator.platform.indexOf("iPhone") || -1 != navigator.platform.indexOf("iPod") || -1 != navigator.platform.indexOf("iPad") || -1 != navigator.platform.indexOf("Mac");
        d && b || a && !Application.USE_ONLY_SOUNDJS ? (Application.instance.soundManager = new SndManagerIE(Application.config.sounds, Application.instance.onSoundsLoaded), d && !c && Application.log("Forcing iOS to soundManagerIE")) : Application.instance.soundManager = new SndManagerWeb(Application.config.sounds,
            Application.instance.onSoundsLoaded)
    }
};
Application.prototype.onResize = function(a, b) {
    this.lastWidth = a;
    this.lastHeight = b;
    Layout.onResize(a, b);
    if (this.rotateScreen) this.rotateScreen.onResize();
    this.onOrientationchange(null)
};
Application.prototype.onOrientationchange = function(a) {
    if (Application.instance.isMobileDevice)
        if (window.innerHeight > window.innerWidth) Application.instance.socialShareObject && (Application.instance.activeAgePopUp = "block" == window.$("#endgameHUD").css("display"), Application.instance.socialShareObject.badRotation()), this.rotateScreen && this.rotateScreen.show(), GuiPopupVideo.instance && GuiPopupVideo.instance.toggle(!1), this.onLostFocus();
        else {
            if (Application.instance.socialShareObject) {
                Application.instance.socialShareObject.goodRotation();
                try {
                    Application.instance.activeAgePopUp ? window.$("#endgameHUD").css("display", "block") : window.$("#endgameHUD").css("display", "none")
                } catch (b) {}
            }
            this.rotateScreen && this.rotateScreen.hide();
            GuiPopupVideo.instance && GuiPopupVideo.instance.toggle(!0);
            if (-1 != navigator.platform.indexOf("iPhone") || -1 != navigator.platform.indexOf("iPod") || -1 != navigator.platform.indexOf("iPad"))
                if (Application.isShowingPage) this.onGotFocus();
                else Application.log("Page is not being shown. Blocked iOS delayed rotation glitch");
            else this.onGotFocus()
        }
};
Application.prototype.onLostFocus = function() {
    this.updateable = !1;
    try {
        Application.info("-- ON LOST FOCUS --"), this.soundManager && !this.soundManager.isMuted() && this.soundManager.pauseAll()
    } catch (a) {
        Application.error("onLostFocus: " + a)
    }
};
Application.prototype.onGotFocus = function() {
    this.updateable = !0;
    try {
        Application.info("-- ON GOT FOCUS --"), this.soundManager && !this.soundManager.isMuted() && this.soundManager.resumeAll()
    } catch (a) {
        Application.error("onGotFocus: " + a)
    }
};
Application.prototype.update = function() {
    window.requestAnimationFrame(Application.instance.update);
    var a = Application.instance,
        b = Date.now();
    a.m_timeElapse += b - a.m_oldTime;
    a.m_oldTime = b;
    a.guiManager.update(a.m_timeElapse);
    a.updateable ? (a.effectManager.update(a.m_timeElapse), a.tweenManager.update()) : a.rotateScreen && a.rotateScreen.animate && a.tweenManager.update();
    a.m_timeElapse = 0;
    a.m_fpsFrameCounter++;
    1E3 <= b - a.m_fpsOldTime && (a.fps = (a.m_fpsFrameCounter / (b - a.m_fpsOldTime) * 1E3).toFixed(0), a.m_fpsOldTime = b,
        a.m_fpsFrameCounter = 0);
    a.renderer.render(a.stage);
    a.renderVideoView && a.videoRenderer.render(a.videoCanvas);
    Application.WIDE_SCREEN ? Application.RENDER_MODE === Application.RENDER_CANVAS && a.getContext().setTransform(Layout.scale, 0, 0, Layout.scale, Layout.left, Layout.top) : Application.RENDER_MODE === Application.RENDER_CANVAS && a.getContext().setTransform(Global.baseScale, 0, 0, Global.baseScale, Global.offsetZoomX, Global.offsetZoomY);
    a.guiManager.onDebugDraw(a.getContext());
    if (window.innerWidth !== a.lastWidth ||
        window.innerHeight !== a.lastHeight) a.onResize(window.innerWidth, window.innerHeight), a.hideAddressBar()
};
Application.prototype.hideAddressBar = function() {
    Application.instance.isMobileDevice && (setTimeout(function() {
        window.scrollTo(0, 1)
    }, 20), setTimeout(function() {
        window.scrollTo(0, 0)
    }, 50))
};
Application.prototype.getCanvas = function() {
    return this.renderer.view
};
Application.prototype.getContext = function() {
    return Application.RENDER_MODE === Application.RENDER_CANVAS ? this.renderer.view.getContext("2d") : this.renderer.view.getContext("webgl") || this.renderer.view.getContext("experimental-webgl")
};
Application.prototype.captureScreen = function() {
    return Application.instance.getCanvas().toDataURL()
};
Application.prototype.addDisplayContainer = function() {
    return new SDisplayObjectContainer
};
Application.prototype.getClip = function(a) {
    return window.PIXI.utils.TextureCache[a] ? new SSprite(a) : new Animation(a)
};
Application.prototype.getSpriteFromUrl = function(a) {
    return PIXI.Sprite.fromImage(a, !1, PIXI.SCALE_MODES.DEFAULT)
};
Application.prototype.getLocalizedImage = function(a) {
    if (window.SwitEntryPoint.debug) {
        var b = window.LocalizedAssets.images;
        if (b)
            for (var c = 0; c < b.length; c++)
                if (b[c] === window.LocalizedAssets.PATH + a) return PIXI.Sprite.fromImage(window.LocalizedAssets.PATH + a, !1, PIXI.SCALE_MODES.DEFAULT);
        Application.fatal("Unregistered localized image: " + a)
    }
    return PIXI.Sprite.fromImage(window.LocalizedAssets.PATH + a, !1, PIXI.SCALE_MODES.DEFAULT)
};
Application.filesQuality = function(a) {
    if (window.SwitEntryPoint.infoBrowser.useAssetsSD && window.Assets[a])
        for (var b = 0; b < window.Assets[a].length; b++) window.Assets.FILES_SD[window.Assets[a][b]] && (Application.DPI = 2, window.Assets[a][b] = window.Assets.FILES_SD[window.Assets[a][b]], Application.log("FILES SD :: " + window.Assets[a][b]))
};
Application.prototype.playSound = function(a) {
    this.soundManager.play(a)
};
Application.prototype.stopSound = function(a) {
    this.soundManager.stop(a)
};
Application.prototype.stopAllSounds = function() {
    this.isSoundOn() && this.soundManager.stopAllSounds()
};
Application.prototype.stopAllMusics = function() {
    this.soundManager.stopAllMusics()
};
Application.prototype.toggleMute = function() {
    this.soundManager.toggleMute()
};
Application.prototype.isPlayingSound = function(a) {
    return this.soundManager.isPlayingSound(a)
};
Application.prototype.setVolumeById = function(a, b) {
    this.soundManager.setVolumeById(a, b)
};
Application.prototype.isSoundOn = function() {
    return !this.soundManager.isMuted()
};
Application.prototype.resumeSound = function(a) {
    this.soundManager.resumeSound(a)
};
Application.prototype.pauseAllSounds = function() {
    this.soundManager.pauseAll()
};
Application.prototype.resumeAllSounds = function() {
    this.soundManager.resumeAll()
};
Application.log = function(a) {
    Application.LOG && (window.console && window.console.log && window.console.log("[LOG] " + a), window.Debug && window.Debug.writeln("[LOG] " + a))
};
Application.info = function(a) {
    window.console && window.console.info && window.console.info("[INFO] " + a);
    window.Debug && window.Debug.writeln("[INFO] " + a)
};
Application.warn = function(a) {
    window.console && window.console.warn && window.console.warn("[WARN] " + a);
    window.Debug && window.Debug.writeln("[WARN] " + a)
};
Application.error = function(a) {
    window.console && window.console.error && window.console.error("[ERROR] " + a);
    window.Debug && window.Debug.writeln("[ERROR] " + a)
};
Application.errorIf = function(a, b) {
    a || Application.error(b)
};
Application.fatal = function(a) {
    Application.error("[FATAL] " + a);
    throw Error(a);
};
Application.assert = function(a, b) {
    a || Application.fatal(b)
};
Application.externalTrack = function(a, b) {};

function ScoreAPI() {
    this.gameId = "491";
    this.playerName = "BAM";
    (this.api = window.config.settings.HIDE_LEADERBOARD_BUTTON ? null : new window.GBAPI) && this.api.setSharedKey("1234");
    this.resultsPerPage = 50;
    try {
        this.playerName = window.localStorage.getItem(window.config.settings.localStorageUserName) || ""
    } catch (a) {
        Application.error("CAN'T [LOAD] LOCAL STORAGE")
    }
}
ScoreAPI.instance = null;
ScoreAPI.ONE_DAY_SECONDS = 86400;
ScoreAPI.ONE_DAY_MS = 864E5;
ScoreAPI.initialize = function() {
    ScoreAPI.instance = new ScoreAPI
};
ScoreAPI.prototype.sendScore = function(a, b) {
    var c = {};
    c.game = this.gameId;
    c.name = this.playerName;
    c.score = a.toString();
    this.api.sendScore(c, b)
};
ScoreAPI.prototype.getScores = function(a) {
    Date.now();
    var b = {};
    b.game = this.gameId;
    b.perPage = this.resultsPerPage;
    b.pageNumber = 1;
    b.orderAsc = 0;
    this.api.getScores(b, a)
};
ScoreAPI.prototype.getScoresThisWeek = function(a) {
    var b = Math.floor(Date.now() / 1E3),
        c = {};
    c.game = this.gameId;
    c.perPage = this.resultsPerPage;
    c.pageNumber = 1;
    c.startTimestamp = b - 7 * ScoreAPI.ONE_DAY_SECONDS;
    c.endTimestamp = b;
    c.orderAsc = 0;
    this.api.getScores(c, a)
};
ScoreAPI.prototype.getScoresToday = function(a) {
    var b = Math.floor(Date.now() / 1E3),
        c = {};
    c.game = this.gameId;
    c.perPage = this.resultsPerPage;
    c.pageNumber = 1;
    c.startTimestamp = b - ScoreAPI.ONE_DAY_SECONDS;
    c.endTimestamp = b;
    c.orderAsc = 0;
    this.api.getScores(c, a)
};
ScoreAPI.prototype.adjustTimestamp = function(a) {
    var b = Math.floor(Date.now() / 1E3);
    return parseInt(b, 10) + a * ScoreAPI.ONE_DAY_SECONDS
};

function DebugGame() {
    DebugGame.instance = this
}
DebugGame.instance = null;
DebugGame.prototype.free = function() {
    DebugGame.instance = null
};
DebugGame.prototype.onDebugInit = function() {};
DebugGame.prototype.onDebugCreateObject = function(a, b, c) {};
DebugGame.prototype.onDebugRemoveObject = function(a) {};
DebugGame.prototype.onDebugKeyDown = function(a) {};
DebugGame.prototype.onDebugKeyUp = function(a) {};
DebugGame.prototype.onDebugPointerPress = function(a) {
    if (Application.sandbox.addObjectEnable && Application.sandbox.objectToCreate) {
        var b = "[SANDBOX] [ADD OBJECT] ",
            c;
        for (c in Application.sandbox.objectToCreate) b += c + ":" + Application.sandbox.objectToCreate[c] + ", ";
        Application.log(b.substring(0, b.length - 2));
        this.onDebugCreateObject(a.data.global.x, a.data.global.y, Application.sandbox.objectToCreate)
    }
};
DebugGame.prototype.onDebugUpdate = function(a) {};
DebugGame.prototype.onDebugPointerRelease = function(a) {};
DebugGame.prototype.onDebugPointerPressAndRelease = function(a) {};
DebugGame.prototype.onDebugPointerOver = function(a) {};
DebugGame.prototype.onDebugPointerMove = function(a) {};
DebugGame.prototype.onDebugGetSandboxConfig = function() {
    return []
};
DebugGame.prototype.onDebugSandboxLoadConfig = function() {};

function DebugObject() {
    this.onDebugInit()
}
DebugObject.COLLISION_BASE = "mcCollision";
DebugObject.COLLISION_ATTACK = "mcCollisionAttack";
DebugObject.prototype.free = function() {};
DebugObject.prototype.onDebugInit = function() {};
DebugObject.prototype.onDebugDelete = function() {};
DebugObject.prototype.onDebugUpdate = function(a) {
    (a = Application.sandbox) && a.objectSelected && a.objectViewPropertiesRealTime && a.objectSelected === this && a.setObjectViewProperties(this)
};
DebugObject.prototype.onDebugPointerPress = function(a) {};
DebugObject.prototype.onDebugChangeProperties = function(a) {
    Application.info("SANDBOX OBJECT PROPERTY :: Change [" + a.property + "] by [" + a.value + "]")
};
DebugObject.prototype.onDebugSelectObject = function() {
    Application.sandbox && Application.sandbox.setObjectViewProperties(this)
};
DebugObject.prototype.onDebugGetProperties = function() {
    return []
};

function Circle(a, b, c) {
    this.x = "undefined" === typeof a ? 0 : a;
    this.y = "undefined" === typeof b ? 0 : b;
    this.r = "undefined" === typeof c ? 0 : c
}
Circle.prototype.hitTest = function(a, b) {
    return 0 === this.r ? !1 : (this.x - a) * (this.x - a) + (this.y - b) * (this.y - b) <= this.r * this.r
};
Circle.prototype.isEmpty = function() {
    return 0 === this.r
};
Circle.prototype.toString = function() {
    return "circle x:" + this.x + " y:" + this.y + " r:" + this.r
};

function Path(a) {
    this.m_sections = [];
    this.m_length = 0;
    for (var b = a.point.length(), c = 0; c < b; ++c) {
        for (var d = a.point[c].n, e = [], f = 0; f < d; ++f) e.push(new Vector2D(parseFloat(a.point[c]["x" + f]), parseFloat(a.point[c]["y" + f])));
        e.push(new Vector2D(parseFloat(a.point[(c + 1) % b].x0), parseFloat(a.point[(c + 1) % b].y0)));
        d = new PathSection(e, this.m_length);
        this.m_length += d.length();
        this.m_sections.push(d)
    }
}
Path.prototype.free = function() {
    this.m_sections = null
};
Path.prototype.update = function(a, b) {
    this.m_sections[b.pathPosition.section].update(a, b);
    b.pathPosition.point ? b.setPosition(b.pathPosition.point.x, b.pathPosition.point.y) : (b.pathPosition.section < this.m_sections.length - 1 ? b.pathPosition.section += 1 : (b.pathPosition.section = 0, b.pathPosition.distance = 0), this.m_sections[b.pathPosition.section].update(a, b), b.pathPosition.point ? b.setPosition(b.pathPosition.point.x, b.pathPosition.point.y) : Application.info("ERROR"))
};
Path.prototype.toString = function() {
    for (var a = "Path:", b = this.m_sections.length, c = 0; c < b; ++c) a += "\n" + this.m_sections[c];
    return a
};

function PathSection(a, b) {
    this.m_order = a.length - 1;
    this.m_points = a;
    this.m_initLength = b;
    this.m_length = 0;
    this.m_oldPos = null;
    switch (this.m_order) {
        case PathSection.CONIC:
        case PathSection.CUBIC:
        case PathSection.LINE:
            this.m_dir = new Vector2D(this.m_points[this.m_order].x - this.m_points[0].x, this.m_points[this.m_order].y - this.m_points[0].y);
            this.m_length = this.m_dir.length();
            this.m_angle = this.m_dir.angle();
            this.m_dir.normalize();
            break;
        default:
            Application.error("Invalid path section order: " + this.m_order)
    }
}
PathSection.LINE = 1;
PathSection.CONIC = 2;
PathSection.CUBIC = 3;
PathSection.SECTIONS = 3;
PathSection.prototype.free = function() {
    this.m_points = null
};
PathSection.prototype.length = function() {
    return this.m_length
};
PathSection.prototype.update = function(a, b) {
    var c = b.pathPosition.distance + a,
        d;
    if (c <= this.m_initLength + this.m_length) {
        switch (this.m_order) {
            case PathSection.LINE:
                b.pathPosition.point = this.m_dir.clone();
                b.pathPosition.point.scale(c - this.m_initLength);
                b.pathPosition.point.add(this.m_points[0]);
                b.pathPosition.tangent = this.m_angle;
                break;
            case PathSection.CONIC:
                b.pathPosition.point = new Vector2D;
                d = (c - this.m_initLength) / this.m_length;
                b.pathPosition.point.x = (1 - d) * (1 - d) * this.m_points[0].x + 2 * (1 - d) * d * this.m_points[1].x +
                    d * d * this.m_points[2].x;
                b.pathPosition.point.y = (1 - d) * (1 - d) * this.m_points[0].y + 2 * (1 - d) * d * this.m_points[1].y + d * d * this.m_points[2].y;
                this.m_oldPos && (this.m_oldPos.subtract(b.pathPosition.point), this.m_oldPos.scale(-1), b.pathPosition.tangent = this.m_oldPos.angle());
                this.m_oldPos = b.pathPosition.point;
                break;
            case PathSection.CUBIC:
                b.pathPosition.point = new Vector2D;
                d = (c - this.m_initLength) / this.m_length;
                b.pathPosition.point.x = (1 - d) * (1 - d) * (1 - d) * this.m_points[0].x + 3 * (1 - d) * (1 - d) * d * this.m_points[1].x + 3 * (1 - d) * d *
                    d * this.m_points[2].x + d * d * d * this.m_points[3].x;
                b.pathPosition.point.y = (1 - d) * (1 - d) * (1 - d) * this.m_points[0].y + 3 * (1 - d) * (1 - d) * d * this.m_points[1].y + 3 * (1 - d) * d * d * this.m_points[2].y + d * d * d * this.m_points[3].y;
                this.m_oldPos && (this.m_oldPos.subtract(b.pathPosition.point), this.m_oldPos.scale(-1), b.pathPosition.tangent = this.m_oldPos.angle());
                this.m_oldPos = b.pathPosition.point;
                break;
            default:
                Application.error("Invalid path section order: " + this.m_order)
        }
        b.pathPosition.distance = c
    } else this.m_oldPos = b.pathPosition.point =
        null
};
PathSection.prototype.toString = function() {
    for (var a = "section:", b = 0; b < this.m_points.length; ++b) a += this.m_points[b] + " ";
    return a
};

function SMath() {}
SMath.degrees = function(a, b) {
    return Math.atan2(a, b) * SMath.RAD_TO_DEG
};
SMath.toRadians = function(a) {
    return a * SMath.DEG_TO_RAD
};
SMath.toDegrees = function(a) {
    return a * SMath.RAD_TO_DEG
};
SMath.setRange = function(a, b, c) {
    return a > b ? b : a < c ? c : a
};
SMath.abs = function(a) {
    return 0 > a ? -a : a
};
SMath.sign = function(a) {
    return 0 < a ? 1 : 0 === a ? 0 : -1
};
SMath.fastSin = function(a) {
    a %= 6.28318531; - 3.14159265 > a ? a += 6.28318531 : 3.14159265 < a && (a -= 6.28318531);
    return 0 > a ? 1.27323954 * a + .405284735 * a * a : 1.27323954 * a - .405284735 * a * a
};
SMath.fastCos = function(a) {
    a = a % 6.28318531 + 1.57079632; - 3.14159265 > a ? a += 6.28318531 : 3.14159265 < a && (a -= 6.28318531);
    return 0 > a ? 1.27323954 * a + .405284735 * a * a : 1.27323954 * a - .405284735 * a * a
};
SMath.RAD_TO_DEG = 57.2957795;
SMath.DEG_TO_RAD = .0174533;
SMath._180_over_PI = 57.2957795;

function SRandom(a) {
    "undefined" !== typeof a && (this.m_seed = a);
    0 >= this.m_seed && this.srand();
    this.m_initSeed = this.m_seed;
    Application.info("SEED: " + this.m_seed);
    this.random()
}
SRandom.prototype.reset = function() {
    this.m_seed = this.m_initSeed;
    this.random()
};
SRandom.prototype.random = function() {
    this.m_seed = 16807 * this.m_seed % 2147483647;
    return this.m_seed / 2147483647
};
SRandom.prototype.srand = function() {
    this.m_seed = 1 + Math.floor(2147483646 * Math.random())
};
SRandom.prototype.randomInt = function(a, b) {
    return a + Math.floor(this.random() * (b - a + 1))
};
SRandom.prototype.getArrayIndex = function(a, b) {
    "undefined" === typeof b && (b = -1);
    if (1 < a) {
        var c = this.randomInt(0, a - 1);
        c == b && (c = (c + 1) % a);
        return c
    }
    return 1 > a ? -1 : 0
};
SRandom.prototype.shuffleArray = function(a) {
    for (var b = a.length - 1; 0 < b;) {
        var c = Math.floor(this.random() * (b + 1)),
            d = a[b];
        a[b] = a[c];
        a[c] = d;
        --b
    }
};

function Shaker(a) {
    this.m_canvas = a;
    this.m_yEnabled = this.m_xEnabled = !0;
    this.m_shaked = !1;
    this.m_amp = 0;
    this.m_duration = this.m_frequency = 1;
    this.m_updateable = !1;
    this.m_timer = 0;
    this.m_timerFrequency = 1;
    this.oy = this.ox = 0
}
Shaker.prototype.free = function() {
    this.m_canvas = null
};
Shaker.prototype.enableDirection = function(a, b) {
    this.m_xEnabled = a;
    this.m_yEnabled = b
};
Shaker.prototype.shake = function(a, b, c) {
    this.m_updateable || (this.ox = this.m_canvas.position.x, this.oy = this.m_canvas.position.y);
    this.stop();
    this.m_duration = c;
    this.m_frequency = b;
    this.m_amp = a;
    0 == this.m_duration && (this.m_duration = -1)
};
Shaker.prototype.setAmplitude = function(a) {
    this.m_amp = a
};
Shaker.prototype.start = function() {
    this.m_updateable = !0
};
Shaker.prototype.stop = function() {
    this.m_canvas.position.x = this.ox;
    this.m_canvas.position.y = this.oy;
    this.m_updateable = !1;
    this.m_duration = -1;
    this.m_timer = this.m_timerFrequency = this.m_frequency = 0
};
Shaker.prototype.isShaking = function() {
    return this.m_updateable
};
Shaker.prototype.updateClipPosition = function() {
    this.m_xEnabled && (this.m_canvas.position.x = this.ox + this.m_amp * Math.random());
    this.m_yEnabled && (this.m_canvas.position.y = this.oy + this.m_amp * Math.random())
};
Shaker.prototype.update = function(a) {
    this.m_updateable && -1 != this.m_duration && (this.m_timer < this.m_duration ? (this.m_timer += a, this.m_timerFrequency += a, this.m_frequency < this.m_timerFrequency && (this.m_timerFrequency = 0, this.updateClipPosition())) : this.stop())
};

function TweenManager() {
    this._tweens = [];
    TweenManager.instance = this
}
TweenManager.prototype.getAll = function() {
    return this._tweens
};
TweenManager.prototype.removeAll = function() {
    this._tweens = []
};
TweenManager.prototype.add = function(a) {
    this._tweens.push(a)
};
TweenManager.prototype.remove = function(a) {
    a = this._tweens.indexOf(a); - 1 !== a && this._tweens.splice(a, 1)
};
TweenManager.prototype.update = function(a) {
    if (0 === this._tweens.length) return !1;
    var b = 0,
        c = this._tweens.length;
    for (a = void 0 !== a ? a : "undefined" !== typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(); b < c;) this._tweens[b] && this._tweens[b].update(a) ? b++ : (this._tweens[b].free(), this._tweens.splice(b, 1), c--);
    return !0
};

function TweenEasing() {}
TweenEasing.LinearNone = function(a) {
    return a
};
TweenEasing.QuadraticIn = function(a) {
    return a * a
};
TweenEasing.QuadraticOut = function(a) {
    return a * (2 - a)
};
TweenEasing.QuadraticInOut = function(a) {
    return 1 > (a *= 2) ? .5 * a * a : -.5 * (--a * (a - 2) - 1)
};
TweenEasing.CubicIn = function(a) {
    return a * a * a
};
TweenEasing.CubicOut = function(a) {
    return --a * a * a + 1
};
TweenEasing.CubicInOut = function(a) {
    return 1 > (a *= 2) ? .5 * a * a * a : .5 * ((a -= 2) * a * a + 2)
};
TweenEasing.QuarticIn = function(a) {
    return a * a * a * a
};
TweenEasing.QuarticOut = function(a) {
    return 1 - --a * a * a * a
};
TweenEasing.QuarticInOut = function(a) {
    return 1 > (a *= 2) ? .5 * a * a * a * a : -.5 * ((a -= 2) * a * a * a - 2)
};
TweenEasing.QuinticIn = function(a) {
    return a * a * a * a * a
};
TweenEasing.QuinticOut = function(a) {
    return --a * a * a * a * a + 1
};
TweenEasing.QuinticInOut = function(a) {
    return 1 > (a *= 2) ? .5 * a * a * a * a * a : .5 * ((a -= 2) * a * a * a * a + 2)
};
TweenEasing.SinusoidalIn = function(a) {
    return 1 - Math.cos(a * Math.PI / 2)
};
TweenEasing.SinusoidalOut = function(a) {
    return Math.sin(a * Math.PI / 2)
};
TweenEasing.SinusoidalInOut = function(a) {
    return .5 * (1 - Math.cos(Math.PI * a))
};
TweenEasing.ExponentialIn = function(a) {
    return 0 === a ? 0 : Math.pow(1024, a - 1)
};
TweenEasing.ExponentialOut = function(a) {
    return 1 === a ? 1 : 1 - Math.pow(2, -10 * a)
};
TweenEasing.ExponentialInOut = function(a) {
    return 0 === a ? 0 : 1 === a ? 1 : 1 > (a *= 2) ? .5 * Math.pow(1024, a - 1) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2)
};
TweenEasing.CircularIn = function(a) {
    return 1 - Math.sqrt(1 - a * a)
};
TweenEasing.CircularOut = function(a) {
    return Math.sqrt(1 - --a * a)
};
TweenEasing.CircularInOut = function(a) {
    return 1 > (a *= 2) ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1)
};
TweenEasing.ElasticIn = function(a) {
    var b, c = .1;
    if (0 === a) return 0;
    if (1 === a) return 1;
    !c || 1 > c ? (c = 1, b = .1) : b = .4 * Math.asin(1 / c) / (2 * Math.PI);
    return -(c * Math.pow(2, 10 * --a) * Math.sin(2 * (a - b) * Math.PI / .4))
};
TweenEasing.ElasticOut = function(a) {
    var b, c = .1;
    if (0 === a) return 0;
    if (1 === a) return 1;
    !c || 1 > c ? (c = 1, b = .1) : b = .4 * Math.asin(1 / c) / (2 * Math.PI);
    return c * Math.pow(2, -10 * a) * Math.sin(2 * (a - b) * Math.PI / .4) + 1
};
TweenEasing.ElasticInOut = function(a) {
    var b, c = .1;
    if (0 === a) return 0;
    if (1 === a) return 1;
    !c || 1 > c ? (c = 1, b = .1) : b = .4 * Math.asin(1 / c) / (2 * Math.PI);
    return 1 > (a *= 2) ? -.5 * c * Math.pow(2, 10 * --a) * Math.sin(2 * (a - b) * Math.PI / .4) : c * Math.pow(2, -10 * --a) * Math.sin(2 * (a - b) * Math.PI / .4) * .5 + 1
};
TweenEasing.BackIn = function(a) {
    return a * a * (2.70158 * a - 1.70158)
};
TweenEasing.BackOut = function(a) {
    return --a * a * (2.70158 * a + 1.70158) + 1
};
TweenEasing.BackInOut = function(a) {
    return 1 > (a *= 2) ? .5 * a * a * (3.5949095 * a - 2.5949095) : .5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2)
};
TweenEasing.BounceIn = function(a) {
    return 1 - TweenEasing.BounceOut(1 - a)
};
TweenEasing.BounceOut = function(a) {
    return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375
};
TweenEasing.BounceInOut = function(a) {
    return .5 > a ? .5 * TweenEasing.BounceIn(2 * a) : .5 * TweenEasing.BounceOut(2 * a - 1) + .5
};

function TweenInterpolation() {}
TweenInterpolation.Linear = function(a, b) {
    var c = a.length - 1,
        d = c * b,
        e = Math.floor(d),
        f = TweenInterpolation.UtilsLinear;
    return 0 > b ? f(a[0], a[1], d) : 1 < b ? f(a[c], a[c - 1], c - d) : f(a[e], a[e + 1 > c ? c : e + 1], d - e)
};
TweenInterpolation.Bezier = function(a, b) {
    var c = 0,
        d = a.length - 1,
        e = Math.pow,
        f = TweenInterpolation.UtilsBernstein,
        g;
    for (g = 0; g <= d; g++) c += e(1 - b, d - g) * e(b, g) * a[g] * f(d, g);
    return c
};
TweenInterpolation.CatmullRom = function(a, b) {
    var c = a.length - 1,
        d = c * b,
        e = Math.floor(d),
        f = TweenInterpolation.UtilsCatmullRom;
    return a[0] === a[c] ? (0 > b && (e = Math.floor(d = c * (1 + b))), f(a[(e - 1 + c) % c], a[e], a[(e + 1) % c], a[(e + 2) % c], d - e)) : 0 > b ? a[0] - (f(a[0], a[0], a[1], a[1], -d) - a[0]) : 1 < b ? a[c] - (f(a[c], a[c], a[c - 1], a[c - 1], d - c) - a[c]) : f(a[e ? e - 1 : 0], a[e], a[c < e + 1 ? c : e + 1], a[c < e + 2 ? c : e + 2], d - e)
};
TweenInterpolation.UtilsLinear = function(a, b, c) {
    return (b - a) * c + a
};
TweenInterpolation.UtilsBernstein = function(a, b) {
    var c = TweenInterpolation.UtilsFactorial;
    return c(a) / c(b) / c(a - b)
};
TweenInterpolation.UtilsFactorial = function(a) {
    for (var b = 1, c = 1; c <= a; c++) b *= c;
    return b
};
TweenInterpolation.UtilsCatmullRom = function(a, b, c, d, e) {
    a = .5 * (c - a);
    d = .5 * (d - b);
    var f = e * e;
    return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b
};

function Tween(a) {
    this._object = this.target = a;
    this._valuesStart = {};
    this._valuesEnd = {};
    this._valuesStartRepeat = {};
    this._duration = 1E3;
    this._repeat = 0;
    this._reversed = this._yoyo = !1;
    this._delayTime = 0;
    this._startTime = null;
    this._easingFunction = TweenEasing.LinearNone;
    this._interpolationFunction = TweenInterpolation.Linear;
    this._chainedTweens = [];
    this._onStartCallback = null;
    this._onStartCallbackFired = !1;
    this._onCompleteCallback = this._onUpdateCallback = null;
    for (var b in a) this._valuesStart[b] = parseFloat(a[b])
}
Tween.prototype.free = function() {
    this._onCompleteCallback = this._onUpdateCallback = this._onStartCallback = this._chainedTweens = this._interpolationFunction = this._easingFunction = this._valuesStartRepeat = this._valuesEnd = this._valuesStart = this._object = this.target = null
};
Tween.prototype.to = function(a, b) {
    void 0 !== b && (this._duration = b);
    this._valuesEnd = a;
    return this
};
Tween.prototype.start = function(a) {
    TweenManager.instance.add(this);
    this._onStartCallbackFired = !1;
    this._startTime = void 0 !== a ? a : "undefined" !== typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now();
    this._startTime += this._delayTime;
    for (var b in this._valuesEnd) {
        if (this._valuesEnd[b] instanceof Array) {
            if (0 === this._valuesEnd[b].length) continue;
            this._valuesEnd[b] = [this._object[b]].concat(this._valuesEnd[b])
        }
        this._valuesStart[b] = this._object[b];
        !1 ===
            this._valuesStart[b] instanceof Array && (this._valuesStart[b] *= 1);
        this._valuesStartRepeat[b] = this._valuesStart[b] || 0
    }
    return this
};
Tween.prototype.stop = function() {
    TweenManager.instance.remove(this);
    return this
};
Tween.prototype.delay = function(a) {
    this._delayTime = a;
    return this
};
Tween.prototype.repeat = function(a) {
    this._repeat = a;
    return this
};
Tween.prototype.yoyo = function(a) {
    this._yoyo = a;
    return this
};
Tween.prototype.easing = function(a) {
    this._easingFunction = a;
    return this
};
Tween.prototype.interpolation = function(a) {
    this._interpolationFunction = a;
    return this
};
Tween.prototype.chain = function() {
    this._chainedTweens = arguments;
    return this
};
Tween.prototype.onStart = function(a) {
    this._onStartCallback = a;
    return this
};
Tween.prototype.onUpdate = function(a) {
    this._onUpdateCallback = a;
    return this
};
Tween.prototype.onComplete = function(a) {
    this._onCompleteCallback = a;
    return this
};
Tween.prototype.update = function(a) {
    var b;
    if (a < this._startTime) return !0;
    !1 === this._onStartCallbackFired && (null !== this._onStartCallback && this._onStartCallback.call(this._object, this), this._onStartCallbackFired = !0);
    var c = (a - this._startTime) / this._duration,
        c = 1 < c ? 1 : c,
        d = this._easingFunction(c);
    for (b in this._valuesEnd) {
        var e = this._valuesStart[b] || 0,
            f = this._valuesEnd[b];
        f instanceof Array ? this._object[b] = this._interpolationFunction(f, d) : ("string" === typeof f && (f = e + parseFloat(f)), "number" === typeof f && (this._object[b] =
            e + (f - e) * d))
    }
    if (1 == c) {
        if (0 < this._repeat) {
            isFinite(this._repeat) && this._repeat--;
            for (b in this._valuesStartRepeat) "string" === typeof this._valuesEnd[b] && (this._valuesStartRepeat[b] += parseFloat(this._valuesEnd[b])), this._yoyo && (c = this._valuesStartRepeat[b], this._valuesStartRepeat[b] = this._valuesEnd[b], this._valuesEnd[b] = c, this._reversed = !this._reversed), this._valuesStart[b] = this._valuesStartRepeat[b];
            this._startTime = a + this._delayTime;
            return !0
        }
        null !== this._onCompleteCallback && this._onCompleteCallback.call(this._object,
            this);
        b = 0;
        for (c = this._chainedTweens.length; b < c; b++) this._chainedTweens[b].start(a);
        return !1
    }
    null !== this._onUpdateCallback && null !== this._object && this._onUpdateCallback.call(this._object, this);
    return !0
};

function Common() {}
Common.saveData = function(a, b) {
    var c = new Date;
    c.setDate(c.getDate() + Common.COOKIE_EXPIRATION_DAYS);
    c = "; expires=" + c.toUTCString();
    document.cookie = a + "=" + b + c + "; path=/"
};
Common.COOKIE_EXPIRATION_DAYS = 1E3;
Common.loadData = function(a, b) {
    for (var c = a + "=", d = document.cookie.split(";"), e = 0; e < d.length; ++e) {
        for (var f = d[e];
            " " === f.charAt(0);) f = f.substring(1, f.length);
        if (0 === f.indexOf(c)) return f.substring(c.length, f.length)
    }
    return b
};
Common.storageString = function(a, b) {
    b = "undefined" !== typeof b ? b : "|";
    for (var c = "", d = 0; d < a.length; d++) c += 0 !== d ? b : "", c += a[d];
    return c
};
Common.copyNumericArray = function(a) {
    for (var b = [], c = 0; c < a.length; c++) b.push(a[c]);
    return b
};
Common.initArray = function(a, b) {
    for (var c = [], d = 0; d < b; d++) c.push(a);
    return c
};
Common.inArray = function(a, b) {
    return -1 !== b.indexOf(a)
};
Common.random = function(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a
};
Common.randomInt = function(a, b) {
    return a + Math.floor(Math.random() * (b - a + 1))
};
Common.mixer = function(a) {
    a = a.slice(0);
    for (var b = 0, c = 0; c < a.length; c++) b = Math.round(Math.random() * (a.length - 1 - c)) + c, a.splice(c, 0, a[b]), a.splice(b + 1, 1);
    return a
};
Common.getRandomArrayIndex = function(a, b) {
    if (1 < a) {
        for (var c = Common.randomInt(0, a - 1); c == b;) c = (c + 1) % a;
        return c
    }
    return 0
};
Common.getRandomFromArray = function(a, b) {
    var c = a.length;
    if (1 < c) {
        if ("undefined" !== typeof b) {
            for (var d = [], e = 0; e < c; ++e) a[e] !== b && d.push(e);
            if (0 < d.length) return a[d[Math.floor(d.length * Math.random())]]
        }
        return a[Math.floor(c * Math.random())]
    }
    return 1 === c ? a[0] : null
};
Common.randomAndSpliceFromArray = function(a) {
    return a.splice(Common.random(0, a.length - 1), 1)
};
Common.shuffleArray = function(a) {
    for (var b, c, d = a.length - 1; 1 <= d; --d) b = Math.floor(Math.random() * (d + 1)), c = a[b], a[b] = a[d], a[d] = c
};
Common.getParams = function(a) {
    var b = {};
    a = a.split(";");
    for (var c = 0; c < a.length; c++)
        for (var d = a[c].split(":"), e = 0; e < d.length; e++) b[String(d[0]).concat()] = d[1];
    return b
};
Common.lengthObject = function(a) {
    var b = 0,
        c;
    for (c in a) a.hasOwnProperty(c) && ++b;
    return b
};
Common.parseRect = function(a) {
    a = a.split(";");
    return 4 !== a.length ? null : new Rectangle(parseInt(a[0], 10), parseInt(a[1], 10), parseInt(a[2], 10), parseInt(a[3], 10))
};
Common.trim = function(a) {
    return String(a).replace(/^\s*(.*?)\s*$/g, "$1")
};
Common.sumArray = function(a) {
    for (var b = 0, c = 0; c < a.length; c++) b += a[c];
    return b
};
Common.parseNum = function(a) {
    return 10 > a ? "0" + a : "" + a
};
Common.circumferenceAngle = function(a, b) {
    var c = Math.atan2(b, a),
        c = 180 / Math.PI * c;
    return 0 > c ? 360 + c : c
};
Common.tween = function(a, b, c, d, e, f) {
    a = (new Tween(a)).to(b, c).easing("undefined" === typeof f ? TweenEasing.BackOut : f).onUpdate(Common.tweenUpdate).onComplete(Common.tweenComplete).delay("undefined" === typeof e ? 0 : e);
    Common.tweenUpdate(a, !0);
    d && a.start();
    return a
};
Common.tweenUpdate = function(a, b) {
    try {
        var c = a.target.parent,
            d = a.target.clip;
        c && a.target.onUpdate && !b && a.target.onUpdate.call(c, a.target);
        if (d)
            for (var e in a.target) switch (e) {
                case "alpha":
                    var f = 1 < a.target.alpha ? 1 : a.target.alpha,
                        f = 0 > a.target.alpha ? 0 : f;
                    d.alpha = f;
                    break;
                case "sx":
                    d.scale.x = a.target.sx;
                    break;
                case "sy":
                    d.scale.y = a.target.sy;
                    break;
                case "scale":
                    d.scale.x = a.target.scale;
                    d.scale.y = a.target.scale;
                    break;
                case "x":
                    d.position.x = a.target.x;
                    break;
                case "y":
                    d.position.y = a.target.y;
                    break;
                case "rotation":
                    d.rotation =
                        a.target.rotation
            }
    } catch (g) {
        Application.warn(" Tween onUpdate ::" + g)
    }
};
Common.tweenComplete = function(a) {
    try {
        var b = a.target.parent,
            c = a.target.clip;
        b && a.target.onComplete && (a.target.onComplete.call(b, a.target), a.target.parent = null, a.target.onComplete = null);
        if (c)
            for (var d in a._valuesEnd) switch (d) {
                case "alpha":
                    var e = 1 < a._valuesEnd.alpha ? 1 : a._valuesEnd.alpha,
                        e = 0 > a._valuesEnd.alpha ? 0 : e;
                    c.alpha = e;
                    break;
                case "sx":
                    c.scale.x = a._valuesEnd.sx;
                    break;
                case "sy":
                    c.scale.y = a._valuesEnd.sy;
                    break;
                case "scale":
                    c.scale.x = a._valuesEnd.scale;
                    c.scale.y = a._valuesEnd.scale;
                    break;
                case "x":
                    c.position.x =
                        a._valuesEnd.x;
                    break;
                case "y":
                    c.position.y = a._valuesEnd.y;
                    break;
                case "rotation":
                    c.rotation = a._valuesEnd.rotation
            }
    } catch (f) {
        Application.warn(" Tween onComplete ::" + f)
    }
};
Common.distance = function(a, b, c, d) {
    return Math.sqrt((c - a) * (c - a) + (d - b) * (d - b))
};
Common.distanceSquared = function(a, b, c, d) {
    return (c - a) * (c - a) + (d - b) * (d - b)
};
Common.makeClockTime = function(a) {
    var b = {};
    a = Math.ceil(a / 1E3);
    var c = Math.floor(a / 60),
        d = Math.floor(a % 60);
    b.total = a;
    b.minutes = c;
    b.seconds = d;
    return b
};
Common.getDigitsByValue = function(a, b) {
    for (var c = String(a), d = [], d = b - c.length, e = 0; e < d; e++) c = "0" + c;
    return d = c.split("")
};
Common.getData = function(a, b) {
    if (null === a) Application.error("Common:: data is null");
    else if (null === b) Application.error("Common:: data is null: " + b);
    else {
        if ("undefined" !== typeof a[b]) return a[b];
        Application.error("Property not found: " + b)
    }
    return null
};
Common.getOptionalData = function(a, b, c) {
    if ("undefined" === typeof a) Application.error("Common:: data is undefined");
    else if ("undefined" === typeof b) Application.error("Common:: data is undefined: " + b);
    else {
        if ("undefined" !== typeof a[b]) return a[b];
        Application.warn("Optional property not found: " + b + " using: " + c);
        return c
    }
    return null
};
Common.isValidNumber = function(a) {
    return "number" !== typeof a || isNaN(a) || !isFinite(a) ? !1 : !0
};
Common.sparseInt = function(a, b) {
    var c = parseInt(a, 10);
    return isNaN(c) ? b : c
};
Common.sparseFloat = function(a, b) {
    var c = parseFloat(a);
    return isNaN(c) ? b : c
};
Common.ajaxRequest = function() {
    var a = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Microsoft.XMLHTTP"];
    if (window.ActiveXObject)
        for (var b = 0; b < a.length; b++) try {
            return new window.ActiveXObject(a[b])
        } catch (c) {} else if (window.XMLHttpRequest) return new window.XMLHttpRequest;
    return null
};
Common.randomRangeInt = function(a, b) {
    return a - b + Math.floor(Math.random() * (2 * b + 1))
};
Common.randomRangeFloat = function(a, b) {
    return a - b + 2 * Math.random() * b
};
Common.trunc = function(a) {
    return 0 > a ? Math.ceil(a) : Math.floor(a)
};
Common.colorDecimalToHex = function(a) {
    return a % 1E3 + (Common.trunc(a / 1E3) % 1E3 << 8) + (Common.trunc(a / 1E6) % 1E3 << 16)
};
Common.getR = function(a) {
    return a >> 16 & 255
};
Common.getG = function(a) {
    return a >> 8 & 255
};
Common.getB = function(a) {
    return a & 255
};
Common.getR_float = function(a) {
    return Common.getR(a) / 255
};
Common.getG_float = function(a) {
    return Common.getG(a) / 255
};
Common.getB_float = function(a) {
    return Common.getB(a) / 255
};
Common.validateRandom = function(a, b) {
    var c = 0;
    return c = a < b ? Common.trunc(Common.randomInt(a, b)) : a == b ? a : Common.trunc(Common.randomInt(b, a))
};
Common.gradToRadian = function(a) {
    return .017453292519943295 * a
};
Common.lerp = function(a, b, c, d) {
    return d / 1E3 * c * (b - a)
};
Common.createArraySize = function(a, b) {
    if (Array.prototype.fill) return Array(a).fill(b);
    for (var c = [], d = 0; d < a; d++) c.push(b);
    return c
};
Common.KEY_1 = 49;
Common.KEY_2 = 50;
Common.KEY_3 = 51;
Common.KEY_4 = 52;
Common.KEY_5 = 53;
Common.KEY_6 = 54;
Common.KEY_7 = 55;
Common.KEY_8 = 56;
Common.KEY_9 = 57;
Common.KEY_0 = 48;
Common.KEY_A = 65;
Common.KEY_B = 66;
Common.KEY_C = 67;
Common.KEY_D = 68;
Common.KEY_E = 69;
Common.KEY_F = 70;
Common.KEY_G = 71;
Common.KEY_H = 72;
Common.KEY_I = 73;
Common.KEY_J = 74;
Common.KEY_K = 75;
Common.KEY_L = 76;
Common.KEY_M = 77;
Common.KEY_N = 78;
Common.KEY_O = 79;
Common.KEY_P = 80;
Common.KEY_Q = 81;
Common.KEY_R = 82;
Common.KEY_S = 83;
Common.KEY_T = 84;
Common.KEY_U = 85;
Common.KEY_V = 86;
Common.KEY_W = 87;
Common.KEY_X = 88;
Common.KEY_Z = 90;
Common.KEY_ESC = 27;
Common.KEY_SPACE = 32;
Common.KEY_ENTER = 13;
Common.KEY_LEFT = 37;
Common.KEY_RIGHT = 39;
Common.KEY_DOWN = 40;
Common.KEY_UP = 38;
Common.COLOR_NONE = "rgba(0, 0, 0, 0)";
Common.COLOR_RED = "#FF0000";
Common.COLOR_GREEN = "#00FF00";
Common.COLOR_BLUE = "#0000FF";
Common.COLOR_BLACK = "#000000";
Common.COLOR_WHITE = "#FFFFFF";
Common.COLOR_ORANGE = "#FF9900";
Common.COLOR_MAGENTA = "#FF00FF";
Common.COLOR_PURPLE = "#990066";
Common.COLOR_PINK = "#FF66FF";
Common.COLOR_BROWN = "#663300";
Common.COLOR_YELLOW = "#FFFF00";
Common.COLOR_GREY = "#666666";
Common.COLOR_DARK_BLUE = "#000066";

function ContextGraphics() {}
ContextGraphics.drawLine = function(a, b, c, d, e, f, g) {
    Application.RENDER_MODE === Application.RENDER_CANVAS && (a.beginPath(), a.strokeStyle = "undefined" === typeof f ? Common.COLOR_BLACK : f, a.lineWidth = "undefined" === typeof g ? 1 : g, a.moveTo(b, c), a.lineTo(d, e), a.stroke(), a.closePath())
};
ContextGraphics.drawRectangle = function(a, b, c, d, e, f, g, h) {
    Application.RENDER_MODE === Application.RENDER_CANVAS && (a.strokeStyle = "undefined" === typeof g ? Common.COLOR_BLUE : g, a.lineWidth = "undefined" === typeof f ? 1 : f, a.fillStyle = "undefined" === typeof h ? "rgba(0, 0, 0, 0)" : h, a.fillRect(b, c, d, e), a.strokeRect(b, c, d, e))
};
ContextGraphics.drawRect = function(a, b, c, d) {
    Application.RENDER_MODE === Application.RENDER_CANVAS && (a.strokeStyle = "undefined" === typeof c ? Common.COLOR_BLUE : c, a.fillStyle = "undefined" === typeof d ? "rgba(0, 0, 0, 0)" : d, a.lineWidth = 1, a.fillRect(b.x, b.y, b.w, b.h), a.strokeRect(b.x, b.y, b.w, b.h))
};
ContextGraphics.drawCircle = function(a, b, c, d, e, f) {
    Application.RENDER_MODE === Application.RENDER_CANVAS && (a.beginPath(), a.lineWidth = 1, a.strokeStyle = "undefined" === typeof e ? Common.COLOR_BLUE : e, a.arc(b, c, d, 0, 2 * Math.PI, !0), a.stroke(), a.fillStyle = "undefined" === typeof f ? "rgba(0, 0, 0, 0)" : f, a.fill(), a.closePath())
};
ContextGraphics.drawArc = function(a, b, c, d, e, f, g, h) {
    Application.RENDER_MODE === Application.RENDER_CANVAS && (a.beginPath(), a.strokeStyle = "undefined" === typeof g ? Common.COLOR_BLUE : g, a.fillStyle = "undefined" === typeof h ? "rgba(0, 0, 0, 0)" : h, a.lineWidth = 1, a.arc(b, c, d, e, f, !0), a.closePath(), a.stroke(), a.fill())
};
ContextGraphics.drawCross = function(a, b, c, d, e, f) {
    Application.RENDER_MODE === Application.RENDER_CANVAS && (a.beginPath(), a.strokeStyle = "undefined" === typeof e ? Common.COLOR_GREEN : e, a.lineWidth = "undefined" === typeof f ? 1 : f, a.moveTo(b - d, c - d), a.lineTo(b + d, c + d), a.moveTo(b - d, c + d), a.lineTo(b + d, c - d), a.stroke(), a.closePath())
};
ContextGraphics.drawArrow = function(a, b, c, d, e, f, g, h) {
    Application.RENDER_MODE === Application.RENDER_CANVAS && (a.beginPath(), a.strokeStyle = "undefined" === typeof f ? Common.COLOR_YELLOW : f, a.lineWidth = "undefined" === typeof h ? 1 : h, "undefined" === typeof g && (g = 5), a.moveTo(b, c), a.lineTo(d, e), b = new SVector3(d - b, e - c), b.normalize(), a.lineTo(d - g * (b.x + b.y), e - g * (b.y - b.x)), a.moveTo(d, e), a.lineTo(d - g * (b.x - b.y), e - g * (b.y + b.x)), a.stroke(), a.closePath())
};
ContextGraphics.drawPath = function(a, b, c, d) {
    if (Application.RENDER_MODE === Application.RENDER_CANVAS) {
        var e = b.length;
        if (!(3 > e)) {
            a.beginPath();
            a.moveTo(b[0][0], b[0][1]);
            for (var f = 1; f < e - 2; ++f) a.quadraticCurveTo(b[f][0], b[f][1], (b[f][0] + b[f + 1][0]) / 2, (b[f][1] + b[f + 1][1]) / 2);
            a.quadraticCurveTo(b[f][0], b[f][1], b[f + 1][0], b[f + 1][1]);
            a.strokeStyle = "undefined" === typeof c ? Common.COLOR_RED : c;
            a.lineWidth = "undefined" === typeof d ? 1 : d;
            a.stroke();
            a.closePath()
        }
    }
};
ContextGraphics.drawBezier = function(a, b, c, d) {
    Application.RENDER_MODE === Application.RENDER_CANVAS && (a.beginPath(), a.moveTo(b[0].x, b[0].y), a.quadraticCurveTo(b[1].x, b[1].y, b[2].x, b[2].y), a.strokeStyle = "undefined" === typeof c ? Common.COLOR_RED : c, a.lineWidth = "undefined" === typeof d ? 1 : d, a.stroke(), a.closePath())
};
ContextGraphics.drawQuad = function(a, b, c, d, e, f, g) {
    Application.RENDER_MODE === Application.RENDER_CANVAS && (a.strokeStyle = "undefined" === typeof f ? Common.COLOR_BLUE : f, a.lineWidth = "undefined" === typeof g ? 1 : g, a.strokeRect(b, c, d, e))
};

function VirtualStick(a, b, c, d) {
    VirtualStick.NONE = -100;
    this.maxForce = "undefined" === typeof b ? 0 : b;
    this.x = "undefined" === typeof c ? 0 : c;
    this.y = "undefined" === typeof d ? 0 : d;
    this.anchor = 0 === this.x && 0 === this.y ? !1 : !0;
    this.identifier = VirtualStick.NONE;
    this.forceY = this.forceX = this.angle = this.force = 0;
    this.canvas = a;
    this.clipBase = Application.instance.getClip("mcUIStickBase");
    this.clipPointer = Application.instance.getClip("mcUIStickPointer");
    this.canvas.addChild(this.clipBase);
    this.canvas.addChild(this.clipPointer);
    this.clipBase.scale.x = 1.5;
    this.clipBase.scale.y = 1.5;
    this.clipBase.setPosition(c, d);
    this.clipPointer.scale.x = 1.5;
    this.clipPointer.scale.y = 1.5;
    this.clipPointer.setPosition(c, d);
    this.m_rectangleCollision = new Rectangle(c - 71, d - 71, 142, 142);
    this.anchor || (this.clipBase.visible = !1, this.clipPointer.visible = !1);
    this.m_callbackChangeFunction = this.m_callbackChangeObject = this.m_callbackReleaseFunction = this.m_callbackReleaseObject = this.m_callbackPressFunction = this.m_callbackPressObject = null
}
VirtualStick.prototype.free = function() {
    this.m_callbackChangeFunction = this.m_callbackChangeObject = this.m_callbackReleaseFunction = this.m_callbackReleaseObject = this.m_callbackPressFunction = this.m_callbackPressObject = null;
    this.canvas.removeChild(this.clipBase);
    this.canvas.removeChild(this.clipPointer);
    this.clipBase.free();
    this.clipBase = null;
    this.clipPointer.free();
    this.canvas = this.m_rectangleCollision = this.clipPointer = null
};
VirtualStick.prototype.addPressListener = function(a, b) {
    this.m_callbackPressObject = a;
    this.m_callbackPressFunction = b
};
VirtualStick.prototype.addReleaseListener = function(a, b) {
    this.m_callbackReleaseObject = a;
    this.m_callbackReleaseFunction = b
};
VirtualStick.prototype.addChangeListener = function(a, b) {
    this.m_callbackChangeObject = a;
    this.m_callbackChangeFunction = b
};
VirtualStick.prototype.onPointerPress = function(a) {
    var b = a.data.global.x,
        c = a.data.global.y;
    this.identifier === VirtualStick.NONE && this.m_rectangleCollision.intersectPoint(b, c) && (this.anchor || (this.x = b, this.y = c, this.clipBase.setPosition(this.x, this.y), this.clipPointer.setPosition(this.x, this.y)), this.clipBase.visible = !0, this.clipPointer.visible = !0, this.identifier = this.getIdentifier(a), null !== this.m_callbackPressObject && null !== this.m_callbackPressFunction && this.m_callbackPressFunction.call(this.m_callbackPressObject,
        this))
};
VirtualStick.prototype.onPointerRelease = function(a) {
    this.identifier === this.getIdentifier(a) && (this.anchor || (this.clipBase.visible = !1, this.clipPointer.visible = !1), this.angle = this.force = 0, this.clipPointer.setPosition(this.x, this.y), this.identifier = VirtualStick.NONE, null !== this.m_callbackReleaseObject && null !== this.m_callbackReleaseFunction && this.m_callbackReleaseFunction.call(this.m_callbackReleaseObject, this))
};
VirtualStick.prototype.onPointerMove = function(a) {
    this.identifier === this.getIdentifier(a) && (this.force = Math.sqrt((a.data.global.x - this.x) * (a.data.global.x - this.x) + (a.data.global.y - this.y) * (a.data.global.y - this.y)), this.angle = Math.atan2(a.data.global.y - this.y, a.data.global.x - this.x), 0 < this.maxForce && this.force > this.maxForce && (this.force = this.maxForce), this.forceX = this.force * Math.cos(this.angle), this.forceY = this.force * Math.sin(this.angle), this.clipPointer.setPosition(this.x + this.forceX, this.y + this.forceY),
        null !== this.m_callbackChangeObject && null !== this.m_callbackChangeFunction && this.m_callbackChangeFunction.call(this.m_callbackChangeObject, this))
};
VirtualStick.prototype.getIdentifier = function(a) {
    return "undefined" !== typeof a.data.identifier ? a.data.identifier : a.data.originalEvent.which
};

function TouchControl() {
    this.onActiveAction = null;
    this.m_currentTime = 0;
    this.m_lock = !1;
    this.m_lastId = this.m_counterTouch = 0;
    this.m_maxTouch = 2;
    this.m_timeReset = 400;
    this.playerTarget = null
}
TouchControl.prototype.update = function(a) {
    this.m_currentTime += a;
    this.m_currentTime > this.m_timeReset && (this.m_counterTouch = this.m_currentTime = 0)
};
TouchControl.prototype.sense = function(a) {
    if (!this.m_lock) {
        this.m_counterTouch++;
        this.m_lock = !0;
        this.m_currentTime = 0;
        if (this.m_counterTouch >= this.m_maxTouch)
            if (this.m_lastId == a) {
                if (this.onActiveAction && this.playerTarget) this.playerTarget[this.onActiveAction]();
                this.m_counterTouch = 0
            } else this.m_counterTouch = 1;
        this.m_lastId = a
    }
};
TouchControl.prototype.unlock = function() {
    this.m_lock = !1
};
TouchControl.prototype.reset = function() {
    this.m_counterTouch = this.m_currentTime = 0
};

function TintInterval(a, b, c, d) {
    this.m_timeFrecuency = 0;
    this.m_timeFrecuencyElapse = c;
    this.m_timeDuration = b;
    this.m_indexColor = this.m_timeElapse = 0;
    this.m_clip = a;
    this.m_colors = "undefined" === typeof d ? null : d;
    this.m_start = !1;
    this.target = null
}
TintInterval.prototype.start = function(a, b) {
    a = "undefined" === typeof a ? 0 : a;
    b = "undefined" === typeof b ? 0 : b;
    0 != a && (this.m_timeDuration = a);
    0 != b && (this.m_timeFrecuency = b);
    this.m_start = !0;
    this.m_timeFrecuencyElapse = this.m_timeElapse = 0;
    this.change()
};
TintInterval.prototype.stop = function() {
    if (this.m_start) {
        if (this.onFinish && this.target) this.target[this.onFinish]();
        this.m_start = !1;
        this.m_indexColor = 0;
        this.change()
    }
};
TintInterval.prototype.setColors = function(a) {
    this.m_colors = a
};
TintInterval.prototype.setClip = function(a) {
    this.m_clip = a;
    this.m_clip.setTint(this.m_colors[this.m_indexColor])
};
TintInterval.prototype.update = function(a) {
    if (this.m_start && (this.m_timeElapse += a, this.m_timeFrecuencyElapse += a, this.m_timeFrecuencyElapse >= this.m_timeFrecuency && (this.change(), this.m_timeFrecuencyElapse = 0), this.m_timeElapse >= this.m_timeDuration && (this.m_start = !1, this.m_indexColor = 0, this.m_clip.setTint(16777215), this.onFinish && this.target))) this.target[this.onFinish]()
};
TintInterval.prototype.change = function() {
    this.m_clip.setTint(this.m_colors[this.m_indexColor]);
    this.m_indexColor++;
    this.m_indexColor >= this.m_colors.length && (this.m_indexColor = 0)
};
TintInterval.prototype.free = function() {
    this.target = this.m_colors = this.m_clip = this.onFinish = null
};

function SInterval(a, b, c, d, e, f, g) {
    "undefined" === typeof d && (d = 1);
    "undefined" === typeof f && (f = !1);
    this.m_timeElapsed = 0;
    this.m_timeToTrigger = c;
    this.m_initLoops = this.m_loop = d;
    this.m_stopped = f;
    this.m_isOver = !1;
    this.m_caller = a;
    this.m_params = e;
    this.m_onEndCallback = b;
    this.m_onLoopCallback = g
}
SInterval.prototype.reset = function(a) {
    a = "undefined" === typeof a ? -1 : a;
    0 < a && (this.m_timeToTrigger = a);
    this.m_timeElapsed = 0;
    this.m_loop = this.m_initLoops;
    this.m_stopped = this.m_isOver = !1
};
SInterval.prototype.stop = function() {
    this.m_stopped = !0
};
SInterval.prototype.resume = function() {
    this.m_stopped = !1
};
SInterval.prototype.update = function(a) {
    if (!this.m_stopped && !this.m_isOver && (this.m_timeElapsed += a, this.m_timeElapsed >= this.m_timeToTrigger))
        if (this.m_timeElapsed = 0, --this.m_loop, 0 >= this.m_loop) {
            if (this.m_isOver = !0, this.m_onEndCallback)
                if (this.m_params) this.m_caller[this.m_onEndCallback](this.m_params);
                else this.m_caller[this.m_onEndCallback]()
        } else if (this.m_onLoopCallback)
        if (this.m_params) this.m_caller[this.m_onLoopCallback](this.m_params);
        else this.m_caller[this.m_onLoopCallback]()
};
SInterval.prototype.free = function() {
    this.m_caller = null
};

function SPoint(a, b) {
    this.x = "undefined" === typeof a ? 0 : a;
    this.y = "undefined" === typeof b ? 0 : b
}
SPoint.prototype.distanceTo = function(a, b) {
    return Math.sqrt((a - this.x) * (a - this.x) + (b - this.y) * (b - this.y))
};

function SVector3(a, b, c) {
    this.x = "undefined" === typeof a ? 0 : a;
    this.y = "undefined" === typeof b ? 0 : b;
    this.z = "undefined" === typeof c ? 0 : c
}
SVector3.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
};
SVector3.prototype.normalize = function() {
    var a = this.x * this.x + this.y * this.y + this.z * this.z;
    0 < a && (a = Math.sqrt(a), this.x /= a, this.y /= a, this.z /= a);
    return this
};
SVector3.prototype.product = function(a) {
    return new SVector3(this.y * a.z - this.z * a.y, -(this.x * a.z - this.z * a.x), this.y * a.x - this.x * a.y)
};

function Movement(a, b, c, d, e) {
    this.m_targetY = this.m_targetX = this.m_oldState = 0;
    this.m_x = a;
    this.m_y = b;
    this.m_speed = 0;
    this.m_typeMovement = Movement.TYPE_DEFAULT;
    this.m_isLoop = "undefined" === typeof d ? !1 : d;
    this.m_isReversible = "undefined" === typeof e ? !1 : e;
    this.m_isAwaitingDelete = !1;
    this.m_cycleCallback = this.m_endCallback = this.m_callerActor = null;
    this.setSpeed(c);
    this.m_state = Movement.ST_INIT
}
Movement.prototype.free = function() {
    this.m_callerActor = this.m_cycleCallback = this.m_endCallback = null
};
Movement.TYPE_DEFAULT = 0;
Movement.TYPE_CIRCLE = 1;
Movement.TYPE_LINEAR = 2;
Movement.MIN_SPEED = 1E-5;
Movement.DEFAULT_SPEED = 1;
Movement.ST_INDEF = -1;
Movement.ST_INIT = 0;
Movement.ST_MOVEMENT = 1;
Movement.ST_PAUSED = 2;
Movement.ST_END = 3;
Movement.prototype.getX = function() {
    return this.m_x
};
Movement.prototype.getY = function() {
    return this.m_y
};
Movement.prototype.getSpeed = function() {
    return this.m_speed
};
Movement.prototype.setSpeed = function(a) {
    a > Movement.MIN_SPEED ? this.m_speed = a : (Application.error("setSpeed: " + a), this.m_speed = Movement.DEFAULT_SPEED)
};
Movement.prototype.type = function() {
    return this.m_typeMovement
};
Movement.prototype.targetX = function() {
    return this.m_targetX
};
Movement.prototype.targetY = function() {
    return this.m_targetY
};
Movement.prototype.isAwaitingDelete = function() {
    return this.m_isAwaitingDelete
};
Movement.prototype.setAwaitingToDelete = function(a) {
    if (this.m_isAwaitingDelete = a) this.m_state = Movement.ST_INDEF
};
Movement.prototype.isPaused = function() {
    return this.m_state == Movement.ST_PAUSED
};
Movement.prototype.setPause = function(a) {
    a ? this.m_state === Movement.ST_MOVEMENT && (this.m_oldState = this.m_state, this.m_state = Movement.ST_PAUSED) : this.m_state = this.m_oldState
};
Movement.prototype.setCallbacks = function(a, b, c) {
    this.m_callerActor = a;
    this.m_endCallback = b;
    this.m_cycleCallback = c
};
Movement.prototype.resetPosition = function(a, b) {
    return this.m_state !== Movement.ST_MOVEMENT && this.m_state !== Movement.ST_PAUSED ? (this.m_x = a, this.m_y = b, !0) : !1
};
Movement.prototype.cancelMotion = function() {
    this.m_state = Movement.ST_END
};
Movement.prototype.onEndMovement = function() {
    this.m_state = Movement.ST_END;
    this.m_callerActor && this.m_endCallback && this.m_endCallback.call(this.m_callerActor, this)
};
Movement.prototype.onCycleEnd = function() {
    this.m_callerActor && this.m_cycleCallback && this.m_cycleCallback.call(this.m_callerActor, this)
};
Movement.prototype.update = function(a) {};

function LinearMovement(a, b, c, d, e) {
    Movement.call(this, a, b, c, d, e);
    this.m_vy = this.m_vx = this.m_angle = 0;
    this.m_toFront = !0;
    this.m_initX = this.m_x;
    this.m_initY = this.m_y;
    this.m_endPointY = this.m_endPointX = 0;
    this.m_motionLimit = new Rectangle;
    this.m_typeMovement = Movement.TYPE_LINEAR
}
Application.subclass(LinearMovement, Movement);
LinearMovement.prototype.free = function() {
    this.m_motionLimit = null;
    Movement.prototype.free.call(this)
};
LinearMovement.prototype.getAngle = function() {
    return this.m_angle
};
LinearMovement.prototype.getLinearVelocityX = function() {
    return this.m_vx
};
LinearMovement.prototype.getLinearVelocityY = function() {
    return this.m_vy
};
LinearMovement.prototype.resetPosition = function(a, b) {
    return Movement.prototype.resetPosition.call(this, a, b) ? (this.m_initX = a, this.m_initY = b, !0) : !1
};
LinearMovement.prototype.settingMotionLimit = function(a, b, c, d) {
    this.m_motionLimit.x = 0 <= c ? a : a + c;
    this.m_motionLimit.y = 0 <= d ? b : b + d;
    this.m_motionLimit.w = 0 <= c ? c : -c;
    this.m_motionLimit.h = 0 <= d ? d : -d
};
LinearMovement.prototype.gotoPosition = function(a, b, c) {
    c = "undefined" !== typeof c ? c : 0;
    this.m_endPointX = this.m_targetX = a;
    this.m_endPointY = this.m_targetY = b;
    a -= this.m_x;
    b -= this.m_y;
    if (0 === a && 0 === b) this.onEndMovement();
    else this.settingMotionLimit(this.m_x, this.m_y, a, b), 0 < c && (this.m_speed = c), c = Math.sqrt(a * a + b * b), this.m_vx = a / c * this.m_speed, this.m_vy = b / c * this.m_speed, this.m_angle = Math.atan2(b, a), this.m_state = Movement.ST_MOVEMENT
};
LinearMovement.prototype.gotoRadialPoint = function(a, b, c) {
    c = "undefined" !== typeof c ? c : 0;
    0 > a && (Application.error("LinearMovement::gotoRadialPoint() - distance: " + a), a *= -1);
    if (0 === a) this.onEndMovement();
    else {
        this.m_angle = b;
        b = a * Math.cos(this.m_angle);
        var d = a * Math.sin(this.m_angle);
        this.settingMotionLimit(this.m_x, this.m_y, b, d);
        0 < c && (this.m_speed = c);
        this.m_vx = b / a * this.m_speed;
        this.m_vy = d / a * this.m_speed;
        this.m_endPointX = this.m_targetX = this.m_x + b;
        this.m_endPointY = this.m_targetY = this.m_y + d;
        this.m_state = Movement.ST_MOVEMENT
    }
};
LinearMovement.prototype.simulateUpdate = function(a) {
    var b = null;
    this.m_state === Movement.ST_MOVEMENT && (b = new Vector2D(this.m_vx * a, this.m_vy * a));
    return b
};
LinearMovement.prototype.update = function(a) {
    if (this.m_state === Movement.ST_MOVEMENT && (this.m_x += this.m_vx * a, this.m_y += this.m_vy * a, !(0 >= a) && (this.m_x < this.m_motionLimit.left() || this.m_x > this.m_motionLimit.right() || this.m_y < this.m_motionLimit.top() || this.m_y > this.m_motionLimit.bottom())))
        if (this.m_x = this.m_endPointX, this.m_y = this.m_endPointY, this.m_isLoop) this.m_isReversible ? (this.m_toFront ? (this.m_endPointX = this.m_initX, this.m_endPointY = this.m_initY) : (this.m_endPointX = this.m_targetX, this.m_endPointY =
            this.m_targetY), this.m_toFront = !this.m_toFront, this.m_vx *= -1, this.m_vy *= -1) : (this.m_x = this.m_initX, this.m_y = this.m_initY), this.onCycleEnd();
        else this.onEndMovement()
};

function CircularMovement(a, b, c, d, e) {
    Movement.call(this, a, b, c, "undefined" === typeof d ? !1 : d, "undefined" === typeof e ? !1 : e);
    this.m_currentRadiansDisplaced = this.m_radiansToDisplace = this.m_initRandians = 0;
    this.m_factorDirection = 1;
    this.m_angularSpeed = this.m_radio = this.m_centroidY = this.m_centroidX = this.m_oldY = this.m_oldX = 0;
    this.m_typeMovement = Movement.TYPE_CIRCLE;
    this.m_oldX = this.m_x;
    this.m_oldY = this.m_y
}
Application.subclass(CircularMovement, Movement);
CircularMovement.prototype.startMovement = function(a, b, c) {
    this.m_centroidX = a;
    this.m_centroidY = b;
    a = this.m_x - this.m_centroidX;
    b = -this.m_y + this.m_centroidY;
    this.m_radio = Math.sqrt(a * a + b * b);
    if (1 >= this.m_radio) Application.error("CircularMovement::startMovement() - Radio very small: " + this.m_radio), this.onEndMovement();
    else if (this.m_factorDirection = 0 > c ? -1 : 1, 0 == c) this.onEndMovement();
    else 0 > c && (c *= -1), this.m_initRandians = Math.atan2(b, a), this.m_radiansToDisplace = c / 180 * Math.PI, this.m_currentRadiansDisplaced =
        0, this.m_angularSpeed = this.m_radiansToDisplace / (c / 360 * Math.PI * this.m_radio * 2 / this.m_speed), c = this.m_initRandians + this.m_radiansToDisplace * this.m_factorDirection, this.m_targetX = this.m_centroidX + this.m_radio * Math.cos(c), this.m_targetY = this.m_centroidY - this.m_radio * Math.sin(c), this.m_state = Movement.ST_MOVEMENT
};
CircularMovement.prototype.startMovement2 = function(a, b, c) {
    this.m_radio = a;
    if (1 >= this.m_radio) Application.error("CircularMovement::startMovement2() - Radio very small: " + this.m_radio), this.onEndMovement();
    else if (this.m_factorDirection = 0 > c ? -1 : 1, 0 == c) this.onEndMovement();
    else 0 > c && (c *= -1), this.m_radiansToDisplace = c / 180 * Math.PI, this.m_angularSpeed = this.m_radiansToDisplace / (c / 360 * Math.PI * this.m_radio * 2 / this.m_speed), this.m_initRandians = b / 180 * Math.PI, this.m_currentRadiansDisplaced = 0, this.m_centroidX = this.m_x -
        this.m_radio * Math.cos(this.m_initRandians), this.m_centroidY = this.m_y + this.m_radio * Math.sin(this.m_initRandians), a = this.m_initRandians + this.m_radiansToDisplace * this.m_factorDirection, this.m_targetX = this.m_centroidX + this.m_radio * Math.cos(a), this.m_targetY = this.m_centroidY - this.m_radio * Math.sin(a), this.m_state = Movement.ST_MOVEMENT
};
CircularMovement.prototype.update = function(a) {
    if (this.m_state == Movement.ST_MOVEMENT && (this.m_currentRadiansDisplaced += this.m_angularSpeed * a, this.m_currentRadiansDisplaced > this.m_radiansToDisplace && (this.m_currentRadiansDisplaced = this.m_radiansToDisplace), a = this.m_initRandians + this.m_currentRadiansDisplaced * this.m_factorDirection, this.m_x = this.m_centroidX + this.m_radio * Math.cos(a), this.m_y = this.m_centroidY - this.m_radio * Math.sin(a), this.m_currentRadiansDisplaced == this.m_radiansToDisplace))
        if (this.m_isLoop) this.m_currentRadiansDisplaced =
            0, this.m_isReversible && (this.m_factorDirection *= -1, this.m_initRandians = a), this.onCycleEnd();
        else this.onEndMovement()
};

function MotionController(a, b, c) {
    this.m_currentMovement = null;
    this.m_currentIndexMovement = 0;
    this.m_advanceFactor = 1;
    this.m_x = a;
    this.m_y = b;
    this.m_speed = c.speed;
    this.m_motionData = c;
    this.m_isLoop = this.m_motionData.isLoop;
    this.m_isReversible = this.m_motionData.isReverse;
    this.m_isStarted = !1;
    this.m_movements = []
}
MotionController.prototype.free = function() {
    this.m_motionData.free();
    this.m_currentMovement = this.m_motionData = null;
    for (var a = this.m_movements.length - 1; 0 <= a;) this.m_movements[a].free(), this.m_movements[a] = null, --a;
    this.m_movements = null
};
MotionController.prototype.isStarted = function() {
    return this.m_isStarted
};
MotionController.prototype.startMotion = function() {
    this.m_isStarted || (this.m_isStarted = !0, this.createMovements(), this.m_currentIndexMovement = -1, this.gotoNextMovement())
};
MotionController.CIRCLE_POLAR = "cp";
MotionController.CIRCLE_CARTESIAN = "cc";
MotionController.LINEAR_POLAR = "lp";
MotionController.LINEAR_CARTESIAN = "lc";
MotionController.RELATIVE_LINEAR_CARTESIAN = "rlc";
MotionController.prototype.getX = function() {
    return this.m_x
};
MotionController.prototype.getY = function() {
    return this.m_y
};
MotionController.prototype.createMovements = function() {
    for (var a = null, a = a = null, b = this.m_x, c = this.m_y, d = null, e = 0; e < this.m_motionData.motionParams.length;) d = this.m_motionData.motionParams[e], d[0] == MotionController.CIRCLE_POLAR ? (a = new CircularMovement(b, c, this.m_speed, this.m_isLoop, this.m_isReversible), a.startMovement2(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3]))) : d[0] == MotionController.CIRCLE_CARTESIAN ? (a = new CircularMovement(b, c, this.m_speed, this.m_isLoop, this.m_isReversible), a.startMovement(parseFloat(d[1]),
        parseFloat(d[2]), parseFloat(d[3]))) : d[0] == MotionController.LINEAR_POLAR ? (a = new LinearMovement(b, c, this.m_speed, this.m_isLoop, this.m_isReversible), a.gotoRadialPoint(parseFloat(d[1]), parseFloat(d[2]))) : d[0] == MotionController.LINEAR_CARTESIAN ? (a = new LinearMovement(b, c, this.m_speed, this.m_isLoop, this.m_isReversible), a.gotoPosition(parseFloat(d[1]), parseFloat(d[2]))) : d[0] == MotionController.RELATIVE_LINEAR_CARTESIAN && (a = new LinearMovement(b, c, this.m_speed, this.m_isLoop, this.m_isReversible), a.gotoPosition(parseFloat(d[1]) +
        b, parseFloat(d[2]) + c)), a && (this.m_movements.push(a), a.setPause(!0), a.setCallbacks(this, this.onEndMovement, this.onCycleMovement), b = a.targetX(), c = a.targetY()), ++e
};
MotionController.prototype.gotoNextMovement = function() {
    this.m_currentIndexMovement += this.m_advanceFactor;
    0 <= this.m_currentIndexMovement && this.m_currentIndexMovement < this.m_movements.length ? (this.m_currentMovement = this.m_movements[this.m_currentIndexMovement], this.m_currentMovement.setPause(!1)) : this.m_isLoop && (this.m_isReversible ? this.m_advanceFactor *= -1 : this.m_currentIndexMovement = -1, this.gotoNextMovement())
};
MotionController.prototype.update = function(a) {
    this.m_currentMovement && (this.m_currentMovement.update(a), this.m_x = this.m_currentMovement.getX(), this.m_y = this.m_currentMovement.getY())
};
MotionController.prototype.onEndMovement = function(a) {};
MotionController.prototype.onCycleMovement = function(a) {
    this.m_currentMovement != a ? Application.error("MotionController::onCycleMovement()") : (a.setPause(!0), this.gotoNextMovement())
};

function PendularMovement(a, b, c, d, e, f, g) {
    this.m_alpha = this.m_angle = 0;
    this.m_x = c;
    this.m_y = d;
    this.m_dy = this.m_dx = this.m_len = 0;
    this.m_gravity = f;
    this.m_time = this.m_w = 0;
    this.m_pivotX = a;
    this.m_pivotY = b;
    this.m_longitudeMax = g;
    this.m_beta = e;
    this.m_velocity = 0;
    this.init()
}
PendularMovement.prototype.getX = function() {
    return this.m_x
};
PendularMovement.prototype.getY = function() {
    return this.m_y
};
PendularMovement.prototype.getAngle = function() {
    return this.m_angle
};
PendularMovement.prototype.getVelocity = function() {
    return this.m_velocity
};
PendularMovement.prototype.getMaxLongitude = function() {
    return this.m_longitudeMax
};
PendularMovement.prototype.init = function() {
    this.m_dx = this.m_x - this.m_pivotX;
    this.m_dy = this.m_y - this.m_pivotY;
    this.m_len = Math.sqrt(this.m_dx * this.m_dx + this.m_dy * this.m_dy);
    this.m_len < PendularMovement.LONGITUDE_MIN && (this.m_len = PendularMovement.LONGITUDE_MIN);
    this.m_angle = Math.atan2(this.m_dx, this.m_dy);
    this.m_alpha = this.m_beta;
    this.m_w = 2 * Math.PI / this.period();
    this.m_time = Math.acos(this.m_angle / this.m_alpha) / this.m_w * 180 / Math.PI
};
PendularMovement.prototype.update = function(a) {
    this.m_len += PendularMovement.INCREMENT_LONGITUDE;
    this.m_len > this.m_longitudeMax && (this.m_len = this.m_longitudeMax);
    this.m_w = 2 * Math.PI / this.period();
    this.m_angle = this.m_alpha * Math.cos(this.m_w * this.m_time * Math.PI / 180);
    this.m_velocity = -this.m_w * this.m_alpha * Math.sin(this.m_w * this.m_time * Math.PI / 180);
    this.m_x = this.m_len * Math.sin(this.m_angle) + this.m_pivotX;
    this.m_y = this.m_len * Math.cos(this.m_angle) + this.m_pivotY;
    this.m_time += PendularMovement.DT
};
PendularMovement.prototype.fastPow = function(a, b) {
    if (0 == b) return 1;
    if (0 == b % 2) {
        var c = this.fastPow(a, .5 * b);
        return c * c
    }
    return a * this.fastPow(a, b - 1)
};
PendularMovement.prototype.factorial = function(a) {
    for (var b = 1, c = 1; c <= a;) b *= c, c++;
    return b
};
PendularMovement.prototype.period = function() {
    for (var a = 0, b = 0; b <= PendularMovement.N;) a += this.fastPow(this.factorial(2 * b) / this.fastPow(this.fastPow(2, b) * this.factorial(b), 2), 2) * this.fastPow(Math.sin(this.m_alpha / 2), 2 * b), b++;
    return 2 * Math.PI * Math.sqrt(this.m_len / this.m_gravity) * a
};
PendularMovement.DT = 4;
PendularMovement.N = 30;
PendularMovement.LONGITUDE_MIN = 50;
PendularMovement.INCREMENT_LONGITUDE = .9;

function ParametricParabolicMovement(a, b, c, d, e, f) {
    e = "undefined" === typeof e ? ParametricParabolicMovement.STD_GRAVITY : e;
    f = "undefined" === typeof f ? ParametricParabolicMovement.STD_SPEED : f;
    this.toFront = c > a;
    this.m_initX = a;
    this.m_initY = b;
    this.m_finalX = c;
    this.m_finalY = d;
    this.m_gravity = e;
    this.m_currentTime = 0;
    this.m_finish = !1;
    this.m_endCallback = null;
    this.m_finalTime = ParametricParabolicMovement.STD_FINAL_TIME;
    this.m_dx = this.m_finalX - this.m_initX;
    this.m_dy = this.m_finalY - this.m_initY;
    this.m_speed = f;
    this.m_vx = this.m_dx /
        this.m_finalTime;
    this.m_vy = (this.m_dy - this.m_gravity * this.m_finalTime * this.m_finalTime / 2) / this.m_finalTime;
    this.m_rx = this.m_initX;
    this.m_ry = this.m_initY;
    this.caller = null
}
ParametricParabolicMovement.STD_GRAVITY = .05;
ParametricParabolicMovement.STD_SPEED = .18;
ParametricParabolicMovement.STD_FINAL_TIME = 100;
ParametricParabolicMovement.prototype.free = function() {
    this.caller = this.m_endCallback = null
};
ParametricParabolicMovement.prototype.getX = function() {
    return this.m_rx
};
ParametricParabolicMovement.prototype.getY = function() {
    return this.m_ry
};
ParametricParabolicMovement.prototype.onComplete = function(a, b) {
    this.caller = a;
    this.m_endCallback = b
};
ParametricParabolicMovement.prototype.update = function(a) {
    this.m_finish || (this.m_rx = Math.floor(this.m_initX + this.m_currentTime * this.m_vx), this.m_ry = Math.floor(this.m_initY + this.m_currentTime * this.m_vy + this.m_gravity * this.m_currentTime * this.m_currentTime / 2));
    this.m_currentTime >= this.m_finalTime ? (this.m_currentTime = this.m_finalTime, this.m_finish = !0, this.m_rx = this.m_finalX, this.m_ry = this.m_finalY, this.m_endCallback && this.m_endCallback.call(this.caller, this)) : this.m_currentTime += this.m_speed * a * 2
};

function GeometricUtils() {}
GeometricUtils.intersectLines = function(a, b, c, d) {
    var e = b.minus(a),
        f = b.minus(c),
        g = b.minus(d),
        f = e.product(f),
        e = e.product(g);
    if (0 == f || 0 == e || 0 < f * e) return null;
    g = Math.abs(GeometricUtils.triarea(a, b, c));
    f = Math.abs(GeometricUtils.triarea(a, b, d));
    e = (c.x * f + d.x * g) / (g + f);
    c = (c.y * f + d.y * g) / (g + f);
    return 0 > (a.x - e) * (e - b.x) || 0 > (a.y - c) * (c - b.y) ? null : new Vector2D(e, c)
};
GeometricUtils.intersectLinePolygon = function(a, b, c) {
    for (var d = [], e = 0; e < c.length; e++) {
        var f = GeometricUtils.intersectLines(a, b, c[e], c[(e + 1) % c.length]);
        f && d.push(f)
    }
    return d
};
GeometricUtils.intersectLinePolygon2 = function(a, b, c) {
    for (var d = [], e = [], f = 0; f < c.length; f++) {
        var g = GeometricUtils.intersectLines(a, b, c[f], c[(f + 1) % c.length]);
        g && (d.push(g), e.push(f))
    }
    return {
        points: d,
        index: e
    }
};
GeometricUtils.trap = function(a, b) {
    return .5 * (b.x - a.x) * (b.y + a.y)
};
GeometricUtils.triarea = function(a, b, c) {
    return GeometricUtils.trap(a, b) + GeometricUtils.trap(b, c) + GeometricUtils.trap(c, a)
};

function PathFinding() {
    this.m_listOpen = [];
    this.m_listClose = [];
    this.m_mapOpen = []
}
PathFinding.ALLOW_DIAGONAL = !0;
PathFinding.ALLOW_DIAGONAL_CORNERING = !1;
PathFinding.getPath = function(a, b, c, d, e, f) {
    return (new PathFinding).getPathPrivate(a, b, c, d, e, f)
};
PathFinding.prototype.getPathPrivate = function(a, b, c, d, e, f) {
    b = Math.floor(b);
    c = Math.floor(c);
    var g = this.getSelectOpen(b, c);
    this.addOpenList(g);
    for (var h = a[0].length, k = a.length, m, l, p, q, n, s, r, t; 0 < this.m_listOpen.length && !this.isInCloseListById(d, e);) {
        p = g.i - 1;
        n = g.i + 2;
        s = g.j - 1;
        for (r = g.j + 2; p < n; p++)
            for (q = s; q < r; q++) p < k && -1 < p && q < h && -1 < q && !this.isInCloseListById(p, q) && (PathFinding.ALLOW_DIAGONAL || p === g.i || q === g.j) && (PathFinding.ALLOW_DIAGONAL_CORNERING || p === g.i || q === g.j || a[p][g.j] == f && a[g.i][q] === f) && a[p][q] ===
                f && (l = this.isInOpenList(p, q), m = p == g.i || q == g.j ? 10 : 14, m = g.g + m, null === l ? (t = new clsNode(g, p, q), l = 10 * (Math.abs(p - d) + Math.abs(q - e)), t.g = m, t.h = l, t.f = m + l, this.addOpenList(t)) : m < l.g && (l.g = m, l.f = l.h + l.g, l.parent = g));
        this.removeOpenList(g);
        this.addCloseList(g);
        g = this.getSelectOpen(b, c)
    }
    a = null;
    if (this.isInCloseListById(d, e)) {
        a = [];
        d = null;
        for (d = this.m_listClose[this.m_listClose.length - 1]; null !== d;) a.push(d), d = d.parent;
        a = a.reverse()
    }
    return a
};
PathFinding.prototype.getSelectOpen = function(a, b) {
    var c = null,
        d = this.m_listOpen.length;
    if (0 < d)
        for (var c = this.m_listOpen[d - 1], e, f = 0; f < d; f++) e = this.m_listOpen[f], e.f < c.f && (c = e);
    else c = new clsNode(null, a, b);
    return c
};
PathFinding.prototype.isInCloseListById = function(a, b) {
    return "undefined" !== typeof this.m_mapOpen[a] && null !== this.m_mapOpen[a] && "undefined" !== typeof this.m_mapOpen[a][b] && null !== this.m_mapOpen[a][b] ? this.m_mapOpen[a][b].isClose : !1
};
PathFinding.prototype.isInCloseList = function(a) {
    return a.isClose
};
PathFinding.prototype.addCloseList = function(a) {
    a.isClose = !0;
    this.m_listClose.push(a)
};
PathFinding.prototype.isInOpenList = function(a, b) {
    return "undefined" !== typeof this.m_mapOpen[a] && null !== this.m_mapOpen[a] && "undefined" !== typeof this.m_mapOpen[a][b] && null !== this.m_mapOpen[a][b] ? this.m_mapOpen[a][b] : null
};
PathFinding.prototype.removeOpenList = function(a) {
    var b = this.m_listOpen.indexOf(a); - 1 < b && this.m_listOpen.splice(b, 1);
    a.isOpen = !1
};
PathFinding.prototype.addOpenList = function(a) {
    a.isOpen = !0;
    this.m_listOpen.push(a);
    this.m_mapOpen[a.i] || (this.m_mapOpen[a.i] = []);
    this.m_mapOpen[a.i][a.j] = a
};

function clsNode(a, b, c) {
    this.f = this.h = this.g = 0;
    this.i = b;
    this.j = c;
    this.isClose = this.isOpen = !1;
    this.parent = a
}

function JumpControl(a, b) {
    this.onMaxHeightReachedCallback = this.onCompleteJumpCallback = this.targetCallback = null;
    this.m_gravity = "undefined" !== typeof b ? b : 9.8;
    this.m_factorGravity = 1;
    this.m_vo = "undefined" !== typeof a ? a : -45;
    this.m_time = this.m_nextZ = this.m_z = 0;
    this.m_isPaused = this.m_isJump = !1;
    this.m_checkMaxHeight = !0;
    this.m_initVelocity = this.m_vo;
    this.m_initPosition = 0
}
JumpControl.prototype.setHeightInit = function(a) {
    this.m_initPosition = a;
    this.m_time = this.m_vo = 0;
    this.m_isJump = !0
};
JumpControl.prototype.cancel = function() {
    this.m_isJump = !1;
    this.m_z = this.m_vo = this.m_time = this.m_initPosition = 0
};
JumpControl.prototype.getCurrentHeight = function() {
    return this.m_z
};
JumpControl.prototype.getElapseTime = function() {
    return this.m_time
};
JumpControl.prototype.getGravity = function() {
    return this.m_gravity
};
JumpControl.prototype.setGravity = function(a) {
    this.m_gravity = a
};
JumpControl.prototype.getIsJump = function() {
    return this.m_isJump
};
JumpControl.prototype.getFactorGravity = function() {
    return this.m_factorGravity
};
JumpControl.prototype.setFactorGravity = function(a) {
    this.m_factorGravity = a
};
JumpControl.prototype.getPaused = function() {
    return this.m_isPaused
};
JumpControl.prototype.setPaused = function(a) {
    this.m_isPaused = a
};
JumpControl.prototype.init = function(a) {
    this.m_nextZ = this.m_z = "undefined" !== typeof a ? a : 0;
    this.m_time = 0;
    this.m_checkMaxHeight = this.m_isJump = !0
};
JumpControl.prototype.getInitVelocity = function() {
    return this.m_vo
};
JumpControl.prototype.setInitVelocity = function(a) {
    this.m_initVelocity = this.m_vo = a
};
JumpControl.prototype.applyForceY = function(a) {
    if (!this.m_isJump) return !1;
    this.m_initPosition = this.m_nextZ;
    this.m_vo = a;
    this.m_time = 0;
    return !0
};
JumpControl.prototype.applyImpulse = function(a) {
    this.m_initPosition = this.m_z;
    this.m_vo = a;
    this.m_time = 0;
    this.m_isJump = !0
};
JumpControl.prototype.completeJump = function() {
    this.m_vo = this.m_initVelocity;
    this.m_z = this.m_initPosition = 0;
    this.m_isJump = !1;
    if (this.targetCallback && this.onCompleteJumpCallback) this.targetCallback[this.onCompleteJumpCallback](this)
};
JumpControl.prototype.update = function(a) {
    if (!this.m_isPaused && this.m_isJump)
        if (this.m_time += .011 * a, this.m_nextZ = this.m_vo * this.m_time + this.m_gravity * this.m_factorGravity * this.m_time * this.m_time * .5 + this.m_initPosition, 0 >= this.m_nextZ) {
            if (this.m_checkMaxHeight && this.m_nextZ > this.m_z && (this.m_checkMaxHeight = !1, this.targetCallback && this.onMaxHeightReachedCallback)) this.targetCallback[this.onMaxHeightReachedCallback](this);
            this.m_z = this.m_nextZ
        } else this.completeJump()
};
JumpControl.prototype.free = function(a) {
    this.onMaxHeightReachedCallback = this.onCompleteJumpCallback = null
};

function Displace(a, b) {
    this.position = new Vector2D(a, b);
    this.positionTarget = new Vector2D(0, 0);
    this.angle = this.speedFactor = this.speedMagnitude = this.accelerationMagnitude = 0;
    this.targetCallback = this.onEndDisplaceCallback = null;
    this.m_timeElapse = 0;
    this.m_positionStart = this.position.clone();
    this.m_acceleration = new Vector2D(0, 0);
    this.m_speedInitial = new Vector2D(0, 0);
    this.m_totalDisplacement = 0;
    this.m_onMove = !1
}
Displace.prototype.currentSpeed = function() {
    var a = new Vector2D(0, 0);
    a.x = this.m_speedInitial.x * this.speedFactor + this.m_acceleration.x * this.m_timeElapse;
    a.y = this.m_speedInitial.y * this.speedFactor + this.m_acceleration.y * this.m_timeElapse;
    return a.length()
};
Displace.prototype.toLeft = function() {
    for (var a = this.angle, a = 180 / Math.PI * a; 0 > a;) a += 360;
    a %= 360;
    return 90 < a && 270 > a
};
Displace.prototype.getX = function() {
    return this.position.x
};
Displace.prototype.getY = function() {
    return this.position.y
};
Displace.prototype.resetPosition = function(a, b) {
    this.position.x = a;
    this.position.y = b
};
Displace.prototype.updateSpeed = function(a) {
    this.speedMagnitude = a;
    this.m_speedInitial.setVector(this.speedMagnitude, this.angle)
};
Displace.prototype.updateAcceleration = function(a) {
    this.m_timeElapse = 0;
    this.m_speedInitial.x = this.m_speedInitial.x * this.speedFactor + this.m_acceleration.x * this.m_timeElapse;
    this.m_speedInitial.y = this.m_speedInitial.y * this.speedFactor + this.m_acceleration.y * this.m_timeElapse;
    this.m_positionStart = this.position.clone();
    this.accelerationMagnitude = a;
    this.m_acceleration.setVector(this.accelerationMagnitude, this.angle)
};
Displace.prototype.cancel = function() {
    this.m_positionStart = this.position.clone();
    this.m_speedInitial.x = 0;
    this.m_speedInitial.y = 0;
    this.m_acceleration.x = 0;
    this.m_timeElapse = this.m_acceleration.y = 0;
    this.speedFactor = 1;
    this.m_onMove = !1;
    if (this.onEndDisplaceCallback && this.targetCallback) this.targetCallback[this.onEndDisplaceCallback]()
};
Displace.prototype.gotoPosition = function(a, b, c, d, e) {
    this.accelerationMagnitude = "undefined" === typeof d ? 0 : d;
    this.speedMagnitude = "undefined" === typeof c ? 0 : c;
    this.speedFactor = "undefined" === typeof e ? 1 : e;
    this.m_timeElapse = 0;
    this.m_positionStart = this.position.clone();
    this.positionTarget.x = a;
    this.positionTarget.y = b;
    this.angle = this.positionTarget.minus(this.m_positionStart).angle();
    this.m_speedInitial.setVector(this.speedMagnitude, this.angle);
    this.m_acceleration.setVector(this.accelerationMagnitude, this.angle);
    this.m_totalDisplacement = this.positionTarget.minus(this.m_positionStart).length();
    this.m_onMove = !0
};
Displace.prototype.gotoDirection = function(a, b, c, d, e) {
    this.accelerationMagnitude = "undefined" === typeof d ? 0 : d;
    this.speedMagnitude = "undefined" === typeof c ? 0 : c;
    this.speedFactor = "undefined" === typeof e ? 1 : e;
    this.angle = b;
    this.m_timeElapse = 0;
    this.m_positionStart = this.position.clone();
    this.m_speedInitial.setVector(this.speedMagnitude, this.angle);
    this.m_acceleration.setVector(this.accelerationMagnitude, this.angle);
    this.m_totalDisplacement = a;
    this.m_onMove = !0;
    this.positionTarget.x = this.m_positionStart.x + a * Math.cos(b);
    this.positionTarget.y = this.m_positionStart.y + a * Math.sin(b)
};
Displace.prototype.estimatePositionAfterTime = function(a) {
    a *= .001;
    var b = new Point(0, 0);
    b.x = this.position.x + this.m_speedInitial.x * a * this.speedFactor + .5 * this.m_acceleration.x * a * a;
    b.y = this.position.y + this.m_speedInitial.y * a * this.speedFactor + .5 * this.m_acceleration.y * a * a;
    return b
};
Displace.prototype.onBounce = function(a) {
    var b = 0;
    a == Displace.DIRECTION_LEFT && (b = 180);
    this.m_timeElapse = 0;
    this.m_positionStart = this.position.clone();
    this.angle = (b + Common.random(-Displace.BOUNCE_ANGLE_VAR, Displace.BOUNCE_ANGLE_VAR)) * (Math.PI / 180);
    this.m_speedInitial.setVector(this.speedMagnitude * Displace.ENERGY_AFTER_BOUNCE, this.angle);
    this.m_acceleration.setVector(this.accelerationMagnitude, this.angle)
};
Displace.prototype.update = function(a) {
    if (0 != this.m_onMove && (this.m_timeElapse += .001 * a, this.position.x = this.m_positionStart.x + this.m_speedInitial.x * this.m_timeElapse * this.speedFactor + .5 * this.m_acceleration.x * this.m_timeElapse * this.m_timeElapse, this.position.y = this.m_positionStart.y + this.m_speedInitial.y * this.m_timeElapse * this.speedFactor + .5 * this.m_acceleration.y * this.m_timeElapse * this.m_timeElapse, a = new Vector2D(0, 0), a.x = this.m_speedInitial.x * this.speedFactor + this.m_acceleration.x * this.m_timeElapse,
            a.y = this.m_speedInitial.y * this.speedFactor + this.m_acceleration.y * this.m_timeElapse, this.m_positionStart.minus(this.position).length() >= this.m_totalDisplacement || Math.abs(a.x) < Displace.NO_SPEED_VALUE && Math.abs(a.y) < Displace.NO_SPEED_VALUE)) {
        if (this.onEndDisplaceCallback && this.targetCallback) this.targetCallback[this.onEndDisplaceCallback]();
        this.m_onMove = !1
    }
};
Displace.prototype.free = function() {
    this.m_speedInitial = this.m_acceleration = this.m_positionOrigin = this.position = null
};
Displace.DIRECTION_RIGHT = 1;
Displace.DIRECTION_LEFT = -1;
Displace.BOUNCE_ANGLE_VAR = 15;
Displace.ENERGY_AFTER_BOUNCE = .6;
Displace.NO_SPEED_VALUE = 5;

function SlidingBackgrounds(a, b) {
    this.m_canvas = a;
    this.m_file = window.slidingbackground.slidingbackground;
    this.m_level = b;
    this.m_objects = [];
    this.m_objectsX = [];
    this.m_objectsY = [];
    this.m_objectsSpeed = [];
    this.m_objectsResetDistance = [];
    this.m_objectsVertical = [];
    this.m_objectsBackground = [];
    this.init()
}
SlidingBackgrounds.prototype.init = function() {
    for (var a = 0; a < this.m_file.length; a++) this.m_file[a].Level === this.m_level && (this.m_objects.push(Application.instance.getClip(this.m_file[a].ClipName)), this.m_objectsX.push(this.m_file[a].StartX), this.m_objectsY.push(this.m_file[a].StartY), this.m_objectsBackground.push(1 === this.m_file[a].Background), this.m_objectsVertical.push(1 === this.m_file[a].Vertical), this.m_objectsSpeed.push(this.m_objectsVertical[this.m_objects.length - 1] ? this.m_file[a].SpeedY : this.m_file[a].SpeedX),
        this.m_objectsResetDistance.push(this.m_objectsVertical[this.m_objects.length - 1] ? this.m_file[a].ResetDistanceY : this.m_file[a].ResetDistanceX), this.m_objects[this.m_objects.length - 1].setPosition(this.m_objectsX[this.m_objects.length - 1], this.m_objectsY[this.m_objects.length - 1]), this.m_canvas.addChild(this.m_objects[this.m_objects.length - 1]))
};
SlidingBackgrounds.prototype.update = function(a) {
    for (var b = 0; b < this.m_objects.length; b++) this.m_objectsVertical[b] ? (this.m_objectsY[b] += a * this.m_objectsSpeed[b], this.m_objectsY[b] += 0 >= this.m_objectsY[b] + (this.m_objectsBackground[b] ? 1 : .5) * Application.APP_HEIGHT ? (Application.APP_HEIGHT - 2) * this.m_objectsResetDistance[b] : 0) : (this.m_objectsX[b] += a * this.m_objectsSpeed[b], this.m_objectsX[b] += 0 >= this.m_objectsX[b] + (this.m_objectsBackground[b] ? 1 : .5) * Application.APP_WIDTH ? (Application.APP_WIDTH - 2) * this.m_objectsResetDistance[b] :
        0), this.m_objects[b].setPosition(this.m_objectsX[b], this.m_objectsY[b])
};
SlidingBackgrounds.prototype.free = function() {
    for (var a = 0; a < this.m_objects.length; a++) this.m_objects[a].free(), this.m_objects[a] = null;
    this.m_file = this.m_canvas = this.m_objectsBackground = this.m_objectsVertical = this.m_objectsResetDistance = this.m_objectsSpeed = this.m_objectsY = this.m_objectsX = this.m_objects = null
};

function ValueInterpolation(a, b, c, d) {
    this.isAwaitingDelete = this.stop = !1;
    this.dataInterpolation = null;
    this.isDisposed = this.isCreatedByPool = !1;
    this.m_timeEnd = this.m_timeInit = this.m_currentTime = 0;
    this.m_startCalculation = !1;
    this.m_finalValue = this.m_initValue = this.m_currentValue = this.m_duration = 0;
    this.m_callback = this.m_caller = null
}
ValueInterpolation.prototype.reset = function(a, b, c, d, e, f, g) {
    d = "undefined" !== typeof d ? d : 0;
    c = "undefined" !== typeof c ? c : this.m_duration;
    this.m_initValue = a;
    this.m_finalValue = b;
    this.m_duration = c;
    this.m_timeInit = d;
    this.m_timeEnd = d + c;
    this.dataInterpolation = null;
    this.isAwaitingDelete = this.stop = !1;
    this.m_currentTime = 0;
    this.m_startCalculation = 0 > d ? !1 : !0;
    this.m_callback = this.m_caller = null;
    return this
};
ValueInterpolation.prototype.onEndInterpolation = function(a, b) {
    this.m_caller = a;
    this.m_callback = b
};
ValueInterpolation.prototype.timeInit = function() {
    return this.m_timeInit
};
ValueInterpolation.prototype.timeEnd = function() {
    return this.m_timeEnd
};
ValueInterpolation.prototype.value = function() {
    return this.m_currentValue
};
ValueInterpolation.prototype.calculateValue = function(a) {
    return 0
};
ValueInterpolation.prototype.update = function(a) {
    this.stop || (this.m_startCalculation ? (this.m_currentTime += a, this.m_currentValue = this.calculateValue(this.m_currentTime), this.m_currentTime >= this.m_duration && (this.m_currentValue = this.m_finalValue, this.stop = !0, null !== this.m_caller && null !== this.m_callback && this.m_callback.call(this.m_caller, this))) : (this.m_currentTime += a, this.m_currentTime >= this.m_timeInit && (this.m_startCalculation = !0, this.m_currentTime = 0)))
};
ValueInterpolation.prototype.free = function() {
    this.dataInterpolation = this.m_caller = this.m_callback = null
};

function LinearInterpolation(a, b, c, d) {
    ValueInterpolation.call(this, a, b, c, d);
    this.m_rateOfChange = 0;
    this.reset(a, b, c, d)
}
Application.subclass(LinearInterpolation, ValueInterpolation);
LinearInterpolation.freeObject = [];
LinearInterpolation.lastCreated = null;
LinearInterpolation.create = function(a, b, c, d) {
    0 < LinearInterpolation.freeObject.length ? (LinearInterpolation.lastCreated = LinearInterpolation.freeObject.pop(), LinearInterpolation.lastCreated.reset(a, b, c, d, 0, 0, 0)) : LinearInterpolation.lastCreated = new LinearInterpolation(a, b, c, d);
    LinearInterpolation.lastCreated.isCreatedByPool = !0;
    LinearInterpolation.lastCreated.isDisposed = !1;
    return LinearInterpolation.lastCreated
};
LinearInterpolation.disposeObject = function(a) {
    a.isCreatedByPool && !a.isDisposed && (LinearInterpolation.freeObject.push(a), a.isDisposed = !0)
};
LinearInterpolation.clear = function() {
    LinearInterpolation.freeObject = []
};
LinearInterpolation.prototype.reset = function(a, b, c, d, e, f, g) {
    ValueInterpolation.prototype.reset.call(this, a, b, c, d, e, f, g);
    this.m_rateOfChange = (b - a) / c;
    return this
};
LinearInterpolation.prototype.calculateValue = function(a) {
    return this.m_initValue + a * this.m_rateOfChange
};
LinearInterpolation.prototype.free = function() {
    ValueInterpolation.prototype.free.call(this);
    LinearInterpolation.disposeObject(this)
};

function ExponentialInterpolation(a, b, c, d, e) {
    ValueInterpolation.call(this, a, b, c, e);
    this.m_c2 = this.m_c1 = this.m_alpha = 0;
    this.reset(a, b, c, e, d)
}
Application.subclass(ExponentialInterpolation, ValueInterpolation);
ExponentialInterpolation.freeObject = [];
ExponentialInterpolation.lastCreated = null;
ExponentialInterpolation.create = function(a, b, c, d, e) {
    0 < ExponentialInterpolation.freeObject.length ? (ExponentialInterpolation.lastCreated = ExponentialInterpolation.freeObject.pop(), ExponentialInterpolation.lastCreated.reset(a, b, c, e, d, 0, 0)) : ExponentialInterpolation.lastCreated = new ExponentialInterpolation(a, b, c, d, e);
    ExponentialInterpolation.lastCreated.isCreatedByPool = !0;
    ExponentialInterpolation.lastCreated.isDisposed = !1;
    return ExponentialInterpolation.lastCreated
};
ExponentialInterpolation.disposeObject = function(a) {
    a.isCreatedByPool && !a.isDisposed && (a.isDisposed = !0, ExponentialInterpolation.freeObject.push(a))
};
ExponentialInterpolation.clear = function() {
    ExponentialInterpolation.freeObject = []
};
ExponentialInterpolation.prototype.reset = function(a, b, c, d, e, f, g) {
    ValueInterpolation.prototype.reset.call(this, a, b, c, d, e, f, g);
    this.m_alpha = 1E3 * e / c;
    this.m_c1 = (b - a) / (Math.exp(this.m_alpha * this.m_duration * .001) - 1);
    this.m_c2 = this.m_initValue - this.m_c1;
    return this
};
ExponentialInterpolation.prototype.calculateValue = function(a) {
    return this.m_c1 * Math.exp(this.m_alpha * a * .001) + this.m_c2
};
ExponentialInterpolation.prototype.free = function() {
    ValueInterpolation.prototype.free.call(this);
    ExponentialInterpolation.disposeObject(this)
};

function ElasticInterpolation(a, b, c, d, e, f) {
    ValueInterpolation.call(this, a, b, c, f);
    this.m_waves = this.m_overshoot = this.m_zetaConst = this.m_c4 = this.m_c3 = this.m_c2 = this.m_c1 = 0;
    this.reset(a, b, c, f, 0, d, e)
}
Application.subclass(ElasticInterpolation, ValueInterpolation);
ElasticInterpolation.MAX_OVERSHOOT = .8;
ElasticInterpolation.INVERSE_PI = .3183098862;
ElasticInterpolation.freeObject = [];
ElasticInterpolation.lastCreated = null;
ElasticInterpolation.create = function(a, b, c, d, e, f) {
    0 < ElasticInterpolation.freeObject.length ? (ElasticInterpolation.lastCreated = ElasticInterpolation.freeObject.pop(), ElasticInterpolation.lastCreated.reset(a, b, c, f, 0, d, e)) : ElasticInterpolation.lastCreated = new ElasticInterpolation(a, b, c, d, e, f);
    ElasticInterpolation.lastCreated.isCreatedByPool = !0;
    ElasticInterpolation.lastCreated.isDisposed = !1;
    return ElasticInterpolation.lastCreated
};
ElasticInterpolation.disposeObject = function(a) {
    a.isCreatedByPool && !a.isDisposed && (a.isDisposed = !0, ElasticInterpolation.freeObject.push(a))
};
ElasticInterpolation.clear = function() {
    ElasticInterpolation.freeObject = []
};
ElasticInterpolation.prototype.reset = function(a, b, c, d, e, f, g) {
    ValueInterpolation.prototype.reset.call(this, a, b, c, d, e, f, g);
    f = "undefined" !== typeof f ? f : 0;
    g = "undefined" !== typeof g ? g : 0;
    f > ElasticInterpolation.MAX_OVERSHOOT && (f = ElasticInterpolation.MAX_OVERSHOOT);
    this.m_overshoot = f;
    d = Math.log(f) * ElasticInterpolation.INVERSE_PI;
    this.m_zetaConst = Math.sqrt(1 - 1 / (d * d + 1));
    this.m_waves = g;
    d = -Math.atan(Math.sqrt(1 - this.m_zetaConst * this.m_zetaConst) / this.m_zetaConst);
    c = 2 * Math.PI / (c / (g + d * ElasticInterpolation.INVERSE_PI *
        .5 + (0 > d ? 1 : 0)));
    g = c / Math.sqrt(1 - this.m_zetaConst * this.m_zetaConst);
    this.m_c1 = b - a;
    this.m_c2 = -this.m_zetaConst * g;
    this.m_c3 = c;
    this.m_c4 = -this.m_c2 / c;
    return this
};
ElasticInterpolation.prototype.calculateValue = function(a) {
    return this.m_c1 * (1 - Math.exp(this.m_c2 * a) * (SMath.fastCos(this.m_c3 * a) + this.m_c4 * SMath.fastSin(this.m_c3 * a))) + this.m_initValue
};
ElasticInterpolation.prototype.free = function() {
    ValueInterpolation.prototype.free.call(this);
    ElasticInterpolation.disposeObject(this)
};

function SATCollisionDetector() {}
SATCollisionDetector.calculatePolyPolyIntersection = function(a, b) {
    for (var c = [], d = [], e = [], f = e = 0; f < a.length; f++)
        if (e = 0 === f ? -(a[0][0] - a[a.length - 1][0]) / (a[0][1] - a[a.length - 1][1]) : -(a[f][0] - a[f - 1][0]) / (a[f][1] - a[f - 1][1]), -1 === c.indexOf(e) && (c.push(e), d = SATCollisionDetector.projectPolygonOntoLine(a, e), e = SATCollisionDetector.projectPolygonOntoLine(b, e), d[0] > e[1] || d[1] < e[0])) return !1;
    for (f = 0; f < b.length; f++)
        if (e = 0 === f ? -(b[0][0] - b[b.length - 1][0]) / (b[0][1] - b[b.length - 1][1]) : -(b[f][0] - b[f - 1][0]) / (b[f][1] - b[f -
                1][1]), -1 === c.indexOf(e) && (c.push(e), d = SATCollisionDetector.projectPolygonOntoLine(a, e), e = SATCollisionDetector.projectPolygonOntoLine(b, e), d[0] > e[1] || d[1] < e[0])) return !1;
    return !0
};
SATCollisionDetector.calculatePolyCircleIntersection = function(a, b) {};
SATCollisionDetector.projectPolygonOntoLine = function(a, b) {
    for (var c = [], d = 0, e = 0, f = 0; f < a.length; f++) Infinity === b || Infinity === b ? d = a[f][1] : 0 === b ? d = a[f][0] : (d = -1 / b, e = a[f][1] - d * a[f][0], d = e / (b - d)), 0 === c.length ? c.push(d) : 1 === c.length ? d >= c[0] ? c.push(d) : c.unshift(d) : d > c[1] ? c[1] = d : d < c[0] && (c[0] = d);
    return c
};

function PhysicsContacListener(a) {
    this.listener = a;
    this.listener.BeginContact = function(a) {
        var c = a.GetFixtureA().GetBody().GetUserData(),
            d = a.GetFixtureB().GetBody().GetUserData();
        null !== c && c.BeginContact(a.GetFixtureB().GetBody(), a);
        null !== d && d.BeginContact(a.GetFixtureA().GetBody(), a)
    };
    this.listener.EndContact = function(a) {
        var c = a.GetFixtureA().GetBody().GetUserData(),
            d = a.GetFixtureB().GetBody().GetUserData();
        null !== c && c.EndContact(a.GetFixtureB().GetBody(), a);
        null !== d && d.EndContact(a.GetFixtureA().GetBody(),
            a)
    };
    this.listener.PostSolve = function(a, c) {
        var d = a.GetFixtureA().GetBody().GetUserData(),
            e = a.GetFixtureB().GetBody().GetUserData();
        null !== d && d.PostSolve(a.GetFixtureB().GetBody(), a, c);
        null !== e && e.PostSolve(a.GetFixtureA().GetBody(), a, c)
    };
    this.listener.PreSolve = function(a, c) {
        var d = a.GetFixtureA().GetBody().GetUserData(),
            e = a.GetFixtureB().GetBody().GetUserData();
        null !== d && d.PreSolve(a.GetFixtureB().GetBody(), a, c);
        null !== e && e.PreSolve(a.GetFixtureA().GetBody(), a, c)
    }
}

function CircleMask(a) {
    PIXI.Graphics.call(this);
    this.yRadius = this.xRadius = a;
    this.ratio = 0;
    this.redraw()
}
Application.subclass(CircleMask, PIXI.Graphics);
CircleMask.prototype.setRatio = function(a, b) {
    this.ratio = b ? 1 - a : a;
    1 < this.ratio ? this.ratio = 1 : 0 > this.ratio && (this.ratio = 0);
    this.redraw()
};
CircleMask.prototype.redraw = function() {
    this.clear();
    this.beginFill(16711680, 1);
    var a = 2 * Math.PI / 8,
        b = Math.ceil(8 * this.ratio);
    this.moveTo(0, 0);
    for (var c = 0; c < b; c++) {
        var d = c * a;
        this.lineTo(SMath.fastSin(d) * -this.xRadius, SMath.fastCos(d) * -this.yRadius)
    }
    d = this.ratio * Math.PI * 2;
    this.lineTo(SMath.fastSin(d) * -this.xRadius, SMath.fastCos(d) * -this.yRadius);
    this.endFill()
};

function SLoader(a) {
    this.onLoadCallback = this.onLoadCaller = null;
    this.jsonLoader = a;
    if (a = this.jsonLoader.json.animations)
        for (var b = 0; b < a.length; b++) a[b].atlas = this.jsonLoader.json.meta.atlas, "undefined" !== typeof window.globalAnimations[a[b].n] && Application.warn("Clip [" + a[b].n + "] is duplicated in multiple JSON files : " + this.jsonLoader.url + " || " + window.globalAnimations[a[b].n + "_url"]), window.globalAnimations[a[b].n] = a[b], window.globalAnimations[a[b].n + "_url"] = this.jsonLoader.url
}
SLoader.prototype.addLoadListener = function(a, b) {
    this.onLoadCaller = a;
    this.onLoadCallback = b
};
SLoader.prototype.load = function() {
    var a = 0,
        b = this.jsonLoader.json.meta,
        c = [];
    SLoader.JsonTextures[this.jsonLoader.url] = [];
    for (a = 0; a < b.atlas.length; a++) {
        var d = this.jsonLoader.baseUrl + b.atlas[a];
        c[a] = new PIXI.loaders.Loader;
        c[a].add(b.atlas[a], d);
        c[a].parent = this;
        c[a].metaImage = b.atlas[a];
        c[a].metaIndex = a;
        c[a].once("complete", function() {
            if (this.parent) this.parent.onLoaded(this)
        });
        c[a].load()
    }
};
SLoader.prototype.onLoaded = function(a) {
    this.onLoadCaller && this.onLoadCallback && this.onLoadCallback.call(this.onLoadCaller);
    if ("undefined" !== typeof this.jsonLoader.json.atlas) {
        for (var b = a.metaIndex, c = a.resources[a.metaImage].texture.baseTexture, d = this.jsonLoader.json.atlas[b], e = 0; e < d.length; e++) {
            var f = d[e];
            "" === d[e].n && (d[e].n = this.jsonLoader.json.meta.atlas[b] + "_" + e);
            window.PIXI.utils.TextureCache[d[e].n] = new window.PIXI.Texture(c, {
                x: f.x,
                y: f.y,
                width: f.w,
                height: f.h,
                p: f.p,
                q: f.q,
                ax: f.p / f.w,
                ay: f.q / f.h
            }, {
                x: f.x,
                y: f.y,
                width: f.w,
                height: f.h
            }, null, null)
        }
        SLoader.JsonTextures[a.parent.jsonLoader.url].push(c)
    }
};
SLoader.JsonTextures = {};
SLoader.checkTexturesLoaded = function(a) {
    if (!a) return !1;
    for (var b = 0; b < a.length; b++)
        if ("undefined" === typeof SLoader.JsonTextures[a[b]]) return !1;
    return !0
};
SLoader.showAllTextures = function() {
    for (var a in SLoader.JsonTextures) Application.info("SLoader >> Textures :: id [" + a + "]")
};
SLoader.unloadFromList = function(a) {
    for (var b = 0; b < a.length; b++) SLoader.unloadTextureFromJson(a[b])
};
SLoader.unloadTextureFromJson = function(a) {
    if (SLoader.JsonTextures[a]) {
        Application.warn("SLoader >> unloadTexture from Json[" + a + "]");
        for (var b = 0; b < SLoader.JsonTextures[a].length; b++) {
            Application.warn("SLoader > unload " + SLoader.JsonTextures[a][b].imageUrl);
            for (var c in window.PIXI.utils.TextureCache) window.PIXI.utils.TextureCache[c] && window.PIXI.utils.TextureCache[c].baseTexture === SLoader.JsonTextures[a][b] && (window.PIXI.utils.TextureCache[c] = null);
            for (var d in window.globalAnimations) window.globalAnimations[d +
                "_url"] === a && (window.globalAnimations[d] = null, delete window.globalAnimations[d], delete window.globalAnimations[d + "_url"]);
            navigator.isCocoonJS && SLoader.JsonTextures[a][b].source.dispose();
            SLoader.JsonTextures[a][b].destroy()
        }
        SLoader.JsonTextures[a] = null;
        delete SLoader.JsonTextures[a]
    } else Application.info("SLoader >> unloadTexture, texture [" + a + "] no found")
};

function SDisplayObjectContainer() {
    this.collisionsClips = [];
    this.anchor = this.pivot = this.scale = this.position = null;
    this.rotation = 0;
    this.alpha = 1;
    this.visible = !0;
    this.children = null;
    PIXI.Container.call(this);
    this.m_pointerMoveCallback = this.m_pointerMoveCaller = this.m_pointerOverCallback = this.m_pointerOverCaller = this.m_pressAndReleaseCallback = this.m_pressAndReleaseCaller = this.m_releaseCallback = this.m_releaseCaller = this.m_pressCallback = this.m_pressCaller = null;
    this.collisions = []
}
Application.subclass(SDisplayObjectContainer, PIXI.Container);
SDisplayObjectContainer.prototype.free = function() {
    for (; 0 < this.collisionsClips.length;) this.removeChild(this.collisionsClips[0]), this.collisionsClips[0].free(), this.collisionsClips[0] = null, this.collisionsClips.splice(0, 1);
    this.collisionsClips = null;
    PIXI.Container.prototype.destroy.call(this, !0);
    this._pressAndReleaseCallback = this._pressAndReleaseCaller = this._releaseCallback = this._releaseCaller = this._pressCallback = this._pressCaller = this.pivot = this.scale = this.position = null
};
SDisplayObjectContainer.prototype.addChild = function(a) {
    return a ? (a.collisionView = this.collisionView, a.collisionView && a.showCollision && a.showCollision(), PIXI.Container.prototype.addChild.call(this, a)) : a
};
SDisplayObjectContainer.prototype.removeChild = function(a) {
    return PIXI.Container.prototype.removeChild.call(this, a)
};
SDisplayObjectContainer.prototype.toggleCollision = function() {
    PIXI.Container.prototype.toggleCollision.call(this);
    this.showCollision()
};
SDisplayObjectContainer.prototype.showCollision = function() {
    for (; 0 < this.collisionsClips.length;) this.removeChild(this.collisionsClips[0]), this.collisionsClips[0].free(), this.collisionsClips[0] = null, this.collisionsClips.splice(0, 1);
    if (this.collisionView)
        for (var a in this.collisions)
            if (this.collisions[a]) {
                var b = this.collisions[a],
                    c = new SGraphics;
                c.drawRectangle(b.x, b.y, b.w, b.h, 1, this.collisionColor, "mcCollision" === a ? this.collisionColor : 255, 1, .1);
                this.collisionsClips.push(c);
                this.addChild(c)
            }
};
SDisplayObjectContainer.prototype.setPosition = function(a, b) {
    this.position.x = a;
    this.position.y = b
};
SDisplayObjectContainer.prototype.setAnchor = function(a, b) {
    this.anchor.x = a;
    this.anchor.y = b
};
SDisplayObjectContainer.prototype.setScale = function(a, b) {
    this.scale.x = a;
    this.scale.y = "undefined" === typeof b ? a : b
};
SDisplayObjectContainer.prototype.getCollision = function(a) {
    return "undefined" === typeof this.collisions[a] ? null : this.collisions[a]
};
SDisplayObjectContainer.prototype.addCollision = function(a, b) {
    this.collisions[a] = b
};
SDisplayObjectContainer.prototype.addPressListener = function(a, b) {
    this.interactive = !0;
    this.self = this;
    this.mousedown = this.touchstart = function(a) {
        this.self._onPointerPress(a)
    };
    this.m_pressCaller = a;
    this.m_pressCallback = b
};
SDisplayObjectContainer.prototype.addReleaseListener = function(a, b) {
    this.interactive = !0;
    this.self = this;
    this.mouseup = this.mouseupoutside = function(a) {
        this.self._onPointerRelease(a)
    };
    this.touchend = this.touchendoutside = function(a) {
        this.self._onPointerRelease(a)
    };
    this.m_releaseCaller = a;
    this.m_releaseCallback = b
};
SDisplayObjectContainer.prototype.addPressAndReleaseListener = function(a, b) {
    this.interactive = !0;
    this.self = this;
    this.click = this.tap = function(a) {
        this.self._onPointerPressAndRelease(a)
    };
    this.m_pressAndReleaseCaller = a;
    this.m_pressAndReleaseCallback = b
};
SDisplayObjectContainer.prototype.addPointerOverListener = function(a, b) {
    this.interactive = !0;
    this.self = this;
    this.mouseover = function(a) {
        this.self._onPointerOver(a)
    };
    this.m_pointerOverCaller = a;
    this.m_pointerOverCallback = b
};
SDisplayObjectContainer.prototype.addPointerMoveListener = function(a, b) {
    this.interactive = !0;
    this.self = this;
    this.mousemove = this.touchmove = function(a) {
        this.self.onPointerMove(a)
    };
    this.m_pointerMoveCaller = a;
    this.m_pointerMoveCallback = b
};
SDisplayObjectContainer.prototype._onPointerPress = function(a) {
    null !== this.m_pressCaller && null !== this.m_pressCallback && this.m_pressCallback.call(this.m_pressCaller, a)
};
SDisplayObjectContainer.prototype._onPointerRelease = function(a) {
    null !== this.m_releaseCaller && null !== this.m_releaseCallback && this.m_releaseCallback.call(this.m_releaseCaller, a)
};
SDisplayObjectContainer.prototype._onPointerPressAndRelease = function(a) {
    null !== this.m_pressAndReleaseCaller && null !== this.m_pressAndReleaseCallback && this.m_pressAndReleaseCallback.call(this.m_pressAndReleaseCaller, a)
};
SDisplayObjectContainer.prototype._onPointerOver = function(a) {
    null !== this.m_pointerOverCaller && null !== this.m_pointerOverCallback && this.m_pointerOverCallback.call(this.m_pointerOverCaller, a)
};
SDisplayObjectContainer.prototype.onPointerMove = function(a) {
    null !== this.m_pointerMoveCaller && null !== this.m_pointerMoveCallback && this.m_pointerMoveCallback.call(this.m_pointerMoveCaller, a)
};
SDisplayObjectContainer.prototype.hitTest = function(a) {
    var b = this.getCollision("mcCollision"),
        c = a.getCollision("mcCollision");
    this.displayObjectUpdateTransform();
    a.displayObjectUpdateTransform();
    return b && c ? SATCollisionDetector.calculatePolyPolyIntersection(SDisplayObjectContainer.getCoordinatesMatrix(this.worldTransform, b.x, b.y, b.w, b.h), SDisplayObjectContainer.getCoordinatesMatrix(a.worldTransform, c.x, c.y, c.w, c.h)) : !1
};
SDisplayObjectContainer.hitTestByBounds = function(a, b, c, d) {
    return a && b && c && d ? (a.displayObjectUpdateTransform(), c.displayObjectUpdateTransform(), SATCollisionDetector.calculatePolyPolyIntersection(SDisplayObjectContainer.getCoordinatesMatrix(a.worldTransform, b.x, b.y, b.w, b.h), SDisplayObjectContainer.getCoordinatesMatrix(c.worldTransform, d.x, d.y, d.w, d.h))) : !1
};
SDisplayObjectContainer.getCoordinatesMatrix = function(a, b, c, d, e) {
    var f = [];
    f.push([b, c]);
    f.push([b + d, c]);
    f.push([b + d, c + e]);
    f.push([b, c + e]);
    for (d = 0; d < f.length; d++) b = f[d][0], c = f[d][1], f[d][0] = a.a * b + a.c * c + a.tx, f[d][1] = a.b * b + a.d * c + a.ty;
    return f
};

function SSprite(a) {
    var b = window.PIXI.Texture.fromImage(a);
    this.name = a;
    window.PIXI.Sprite.call(this, b)
}
Application.subclass(SSprite, PIXI.Sprite);
SSprite.prototype.free = function() {
    PIXI.Sprite.prototype.destroy.call(this, !1, !1)
};
SSprite.prototype.setPosition = function(a, b) {
    this.position.x = a;
    this.position.y = b
};
SSprite.prototype.setScale = function(a, b) {
    this.scale.x = a;
    this.scale.y = "undefined" === typeof b ? a : b
};

function SPixiText(a, b) {
    this.anchor = this.pivot = this.scale = this.position = null;
    this.rotation = 0;
    this.alpha = 1;
    this.visible = !0;
    this._style = {};
    this.context = null;
    this.resolution = 1;
    PIXI.Text.call(this, a, b);
    Application.RIGHT_TO_LEFT && (this.canvas.setAttribute("dir", "rtl"), this.canvas.style.top = "-1000px", this.canvas.style.left = "-1000px", this.canvas.style.opacity = 0, document.body.appendChild(this.canvas))
}
Application.subclass(SPixiText, PIXI.Text);
SPixiText.prototype.setText = function(a) {
    "object" === typeof a ? (this._text = a.string, this._style.size = 0 !== parseInt(a.size, 10) ? parseInt(a.size, 10) : this._style.size, this._style.fill = "" !== a.color ? a.color : this._style.fill, this._style.font = "" !== a.font ? this._style.size + "px " + a.font : this._style.font) : this._text = a.toString() || "";
    this.dirty = !0
};
SPixiText.prototype.setStyle = function(a) {
    this._style = this._style || {};
    this._style.font = "undefined" !== typeof a.font ? a.font : this._style.font || "bold 20pt Arial";
    this._style.fill = "undefined" !== typeof a.fill ? a.fill : this._style.fill || "black";
    this._style.align = a.align ? a.align : GuiText.ALIGN_LEFT;
    this._style.valign = "undefined" !== typeof a.valign ? a.valign : this._style.valign || GuiText.ALIGN_V_TOP;
    this._style.stroke = "undefined" !== typeof a.stroke ? a.stroke : this._style.stroke || "black";
    this._style.strokeThickness = "undefined" !==
        typeof a.strokeThickness ? a.strokeThickness : this._style.strokeThickness || 0;
    this._style.wordWrap = "undefined" !== typeof a.wordWrap ? a.wordWrap : this._style.wordWrap || !1;
    this._style.wordWrapWidth = "undefined" !== typeof a.wordWrapWidth ? a.wordWrapWidth : this._style.wordWrapWidth || 100;
    this._style.dropShadow = "undefined" !== typeof a.dropShadow ? a.dropShadow : this._style.dropShadow || !1;
    this._style.dropShadowAngle = "undefined" !== typeof a.dropShadowAngle ? a.dropShadowAngle : this._style.dropShadowAngle || Math.PI / 6;
    this._style.dropShadowDistance =
        "undefined" !== typeof a.dropShadowDistance ? a.dropShadowDistance : this._style.dropShadowDistance || 4;
    this._style.dropShadowColor = "undefined" !== typeof a.dropShadowColor ? a.dropShadowColor : this._style.dropShadowColor || "black";
    this._style.lineJoin = "undefined" !== typeof a.lineJoin ? a.lineJoin : this._style.lineJoin || "miter";
    this.dirty = !0
};
SPixiText.prototype.updateText = function() {
    this.texture.baseTexture.resolution = this.resolution;
    this.context.font = this._style.font;
    var a = this._text;
    this._style.wordWrap && (a = this.wordWrap(this._text));
    for (var a = a.split(/(?:\r\n|\r|\n)/), b = [], c = 0, d = this.determineFontProperties(this._style.font), e = 0; e < a.length; e++) {
        var f = this.context.measureText(a[e]).width;
        b[e] = f;
        c = Math.max(c, f)
    }
    e = c + this._style.strokeThickness;
    this._style.dropShadow && (e += this._style.dropShadowDistance);
    this.canvas.width = (e + this.context.lineWidth) *
        this.resolution;
    this._lineHeight = f = d.fontSize + this._style.strokeThickness + 5;
    e = f * a.length;
    this._style.dropShadow && (e += this._style.dropShadowDistance);
    this.canvas.height = e * this.resolution;
    this.context.scale(this.resolution, this.resolution);
    navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.context.font = this._style.font;
    this.context.strokeStyle = this._style.stroke;
    this.context.lineWidth = this._style.strokeThickness;
    this.context.textBaseline = "alphabetic";
    this.context.lineJoin =
        this._style.lineJoin;
    Application.RIGHT_TO_LEFT && (this.context.textAlign = "left");
    var g, h;
    this.context.fillStyle = this._style.fill;
    for (e = 0; e < a.length; e++) g = this._style.strokeThickness / 2, h = this._style.strokeThickness / 2 + e * f + d.ascent, Application.RIGHT_TO_LEFT ? this._style.align === GuiText.ALIGN_RIGHT ? g = c - b[e] : this._style.align === GuiText.ALIGN_CENTER ? g = c - b[e] >> 1 : this._style.align === GuiText.ALIGN_LEFT && (g = 0) : this._style.align === GuiText.ALIGN_RIGHT ? g = c - b[e] : this._style.align === GuiText.ALIGN_CENTER && (g = c - b[e] >>
        1), this._style.stroke && this._style.strokeThickness && this.context.strokeText(a[e], g, h), this._style.fill && this.context.fillText(a[e], g, h);
    this.updateTexture()
};
SPixiText.prototype.destroy = function(a) {
    Application.RIGHT_TO_LEFT && document.body.removeChild(this.canvas);
    this._style = this.canvas = this.context = null;
    this.texture.destroy(void 0 === a ? !0 : a)
};

function SText(a, b) {
    this.pivot = this.scale = this.position = null;
    this.rotation = 0;
    this.alpha = 1;
    this.visible = !0;
    this.worldTransform = null;
    PIXI.Container.call(this);
    this.style = null;
    this._lineHeight = this._maxLineWidth = this._height = this._width = 0;
    this._lineWidths = [];
    this.setText(a);
    this.setStyle(b);
    this.updateText()
}
Application.subclass(SText, PIXI.Container);
SText.prototype.setText = function(a) {
    "object" === typeof a ? (this._text = a.string, this.style.size = 0 !== parseInt(a.size, 10) ? parseInt(a.size, 10) : this.style.size, this.style.fill = "" !== a.color ? a.color : this.style.fill, this.style.font = "" !== a.font ? this.style.size + "px " + a.font : this.style.font) : this._text = a.toString() || ""
};
SText.prototype.setStyle = function(a) {
    this.style = this.style || {};
    this.style.size = "undefined" !== typeof a.size ? a.size : this.style.size || 10;
    this.style.font = "undefined" !== typeof a.font ? a.font : this.style.font || "bold 10pt Arial";
    this.style.fill = "undefined" !== typeof a.fill ? a.fill : this.style.fill || "black";
    this.style.align = a.align ? a.align : GuiText.ALIGN_LEFT;
    this.style.valign = "undefined" !== typeof a.valign ? a.valign : this.style.valign || GuiText.ALIGN_V_TOP;
    this.style.stroke = "undefined" !== typeof a.stroke ? a.stroke :
        this.style.stroke || "black";
    this.style.strokeThickness = "undefined" !== typeof a.strokeThickness ? a.strokeThickness : this.style.strokeThickness || 0;
    this.style.wordWrap = "undefined" !== typeof a.wordWrap ? a.wordWrap : this.style.wordWrap || !1;
    this.style.wordWrapWidth = "undefined" !== typeof a.wordWrapWidth ? a.wordWrapWidth : this.style.wordWrapWidth || 100;
    this.style.dropShadow = "undefined" !== typeof a.dropShadow ? a.dropShadow : this.style.dropShadow || !1;
    this.style.dropShadowDistance = "undefined" !== typeof a.dropShadowDistance ?
        a.dropShadowDistance : this.style.dropShadowDistance || 5;
    this.style.dropShadowAngle = "undefined" !== typeof a.dropShadowAngle ? a.dropShadowAngle : this.style.dropShadowAngle || -Math.PI / 4;
    this.style.dropShadowColor = "undefined" !== typeof a.dropShadowColor ? a.dropShadowColor : this.style.dropShadowColor || "black"
};
SText.prototype.updateText = function() {
    Application.instance.getContext().font = this.style.font;
    this.outputText = this._text;
    this.style.wordWrap && (this.outputText = this.wordWrap(this._text));
    Application.instance.getContext().font = this.style.font;
    Application.instance.getContext().strokeStyle = this.style.stroke;
    Application.instance.getContext().lineWidth = this.style.strokeThickness;
    Application.instance.getContext().textBaseline = "alphabetic";
    Application.instance.getContext().lineJoin = this.style.lineJoin;
    this.lines =
        this.outputText.split(/(?:\r\n|\r|\n|\<br>)/);
    this._lineWidths = [];
    this._maxLineWidth = 0;
    for (var a = this.determineFontProperties(this.style.font), b = 0; b < this.lines.length; b++) {
        var c = Application.instance.getContext().measureText(this.lines[b]).width;
        this._lineWidths[b] = c;
        this._maxLineWidth = Math.max(this._maxLineWidth, c)
    }
    this._width = this._maxLineWidth + this.style.strokeThickness;
    this._lineHeight = this.determineFontProperties(this.style.font).fontSize + this.style.strokeThickness;
    this._height = this._lineHeight *
        this.lines.length;
    var d;
    if (this.style.dropShadow) {
        Application.instance.getContext().fillStyle = this.style.dropShadowColor;
        for (var e = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance, f = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance, b = 0; b < this.lines.length; b++) c = this.style.strokeThickness / 2, d = this.style.strokeThickness / 2 + b * this._lineHeight + a.ascent, this.style.align === GuiText.ALIGN_RIGHT ? c += this._maxLineWidth - this._lineWidths[b] : this.style.align === GuiText.ALIGN_CENTER &&
            (c += (this._maxLineWidth - this._lineWidths[b]) / 2), this.style.fill && Application.instance.getContext().fillText(this.lines[b], c + e, d + f)
    }
    Application.instance.getContext().fillStyle = this.style.fill;
    for (b = 0; b < this.lines.length; b++) c = this.style.strokeThickness / 2, d = this.style.strokeThickness / 2 + b * this._lineHeight + a.ascent, this.style.align === GuiText.ALIGN_RIGHT ? c += this._maxLineWidth - this._lineWidths[b] : this.style.align === GuiText.ALIGN_CENTER && (c += (this._maxLineWidth - this._lineWidths[b]) / 2), this.style.stroke &&
        this.style.strokeThickness && Application.instance.getContext().strokeText(this.lines[b], c, d), this.style.fill && Application.instance.getContext().fillText(this.lines[b], c, d)
};
SText.prototype._renderCanvas = function(a) {
    if (!1 !== this.visible && 0 !== this.alpha) {
        var b = a.context;
        b.setTransform(this.worldTransform.a, this.worldTransform.b, this.worldTransform.c, this.worldTransform.d, this.worldTransform.tx * a.resolution, this.worldTransform.ty * a.resolution);
        b.strokeStyle = this.style.stroke;
        b.lineWidth = this.style.strokeThickness;
        b.textBaseline = "middle";
        b.globalAlpha = this.worldAlpha;
        b.fillStyle = this.style.fill;
        b.font = this.style.font;
        for (a = 0; a < this.lines.length; a++) {
            var c = new SPoint(0, a *
                this._lineHeight);
            Application.RIGHT_TO_LEFT ? (this.style.align === GuiText.ALIGN_RIGHT ? c.x = 0 : this.style.align === GuiText.ALIGN_CENTER ? c.x = this._maxLineWidth - this._lineWidths[a] >> 1 : this.style.align === GuiText.ALIGN_LEFT && (c.x = this._maxLineWidth - this._lineWidths[a]), c.x = -c.x) : this.style.align === GuiText.ALIGN_RIGHT ? c.x = this._maxLineWidth - this._lineWidths[a] : this.style.align === GuiText.ALIGN_CENTER && (c.x = this._maxLineWidth - this._lineWidths[a] >> 1);
            this.style.stroke && this.style.strokeThickness && b.strokeText(this.lines[a],
                c.x, c.y);
            this.style.fill && b.fillText(this.lines[a], c.x, c.y)
        }
        b.lineWidth = 1
    }
};
SText.prototype.determineFontProperties = function(a) {
    var b = PIXI.Text.fontPropertiesCache[a];
    if (!b) {
        var b = {},
            c = PIXI.Text.fontPropertiesCanvas,
            d = PIXI.Text.fontPropertiesContext;
        d.font = a;
        var e = Math.ceil(d.measureText("|Mq").width),
            f = Math.ceil(d.measureText("M").width),
            g = 2 * f,
            f = 1.4 * f | 0;
        c.width = e;
        c.height = g;
        d.fillStyle = "#f00";
        d.fillRect(0, 0, e, g);
        d.font = a;
        d.textBaseline = "alphabetic";
        d.fillStyle = "#000";
        d.fillText("|M\u00c9q", 0, f);
        var c = d.getImageData(0, 0, e, g).data,
            d = c.length,
            e = 4 * e,
            h, k, m = 0,
            l = !1;
        for (h = 0; h < f; h++) {
            for (k =
                0; k < e; k += 4)
                if (255 !== c[m + k]) {
                    l = !0;
                    break
                }
            if (l) break;
            else m += e
        }
        b.ascent = f - h;
        m = d - e;
        l = !1;
        for (h = g; h > f; h--) {
            for (k = 0; k < e; k += 4)
                if (255 !== c[m + k]) {
                    l = !0;
                    break
                }
            if (l) break;
            else m -= e
        }
        b.descent = h - f;
        b.descent += 6;
        b.fontSize = b.ascent + b.descent;
        PIXI.Text.fontPropertiesCache[a] = b
    }
    return b
};
SText.prototype.destroy = function(a) {
    this.lines = this.style = null
};
SText.prototype.wordWrap = function(a) {
    var b = "";
    a = a.split("\n");
    for (var c = Application.instance.getContext(), d = 0; d < a.length; d++) {
        for (var e = this.style.wordWrapWidth, f = a[d].split(" "), g = 0; g < f.length; g++) {
            var h = c.measureText(f[g]).width,
                k = h + c.measureText(" ").width;
            0 === g || k > e ? (0 < g && (b += "\n"), b += f[g], e = this.style.wordWrapWidth - h) : (e -= k, b += " " + f[g])
        }
        d < a.length - 1 && (b += "\n")
    }
    return b
};

function SGraphics() {
    PIXI.Graphics.call(this)
}
Application.subclass(SGraphics, PIXI.Graphics);
SGraphics.prototype.free = function() {
    PIXI.Graphics.prototype.destroy.call(this)
};
SGraphics.prototype.drawLine = function(a, b, c, d, e, f, g) {
    this.lineStyle("undefined" === typeof f ? 1 : f, "undefined" === typeof e ? Common.COLOR_BLACK : e, "undefined" === typeof g ? 1 : g);
    this.moveTo(a, b);
    this.lineTo(c, d)
};
SGraphics.prototype.drawRectangle = function(a, b, c, d, e, f, g, h, k) {
    "undefined" === typeof g ? this.fillColor = void 0 : this.beginFill(g, "undefined" === typeof k ? 1 : k);
    this.lineStyle("undefined" === typeof e ? 1 : e, "undefined" === typeof f ? Common.COLOR_BLACK : f, "undefined" === typeof h ? 1 : h);
    this.drawRect(a, b, c, d);
    this.endFill()
};
SGraphics.prototype.drawCircle = function(a, b, c, d, e, f, g, h) {
    "undefined" === typeof f ? this.fillColor = void 0 : this.beginFill(f, "undefined" === typeof h ? 1 : h);
    this.lineStyle("undefined" === typeof d ? 1 : d, "undefined" === typeof e ? Common.COLOR_BLACK : e, "undefined" === typeof g ? 1 : g);
    PIXI.Graphics.prototype.drawCircle.call(this, a, b, c);
    this.endFill()
};
SGraphics.prototype.drawEllipse = function(a, b, c, d, e, f, g, h, k) {
    "undefined" === typeof g ? this.fillColor = void 0 : this.beginFill(g, "undefined" === typeof k ? 1 : k);
    this.lineStyle("undefined" === typeof e ? 1 : e, "undefined" === typeof f ? Common.COLOR_BLACK : f, "undefined" === typeof h ? 1 : h);
    PIXI.Graphics.prototype.drawEllipse.call(this, a, b, c, d);
    this.endFill()
};
SGraphics.prototype.drawCross = function(a, b, c, d, e, f) {
    this.lineStyle("undefined" === typeof e ? 1 : e, "undefined" === typeof d ? Common.COLOR_BLACK : d, "undefined" === typeof f ? 1 : f);
    this.moveTo(a - c, b - c);
    this.lineTo(a + c, b + c);
    this.moveTo(a - c, b + c);
    this.lineTo(a + c, b - c)
};
SGraphics.prototype.drawArrow = function(a, b, c, d, e, f, g, h, k, m) {
    "undefined" === typeof e && (e = 5);
    "undefined" === typeof h ? this.fillColor = void 0 : this.beginFill(h, "undefined" === typeof m ? 1 : m);
    this.lineStyle("undefined" === typeof f ? 1 : f, "undefined" === typeof g ? Common.COLOR_BLACK : g, "undefined" === typeof k ? 1 : k);
    this.moveTo(a, b);
    this.lineTo(c, d);
    a = new SVector3(c - a, d - b);
    a.normalize();
    this.lineTo(c - e * (a.x + a.y), d - e * (a.y - a.x));
    this.moveTo(c, d);
    this.lineTo(c - e * (a.x - a.y), d - e * (a.y + a.x))
};

function Animation(a) {
    SDisplayObjectContainer.call(this);
    this.tint = 16777215;
    this.m_interpolations = [];
    this.m_endedInterpolations = [];
    this.m_layerNames = {};
    this.screenLinked = null;
    this.screenActionStop = 0;
    this.atlas = [];
    this.dataLayers = [];
    this.params = null;
    this.name = a;
    this.loop = !0;
    (this.data = null === a || 0 === a.length ? null : window.globalAnimations[a]) ? (this.params = this.data.params, this.atlas = this.data.atlas, this.dataLayers = this.data.l) : Application.error("Animation :: clip with id [" + a + "] no found, check Asset(Animo Json) is register or loaded");
    this.indexFrames = {};
    this.indexActions = {};
    this.displayLayers = [];
    this.createLayers();
    this.m_changeTimeCounter = 0;
    null != this.data ? (this.m_changeTime = 1 / parseInt(this.data[Animation.FPS], 10) * 1E3, this.totalFrames = parseInt(this.data[Animation.FRAMES], 10)) : this.totalFrames = this.m_changeTime = 0;
    this.currentFrame = -1;
    this.setFrame(0);
    this.m_endAniFunction = this.m_endAniCaller = null;
    this.stoppedChildren = this.m_stopped = !1
}
Application.subclass(Animation, SDisplayObjectContainer);
Animation.POS_X = "x";
Animation.POS_Y = "y";
Animation.ASSET = "a";
Animation.ASSET_LIST = "i";
Animation.ASSET_ID = "k";
Animation.CENTER_X = "u";
Animation.CENTER_Y = "v";
Animation.SCALE_X = "w";
Animation.SCALE_Y = "h";
Animation.ANGLE = "g";
Animation.ALPHA = "t";
Animation.COLLISION = "c";
Animation.INSTANCE_NAME = "o";
Animation.BLEND_MODE = "b";
Animation.NAME = "n";
Animation.FPS = "r";
Animation.LAYER = "l";
Animation.FRAMES = "f";
Animation.FRAMES_ACTIONS = "fa";
Animation.ACTIONS = "a";
Animation.FRAME = "n";
Animation.INTERPOLATE = "p";
Animation.prototype.clearAll = function() {
    for (var a = 0; a < this.displayLayers.length; a++) null !== this.displayLayers[a] && (this.removeChild(this.displayLayers[a]), this.displayLayers[a].free(), this.displayLayers[a] = null);
    this.displayLayers = []
};
Animation.prototype.free = function() {
    this.m_layerNames = null;
    for (var a = 0; a < this.displayLayers.length; a++) null !== this.displayLayers[a] && (this.removeChild(this.displayLayers[a]), this.displayLayers[a].free(), this.displayLayers[a] = null);
    this.data = this.params = this.dataLayers = this.atlas = this.screenLinked = this.m_endAniFunction = this.m_endAniCaller = this.indexActions = this.indexFrames = this.displayLayers = null;
    if (this.m_interpolations)
        for (var b in this.m_interpolations) this.m_interpolations[b] && (this.m_interpolations[b].free(),
            this.m_interpolations[b] = null);
    this.m_endedInterpolations = this.m_interpolations = null;
    for (var c in this.collisions) this.collisions[c] = null;
    this.collisions = null;
    SDisplayObjectContainer.prototype.free.call(this)
};
Animation.prototype.getLayer = function(a) {
    return "undefined" !== typeof this.m_layerNames[a] ? this.m_layerNames[a] : null
};
Animation.prototype.stop = function() {
    this.m_stopped = !0
};
Animation.prototype.resume = function() {
    this.m_stopped = !1
};
Animation.prototype.gotoAndStop = function(a) {
    0 >= a && (a = 1);
    a > this.totalFrames && (a = this.totalFrames);
    this.setFrame(a - 1);
    this.stop()
};
Animation.prototype.gotoAndPlay = function(a) {
    0 >= a && (a = 1);
    a > this.totalFrames && (a = this.totalFrames);
    this.setFrame(a - 1);
    this.resume()
};
Animation.prototype.onEndAnimation = function(a, b) {
    this.m_endAniCaller = a;
    this.m_endAniFunction = b
};
Animation.prototype.setTint = function(a) {
    this.tint = a;
    for (var b = 0; b < this.displayLayers.length; b++) this.displayLayers[b] && (this.displayLayers[b].tint = a)
};
Animation.prototype.update = function(a) {
    if (!this.stoppedChildren)
        for (var b = 0; b < this.displayLayers.length; b++)
            if (this.displayLayers[b] && this.displayLayers[b].children)
                for (var c = 0; c < this.displayLayers[b].children.length; c++) this.displayLayers[b].children[c].update && this.displayLayers[b].children[c].update(a);
    if (!(this.m_stopped || 1 >= this.totalFrames)) {
        for (var d in this.m_interpolations) this.m_interpolations[d] && this.m_interpolations[d].update(a) && this.m_endedInterpolations.push(d);
        if (this.m_endedInterpolations)
            for (; 0 <
                this.m_endedInterpolations.length;) b = this.m_endedInterpolations.pop(), this.m_interpolations[b].free(), this.m_interpolations[b] = null;
        this.m_changeTimeCounter += a;
        this.m_changeTimeCounter >= this.m_changeTime && (this.setFrame(this.currentFrame), this.m_changeTimeCounter -= this.m_changeTime, this.currentFrame++, this.currentFrame >= this.totalFrames && (this.loop ? this.currentFrame = 0 : this.m_stopped = !0, null !== this.m_endAniCaller && null !== this.m_endAniFunction && this.m_endAniFunction.call(this.m_endAniCaller, this)))
    }
};
Animation.prototype.setFrame = function(a) {
    this.currentFrame = a;
    for (var b, c = 0, c = 0; c < this.dataLayers.length; c++) b = this.indexFrames[c + "_" + a], "undefined" !== typeof b && this.setSprite(c, b);
    if (this.indexActions["act_" + a])
        for (c = 0; c < this.indexActions["act_" + a].length; c++) AnimationActions.applyAction(this, this.indexActions["act_" + a][c])
};
Animation.prototype.createLayers = function() {
    for (var a = 0, b = 0; b < this.dataLayers.length; b++)
        if (this.dataLayers[b][Animation.FRAMES]) {
            for (a = 0; a < this.dataLayers[b][Animation.FRAMES].length; a++) this.indexFrames[b + "_" + this.dataLayers[b][Animation.FRAMES][a][Animation.FRAME]] = this.dataLayers[b][Animation.FRAMES][a];
            this.displayLayers.push(null);
            this.m_layerNames[this.dataLayers[b][Animation.NAME]] = null
        } else if (this.dataLayers[b][Animation.FRAMES_ACTIONS])
        for (a = 0; a < this.dataLayers[b][Animation.FRAMES_ACTIONS].length; a++) this.parseActions(this.dataLayers[b][Animation.FRAMES_ACTIONS][a][Animation.FRAME],
            this.dataLayers[b][Animation.FRAMES_ACTIONS][a])
};
Animation.prototype.parseActions = function(a, b) {
    var c = "act_" + a;
    this.indexActions[c] || (this.indexActions[c] = []);
    for (var d = Common.trim(b[Animation.ACTIONS]).split(";"), e = 0; e < d.length; e++) {
        var f = d[e].split(":"),
            g = new AnimationActions;
        g.name = Common.trim(f[0].toLowerCase());
        1 < f.length && (g.params = Common.trim(f[1]));
        g.name === AnimationActions.ACT_STOP_GUI && (this.screenActionStop = a);
        this.indexActions[c].push(g)
    }
};
Animation.prototype.getInstance = function(a) {
    "undefined" === typeof this[a] && Application.error("Instance [" + a + "] no found in clip");
    return this[a]
};
Animation.prototype.getInstanceNotException = function(a) {
    return "undefined" === typeof this[a] ? null : this[a]
};
Animation.prototype.setSprite = function(a, b) {
    this.m_interpolations[a] && (this.m_interpolations[a].free(), this.m_interpolations[a] = null);
    b[Animation.CENTER_X] = b[Animation.CENTER_X] || 0;
    b[Animation.CENTER_Y] = b[Animation.CENTER_Y] || 0;
    1 === b[Animation.COLLISION] && b[Animation.INSTANCE_NAME] && 1 < b.w && 1 < b.h && (this.collisions[b[Animation.INSTANCE_NAME]] = new Rectangle(b.x, b.y, b.w / Application.DPI, b.h / Application.DPI), "mcCollision" === b[Animation.INSTANCE_NAME] && (this.hitArea = this.collisions[b[Animation.INSTANCE_NAME]]));
    if (-1 === b[Animation.ASSET_ID]) null !== this.displayLayers[a] && (this.displayLayers[a].visible = !1);
    else {
        var c = this.atlas[b[Animation.ASSET_LIST]] + "_" + b[Animation.ASSET_ID];
        null === this.displayLayers[a] ? (this.displayLayers[a] = new SSprite(c), "undefined" !== typeof this.dataLayers[a][Animation.BLEND_MODE] && (2 === this.dataLayers[a][Animation.BLEND_MODE] ? this.displayLayers[a].blendMode = PIXI.BLEND_MODES.ADD : 3 === this.dataLayers[a][Animation.BLEND_MODE] && Application.RENDER_MODE === Application.RENDER_WEBGL && (this.displayLayers[a].blendMode =
            PIXI.BLEND_MODES.MULTIPLY)), this.addChild(this.displayLayers[a]), this.m_layerNames[this.dataLayers[a][Animation.NAME]] = this.displayLayers[a]) : this.displayLayers[a].texture = PIXI.Texture.fromImage(c, !1, 0);
        this.displayLayers[a].position.x = b[Animation.POS_X];
        this.displayLayers[a].position.y = b[Animation.POS_Y];
        b[Animation.ANGLE] = b[Animation.ANGLE] || 0;
        this.displayLayers[a].rotation = b[Animation.ANGLE] * Math.PI / 180;
        b[Animation.SCALE_X] === Application.UNDEFINED && (b[Animation.SCALE_X] = 1);
        this.displayLayers[a].scale.x =
            b[Animation.SCALE_X];
        b[Animation.SCALE_Y] === Application.UNDEFINED && (b[Animation.SCALE_Y] = 1);
        this.displayLayers[a].scale.y = b[Animation.SCALE_Y];
        b[Animation.ALPHA] === Application.UNDEFINED && (b[Animation.ALPHA] = 1);
        this.displayLayers[a].alpha = b[Animation.ALPHA];
        this.displayLayers[a].visible = !0;
        b[Animation.INTERPOLATE] && 0 !== b[Animation.INTERPOLATE] && (c = this.indexFrames[a + "_" + b[Animation.INTERPOLATE]], c[Animation.CENTER_X] = c[Animation.CENTER_X] || 0, c[Animation.CENTER_Y] = c[Animation.CENTER_Y] || 0, c[Animation.ANGLE] =
            c[Animation.ANGLE] || 0, c[Animation.SCALE_X] === Application.UNDEFINED && (c[Animation.SCALE_X] = 1), c[Animation.SCALE_Y] === Application.UNDEFINED && (c[Animation.SCALE_Y] = 1), c[Animation.ALPHA] === Application.UNDEFINED && (c[Animation.ALPHA] = 1), this.m_interpolations[a] = new Interpolation(this.displayLayers[a], !0, b, c, 1E3 * (c[Animation.FRAME] - b[Animation.FRAME]) / this.data[Animation.FPS]));
        b[Animation.INSTANCE_NAME] && "" !== b[Animation.INSTANCE_NAME] && (this.displayLayers[a].name = b[Animation.INSTANCE_NAME], this[b[Animation.INSTANCE_NAME]] =
            this.displayLayers[a])
    }
};

function AnimationActions() {
    this.params = this.name = null
}
AnimationActions.ACT_STOP = "s";
AnimationActions.ACT_STOP_GUI = "sg";
AnimationActions.ACT_FINISH_GUI = "fg";
AnimationActions.ACT_PLAY = "p";
AnimationActions.ACT_PLAY_SOUND = "ps";
AnimationActions.ACT_GO_TO_AND_PLAY = "gp";
AnimationActions.ACT_GO_TO_AND_STOP = "gs";
AnimationActions.ACT_GO_TO_RANDOM_AND_STOP = "rs";
AnimationActions.ACT_GO_TO_RANDOM_AND_PLAY = "rp";
AnimationActions.ACT_CREATE_FX = "fx";
AnimationActions.ACT_CALL_FUNCTION = "f";
AnimationActions.applyAction = function(a, b) {
    switch (b.name) {
        case AnimationActions.ACT_STOP:
            a.stop();
            break;
        case AnimationActions.ACT_PLAY:
            a.resume();
            break;
        case AnimationActions.ACT_GO_TO_AND_PLAY:
            a.gotoAndPlay(parseInt(b.params, 10));
            break;
        case AnimationActions.ACT_GO_TO_AND_STOP:
            a.gotoAndStop(parseInt(b.params, 10));
            break;
        case AnimationActions.ACT_GO_TO_RANDOM_AND_STOP:
            var c = Common.randomInt(1, a.totalFrames);
            a.gotoAndStop(c);
            break;
        case AnimationActions.ACT_GO_TO_RANDOM_AND_PLAY:
            c = Common.randomInt(1, a.totalFrames);
            a.gotoAndPlay(c);
            break;
        case AnimationActions.ACT_PLAY_SOUND:
            Application.instance.playSound(Common.trim(b.params));
            break;
        case AnimationActions.ACT_CREATE_FX:
            b.params = b.params.replace(/\s/g, "");
            var d = b.params.split(","),
                c = d[0],
                e = 1 < d.length ? parseInt(d[1], 10) : 0,
                f = 2 < d.length ? parseInt(d[2], 10) : 0,
                d = 3 < d.length ? a.getInstance(d[3]) : a.screenLinked.canvas;
            Application.instance.effectManager.createEffect(c, e, f, d);
            break;
        case AnimationActions.ACT_CALL_FUNCTION:
            break;
        case AnimationActions.ACT_STOP_GUI:
            if (a.screenLinked) a.screenLinked.onStopScreen();
            break;
        case AnimationActions.ACT_FINISH_GUI:
            if (a.screenLinked) a.screenLinked.onFinishScreen();
            break;
        default:
            Application.warn("Please define Action[ " + b.name + " ] in animation")
    }
};

function Interpolation(a, b, c, d, e) {
    this.m_sprite = a;
    this.m_smooth = b;
    this.m_alpha = c[Animation.ALPHA];
    this.m_angle = c[Animation.ANGLE];
    this.m_scaleX = c[Animation.SCALE_X];
    this.m_scaleY = c[Animation.SCALE_Y];
    this.m_start = c;
    this.m_end = d;
    this.m_totalTime = e;
    this.m_time = 0;
    this.m_x = c[Animation.POS_X];
    this.m_y = c[Animation.POS_Y];
    this.m_startCornerY = this.m_startCornerX = 0;
    this.m_interpolateX = c[Animation.POS_X] !== d[Animation.POS_X];
    this.m_interpolateY = c[Animation.POS_Y] !== d[Animation.POS_Y];
    this.m_interpolateScaleX =
        c[Animation.SCALE_X] !== d[Animation.SCALE_X];
    this.m_interpolateScaleY = c[Animation.SCALE_Y] !== d[Animation.SCALE_Y];
    this.m_interpolateAlpha = c[Animation.ALPHA] !== d[Animation.ALPHA];
    if (this.m_interpolateAngle = c[Animation.ANGLE] !== d[Animation.ANGLE]) this.m_c1 = new Vector2D(c[Animation.SCALE_X] * c[Animation.CENTER_X], c[Animation.SCALE_Y] * c[Animation.CENTER_Y]), this.m_c1.rotate(Math.PI * c[Animation.ANGLE] / 180), a = new Vector2D(c[Animation.POS_X], c[Animation.POS_Y]), this.m_c1.add(a), this.m_c2 = new Vector2D(d[Animation.SCALE_X] *
        c[Animation.CENTER_X], d[Animation.SCALE_Y] * c[Animation.CENTER_Y]), this.m_c2.rotate(Math.PI * d[Animation.ANGLE] / 180), a = new Vector2D(d[Animation.POS_X], d[Animation.POS_Y]), this.m_c2.add(a), this.m_c = new Vector2D
}
Interpolation.prototype.update = function(a) {
    var b = !1;
    this.m_time += a;
    this.m_time >= this.m_totalTime && (b = !0, this.m_time = this.m_totalTime);
    this.m_interpolateAlpha && (this.m_alpha = this.interpolate(this.m_start[Animation.ALPHA], this.m_end[Animation.ALPHA], this.m_time));
    this.m_interpolateAngle && (this.m_angle = this.interpolate(this.m_start[Animation.ANGLE], this.m_end[Animation.ANGLE], this.m_time));
    this.m_interpolateScaleX && (this.m_scaleX = this.interpolate(this.m_start[Animation.SCALE_X], this.m_end[Animation.SCALE_X],
        this.m_time));
    this.m_interpolateScaleY && (this.m_scaleY = this.interpolate(this.m_start[Animation.SCALE_Y], this.m_end[Animation.SCALE_Y], this.m_time));
    var c = a = 0,
        d, e;
    if (this.m_interpolateAngle) d = .017453292519943295 * this.m_angle, Math.cos(d), Math.sin(d), this.m_c.x = this.interpolate(this.m_c1.x, this.m_c2.x, this.m_time), this.m_c.y = this.interpolate(this.m_c1.y, this.m_c2.y, this.m_time), c = new Vector2D(this.m_scaleX * this.m_start[Animation.CENTER_X], this.m_scaleY * this.m_start[Animation.CENTER_Y]), c.rotate(d), e =
        new Vector2D(this.m_scaleX * this.m_startCornerX, this.m_scaleY * this.m_startCornerY), e.rotate(d), a = this.m_c.x - c.x - e.x, c = this.m_c.y - c.y - e.y;
    else {
        this.m_x = this.m_start[Animation.POS_X];
        this.m_interpolateX && (this.m_x = this.interpolate(this.m_start[Animation.POS_X], this.m_end[Animation.POS_X], this.m_time));
        this.m_y = this.m_start[Animation.POS_Y];
        this.m_interpolateY && (this.m_y = this.interpolate(this.m_start[Animation.POS_Y], this.m_end[Animation.POS_Y], this.m_time));
        var f = this.m_startCornerX,
            g = this.m_startCornerY;
        a = this.m_x;
        c = this.m_y;
        0 !== this.m_angle ? (d = .017453292519943295 * this.m_angle, e = Math.cos(d), d = Math.sin(d), 1 !== this.m_scaleX && (f *= this.m_scaleX), 1 !== this.m_scaleY && (g *= this.m_scaleY), a += g * d - f * e, c += -f * d - g * e) : (1 !== this.m_scaleX && (f *= this.m_scaleX), 1 !== this.m_scaleY && (g *= this.m_scaleY), a -= f, c -= g)
    }
    this.m_sprite.position.x = a;
    this.m_sprite.position.y = c;
    this.m_sprite.scale.x = this.m_scaleX;
    this.m_sprite.scale.y = this.m_scaleY;
    this.m_sprite.rotation = .017453292519943295 * this.m_angle;
    this.m_sprite.alpha = this.m_alpha;
    return b
};
Interpolation.prototype.interpolate = function(a, b, c) {
    return c * (b - a) / this.m_totalTime + a
};
Interpolation.prototype.toString = function() {
    return "INTERPOLATION:   " + this.m_start + " to " + this.m_end
};
Interpolation.prototype.free = function() {
    this.m_sprite = this.m_c2 = this.m_c1 = this.m_c = this.m_end = this.m_start = null
};

function NanoEffect(a, b, c, d, e) {
    this.x = b;
    this.y = c;
    this.canvas = d;
    this.name = a;
    this.isAwaitingDelete = !1;
    this.data = window.nano.effects[a];
    this.params = e || {};
    this.emitters = [];
    this.emittersIndex = {};
    for (a = 0; a < this.data.length; a++) b = this.data[a].emitter, window.nano.emitters[b] ? (b = new NanoEmitter(this, window.nano.emitters[b]), b.ox = this.data[a].pos_x, b.oy = this.data[a].pos_y, b.name = this.data[a].emitter, this.emittersIndex[this.data[a].emitter] = b, this.emitters.push(b)) : Application.warn("Emiiter [" + b + "] no found")
}
NanoEffect.prototype.setPause = function(a) {
    for (var b = 0; b < this.emitters.length; b++) this.emitters[b].pause = a
};
NanoEffect.prototype.update = function(a) {
    for (var b = 0; b < this.emitters.length; b++) this.emitters[b].update(a), this.emitters[b].isAwaitingDelete && (delete this.emittersIndex[this.emitters[b].name], this.emitters[b].free(), this.emitters[b] = null, this.emitters.splice(b, 1), b--);
    0 === this.emitters.length && (this.isAwaitingDelete = !0)
};
NanoEffect.prototype.free = function() {
    for (var a in this.emittersIndex) delete this.emittersIndex[a];
    this.emittersIndex = null;
    for (a = 0; a < this.emitters.length; a++) this.emitters[a].free(), this.emitters[a] = null;
    this.canvas = null
};
NanoEffect.random = function(a, b) {
    return Math.random() * (b - a) + a
};
NanoEffect.randomInt = function(a, b) {
    return a + Math.floor(Math.random() * (b - a + 1))
};

function NanoEmitter(a, b) {
    this.effect = a;
    this.data = b;
    this.data[NanoParticle.CLIP_ARRAY] = this.data[NanoParticle.CLIP].split(",");
    this.data[NanoParticle.TINT_ARRAY] = this.data[NanoParticle.TINT].split(",");
    this.canvas = this.effect.canvas;
    this.frequency = b[NanoEmitter.FRECUENCY];
    this.delay = b[NanoEmitter.DELAY];
    this.particles = [];
    this.isAwaitingDelete = !1;
    this.oy = this.ox = this.counter = 0;
    this.name = "";
    this.state = NanoEmitter.ST_INTRO;
    this.pause = !1
}
NanoEmitter.ST_INTRO = 1;
NanoEmitter.ST_EMISSION = 2;
NanoEmitter.FRECUENCY = "em_frequency";
NanoEmitter.QUANTITY_MIN = "em_quantity_min";
NanoEmitter.QUANTITY_MAX = "em_quantity_max";
NanoEmitter.MAX_PARTICLES = "em_max_particles";
NanoEmitter.ANGLE_MIN = "em_angle_min";
NanoEmitter.ANGLE_MAX = "em_angle_max";
NanoEmitter.ROTATION_SPEED = "em_rotation_speed";
NanoEmitter.DISTRIBUTE = "em_distribute";
NanoEmitter.DELAY = "em_delay";
NanoEmitter.POS_X = "pos_x";
NanoEmitter.POS_Y = "pos_y";
NanoEmitter.prototype.createParticles = function() {
    if (!(this.pause || 0 !== this.data[NanoEmitter.MAX_PARTICLES] && this.counter >= this.data[NanoEmitter.MAX_PARTICLES])) {
        var a = NanoEffect.randomInt(this.data[NanoEmitter.QUANTITY_MIN], this.data[NanoEmitter.QUANTITY_MAX]),
            b, c;
        this.data[NanoEmitter.DISTRIBUTE] && (c = 1 < a ? (this.data[NanoEmitter.ANGLE_MAX] - this.data[NanoEmitter.ANGLE_MIN]) / (a - 1) : this.data[NanoEmitter.ANGLE_MIN]);
        for (var d = 0; d < a; d++) b = this.data[NanoEmitter.DISTRIBUTE] ? new NanoParticle(this, this.data[NanoEmitter.ANGLE_MIN] +
            d * c) : new NanoParticle(this, NanoEffect.random(this.data[NanoEmitter.ANGLE_MIN], this.data[NanoEmitter.ANGLE_MAX])), this.counter++, this.particles.push(b)
    }
};
NanoEmitter.prototype.update = function(a) {
    switch (this.state) {
        case NanoEmitter.ST_INTRO:
            0 >= this.delay && (this.createParticles(), this.state = NanoEmitter.ST_EMISSION);
            this.delay -= a;
            break;
        case NanoEmitter.ST_EMISSION:
            this.frequency -= a;
            0 >= this.frequency && (this.createParticles(), this.frequency = this.data[NanoEmitter.FRECUENCY]);
            for (var b = 0; b < this.particles.length; b++) this.particles[b].update(a), this.particles[b].isAwaitingDelete && (this.particles[b].free(), this.particles[b] = null, this.particles.splice(b, 1), b--);
            0 < this.data[NanoEmitter.MAX_PARTICLES] && this.counter >= this.data[NanoEmitter.MAX_PARTICLES] && 0 === this.particles.length && (this.isAwaitingDelete = !0)
    }
};
NanoEmitter.prototype.free = function() {
    for (var a = 0; a < this.particles.length; a++) this.particles[a].free();
    this.data = this.effect = null
};

function NanoParticle(a, b) {
    this.canvas = a.canvas;
    this.data = a.data;
    this.isAwaitingDelete = !1;
    this.time = 0;
    this.inPool = !1;
    var c = Common.getRandomFromArray(this.data[NanoParticle.CLIP_ARRAY]);
    window.PIXI.utils.TextureCache[c] ? this.clip = new window.PIXI.Sprite(window.PIXI.Texture.fromImage(c)) : (this.clip = PoolClips.instance.getClip(Common.getRandomFromArray(this.data[NanoParticle.CLIP_ARRAY])), this.inPool = !0);
    this.canvas && this.canvas.children ? this.canvas.addChild(this.clip) : this.isAwaitingDelete = !0;
    this.clip.position.x =
        a.effect.x + a.ox + NanoEffect.random(this.data[NanoParticle.X_MIN], this.data[NanoParticle.X_MAX]);
    this.clip.position.y = a.effect.y + a.oy + NanoEffect.random(this.data[NanoParticle.Y_MIN], this.data[NanoParticle.Y_MAX]);
    this.clip.scale.x = this.clip.scale.y = NanoEffect.random(this.data[NanoParticle.SCALE_MIN], this.data[NanoParticle.SCALE_MAX]);
    this.clip.rotation = NanoEffect.random(this.data[NanoParticle.ROTATION_MIN], this.data[NanoParticle.ROTATION_MAX]);
    this.clip.alpha = NanoEffect.random(this.data[NanoParticle.ALPHA_MIN],
        this.data[NanoParticle.ALPHA_MAX]);
    this.timelife = NanoEffect.randomInt(this.data[NanoParticle.TIMELIFE_MIN], this.data[NanoParticle.TIMELIFE_MAX]);
    this.rotationSpeed = NanoEffect.random(this.data[NanoParticle.ROTATION_SPEED_MIN], this.data[NanoParticle.ROTATION_SPEED_MAX]);
    this.clip.blendMode = window.PIXI.BLEND_MODES[this.data[NanoParticle.BLEND]];
    c = NanoEffect.random(this.data[NanoParticle.SPEED_MIN], this.data[NanoParticle.SPEED_MAX]);
    this.ox = this.clip.position.x;
    this.oy = this.clip.position.y;
    this.vx = c *
        Math.cos(b);
    this.vy = c * Math.sin(b);
    0 === this.data[NanoParticle.ROTATION_MIN] && 0 === this.data[NanoParticle.ROTATION_MAX] && (this.clip.rotation = b)
}
NanoParticle.CLIP = "pt_clip";
NanoParticle.TINT = "pt_tint";
NanoParticle.CLIP_ARRAY = "pt_clip_array";
NanoParticle.TINT_ARRAY = "pt_tint_array";
NanoParticle.BLEND = "pt_blend";
NanoParticle.X_MIN = "pt_x_min";
NanoParticle.X_MAX = "pt_x_max";
NanoParticle.Y_MIN = "pt_y_min";
NanoParticle.Y_MAX = "pt_y_max";
NanoParticle.SCALE_MIN = "pt_scale_min";
NanoParticle.SCALE_MAX = "pt_scale_max";
NanoParticle.SCALE_SPEED = "pt_scale_speed";
NanoParticle.SPEED_MIN = "pt_speed_min";
NanoParticle.SPEED_MAX = "pt_speed_max";
NanoParticle.ACCELERATION_X = "pt_acceleration_x";
NanoParticle.ACCELERATION_Y = "pt_acceleration_y";
NanoParticle.TIMELIFE_MIN = "pt_timelife_min";
NanoParticle.TIMELIFE_MAX = "pt_timelife_max";
NanoParticle.ROTATION_MIN = "pt_rotation_min";
NanoParticle.ROTATION_MAX = "pt_rotation_max";
NanoParticle.ROTATION_SPEED_MIN = "pt_rotation_speed_min";
NanoParticle.ROTATION_SPEED_MAX = "pt_rotation_speed_max";
NanoParticle.ALPHA_MIN = "pt_alpha_min";
NanoParticle.ALPHA_MAX = "pt_alpha_max";
NanoParticle.ALPHA_SPEED = "pt_alpha_speed";
NanoParticle.prototype.update = function(a) {
    this.time += a;
    this.clip.update && this.clip.update(a);
    this.clip.position.x = this.ox + this.vx * this.time + 5E-4 * this.data[NanoParticle.ACCELERATION_X] * this.time * this.time;
    this.clip.position.y = this.oy + this.vy * this.time + 5E-4 * this.data[NanoParticle.ACCELERATION_Y] * this.time * this.time;
    0 !== this.rotationSpeed && (this.clip.rotation += .01 * this.rotationSpeed * a);
    this.clip.scale.x += .001 * this.data[NanoParticle.SCALE_SPEED] * a;
    this.clip.scale.y += .001 * this.data[NanoParticle.SCALE_SPEED] *
        a;
    this.clip.alpha += .001 * this.data[NanoParticle.ALPHA_SPEED] * a;
    1 < this.clip.alpha && (this.clip.alpha = 1);
    0 >= this.clip.alpha && (this.isAwaitingDelete = !0);
    this.time >= this.timelife && (this.isAwaitingDelete = !0)
};
NanoParticle.prototype.free = function() {
    this.inPool ? PoolClips.instance.releaseClip(this.clip) : (this.clip && this.clip.parent && this.clip.parent.removeChild(this.clip), this.clip.free ? this.clip.free() : this.clip.destroy());
    this.data = this.canvas = this.clip = null
};

function SJsonLoader(a) {
    this.json = this.ajaxRequest = null;
    this.url = a;
    this.baseUrl = a.replace(/[^\/]*$/, "");
    this.m_errorFunction = this.m_errorCaller = this.m_loadFunction = this.m_loadCaller = null
}
SJsonLoader.prototype.addLoadedListener = function(a, b) {
    this.m_loadCaller = a;
    this.m_loadFunction = b
};
SJsonLoader.prototype.addErrorListener = function(a, b) {
    this.m_errorCaller = a;
    this.m_errorFunction = b
};
SJsonLoader.prototype.load = function() {
    if (this.ajaxRequest = Common.ajaxRequest()) {
        var a = this;
        this.ajaxRequest.onreadystatechange = function() {
            a.onJSONLoaded()
        };
        this.ajaxRequest.open("GET", this.url, !0);
        this.ajaxRequest.overrideMimeType && this.ajaxRequest.overrideMimeType("application/json");
        this.ajaxRequest.send(null)
    } else Application.error("Not found [ AJAX object ] in Browser")
};
SJsonLoader.prototype.onJSONLoaded = function() {
    4 === this.ajaxRequest.readyState && (200 === this.ajaxRequest.status || -1 === window.location.protocol.indexOf("http") ? (this.json = JSON.parse(this.ajaxRequest.responseText), this.m_loadCaller && this.m_loadFunction ? this.m_loadFunction.call(this.m_loadCaller, this) : this.m_loadFunction && this.m_loadFunction(this)) : this.m_erroCaller && this.m_errorFunction ? this.m_errorFunction.call(this.m_erroCaller, this) : this.m_errorFunction && this.m_errorFunction(this))
};

function SndManager() {
    this.callbackBug = this.m_muted = !1
}
SndManager.instance = null;
SndManager.prototype.isMuted = function() {
    return this.m_muted
};
SndManager.prototype.play = function(a) {};
SndManager.prototype.stop = function(a) {};
SndManager.prototype.pauseSound = function(a) {};
SndManager.prototype.pauseAll = function() {};
SndManager.prototype.resumeAll = function() {};
SndManager.prototype.stopAllSounds = function() {};
SndManager.prototype.toggleMute = function() {
    this.m_muted = !this.m_muted;
    Application.info("toggleMute: " + this.m_muted)
};
SndManager.prototype.stopAllMusics = function() {};
SndManager.prototype.isPlayingSound = function(a) {};
SndManager.prototype.resumeSound = function(a) {};
SndManager.prototype.setVolumeById = function(a, b) {};

function SndManagerSimple() {
    SndManager.call(this);
    SndManager.instance = this;
    var a = window.config.sounds,
        b = Application.ASSETS_PATH + "media/sounds/";
    this.soundList = {};
    this.soundPlaying = [];
    this.masterVolume = 1;
    for (var c = 0; c < a.length; ++c) {
        var d = {};
        d.src = b + a[c].file + ".ogg";
        d.id = a[c].id;
        d.loop = 0 === parseInt(a[c].loops, 10) ? !0 : !1;
        d.volume = a[c].vol;
        this.soundList[a[c].id] = d
    }
}
Application.subclass(SndManagerSimple, SndManager);
SndManagerSimple.MAX_CHANNELS = 6;
SndManagerSimple.prototype.onSoundComplete = function(a) {
    for (var b = a.target, c = 0; c < this.soundPlaying.length; c++)
        if (this.soundPlaying[c] === b) {
            this.soundPlaying.splice(c, 1);
            break
        }
    a.target = null
};
SndManagerSimple.prototype.play = function(a) {
    if (!this.m_muted)
        if ("undefined" === typeof this.soundList[a]) Application.warn("[SndManagerSimple] sound with id [" + a + "] no found");
        else if (this.soundPlaying.length >= SndManagerSimple.MAX_CHANNELS) Application.warn("[SndManagerSimple] max channels adminted [" + a + "]");
    else {
        a = this.soundList[a];
        if (a.loop)
            for (var b = 0; b < this.soundPlaying.length; b++)
                if (this.soundPlaying[b].id === a.id) return;
        var b = document.createElement("audio"),
            c = this;
        b.addEventListener("ended", function(a) {
            c.onSoundComplete(a)
        }, !1);
        b.src = a.src;
        b.id = a.id;
        b.preload = "auto";
        b.load();
        b.volume = a.volume * this.masterVolume;
        b.loop = a.loop;
        b.play();
        this.soundPlaying.push(b)
    }
};
SndManagerSimple.prototype.stop = function(a) {
    for (var b = this.soundPlaying.length - 1; 0 <= b; --b) this.soundPlaying[b].id === a && ("undefined" !== typeof this.soundPlaying[b].dispose ? this.soundPlaying[b].dispose() : this.soundPlaying[b].pause(), this.soundPlaying[b] = null, this.soundPlaying.splice(b, 1))
};
SndManagerSimple.prototype.isPlayingSound = function(a) {
    for (var b = this.soundPlaying.length - 1; 0 <= b; --b)
        if (this.soundPlaying[b].id === a) return !0;
    return !1
};
SndManagerSimple.prototype.pauseSound = function(a) {
    for (var b = this.soundPlaying.length - 1; 0 <= b; --b) this.soundPlaying[b].id === a && this.soundPlaying[b].pause()
};
SndManagerSimple.prototype.resumeSound = function(a) {
    for (var b = this.soundPlaying.length - 1; 0 <= b; --b) this.soundPlaying[b].id === a && this.soundPlaying[b].play()
};
SndManagerSimple.prototype.setMasterVolume = function(a) {
    this.masterVolume = a;
    for (a = this.soundPlaying.length - 1; 0 <= a; --a) {
        var b = this.soundPlaying[a];
        b.volume *= this.masterVolume
    }
};
SndManagerSimple.prototype.pauseAll = function() {
    for (var a = this.soundPlaying.length - 1; 0 <= a; --a) this.soundPlaying[a].pause()
};
SndManagerSimple.prototype.resumeAll = function() {
    if (!this.m_muted)
        for (var a = this.soundPlaying.length - 1; 0 <= a; --a) this.soundPlaying[a].play()
};
SndManagerSimple.prototype.stopAllSounds = function() {
    for (var a = this.soundPlaying.length - 1; 0 <= a; a--) "undefined" !== typeof this.soundPlaying[a].dispose ? this.soundPlaying[a].dispose() : this.soundPlaying[a].pause(), this.soundPlaying[a] = null;
    this.soundPlaying = []
};
SndManagerSimple.prototype.stopAllMusics = function() {
    for (var a = this.soundPlaying.length - 1; 0 <= a; a--) this.soundPlaying[a].loop && ("undefined" !== typeof this.soundPlaying[a].dispose ? this.soundPlaying[a].dispose() : this.soundPlaying[a].pause(), this.soundPlaying[a] = null, this.soundPlaying.splice(a, 1))
};
SndManagerSimple.prototype.toggleMute = function() {
    SndManager.prototype.toggleMute.call(this);
    this.m_muted ? this.pauseAll() : this.resumeAll()
};
SndManagerSimple.prototype.free = function() {
    this.stopAllSounds();
    for (var a in this.soundList) this.soundList[a] = null;
    this.soundPlaying = this.soundList = null
};
SndManagerSimple.prototype.setVolumeById = function(a, b) {
    for (var c = this.soundPlaying.length - 1; 0 <= c; c--) this.soundPlaying[c].id === a && (this.soundPlaying[c].volume = b)
};

function SndManagerIE(a, b) {
    SndManager.call(this);
    SndManager.instance = this;
    var c = window.SwitEntryPoint.infoBrowser.isIE,
        d = -1 != navigator.userAgent.indexOf("Firefox");
    navigator.userAgent.indexOf("Safari");
    var e = -1 != navigator.platform.indexOf("iPhone") || -1 != navigator.platform.indexOf("iPod") || -1 != navigator.platform.indexOf("iPad") || -1 != navigator.platform.indexOf("Mac");
    c || e && d || Application.error("Using SndManagerIE for no IE browsers");
    this.sounds = {};
    this.soundList = a;
    this.callback = b;
    this.soundsLoaded =
        0;
    this.soundsTotal = a.length;
    GuiLoader.instance && (GuiLoader.instance.totalFiles = this.soundsTotal);
    window.soundManager.setup({
        url: "media/swf/",
        flashVersion: 9,
        useHTML5Audio: !0,
        preferFlash: !0,
        useHighPerformance: !0,
        flashLoadTimeout: 2E3,
        noSWFCache: !1,
        consoleOnly: !0,
        wmode: null,
        debugMode: !1,
        onready: this.onReady,
        ontimeout: function() {
            Application.instance.onErrorSndManagerIE()
        }
    })
}
Application.subclass(SndManagerIE, SndManager);
SndManagerIE.prototype.onReady = function() {
    for (var a = Application.ASSETS_PATH + "media/sounds/", b = SndManager.instance.soundList, c = window.soundManager, d = 0; d < b.length; d++) c.createSound({
        id: b[d].id,
        url: a + b[d].file + ".mp3",
        autoLoad: !0,
        onload: function() {
            SndManager.instance.onLoad(this.url)
        }
    }), SndManager.instance.sounds[b[d].id] = b[d]
};
SndManagerIE.prototype.onLoad = function(a) {
    this.soundsLoaded++;
    Application.log("SndManagerIE.onLoad: " + a + " " + this.soundsLoaded + "/" + this.soundsTotal);
    GuiLoader.instance && GuiLoader.instance.load();
    this.soundsLoaded === this.soundsTotal && this.callback()
};
SndManagerIE.prototype.play = function(a) {
    if (!this.m_muted && "undefined" !== typeof this.sounds[a]) {
        var b = window.soundManager,
            c = this.sounds[a].loops;
        1 !== c ? (0 === c && (c = 999999), 0 === b.sounds[a].instanceCount && b.play(a, {
            volume: 100 * this.sounds[a].vol,
            loops: c
        })) : b.play(a, {
            volume: 100 * this.sounds[a].vol
        })
    }
};
SndManagerIE.prototype.stop = function(a) {
    window.soundManager.stop(a)
};
SndManagerIE.prototype.pauseAll = function() {
    window.soundManager.pauseAll()
};
SndManagerIE.prototype.resumeAll = function() {
    this.m_muted || window.soundManager.resumeAll()
};
SndManagerIE.prototype.stopAllSounds = function() {
    window.soundManager.stopAll()
};
SndManagerIE.prototype.toggleMute = function() {
    SndManager.prototype.toggleMute.call(this);
    this.m_muted ? window.soundManager.pauseAll() : window.soundManager.resumeAll()
};
SndManagerIE.prototype.stopAllMusics = function() {
    var a = window.soundManager,
        b, c;
    for (b = a.soundIDs.length - 1; 0 <= b; b--) c = a.sounds[a.soundIDs[b]], 1 === c.playState && (c = c.id, 0 === this.sounds[c].loops && window.soundManager.stop(c))
};
SndManagerIE.prototype.isPlayingSound = function(a) {
    return (a = window.soundManager.getSoundById(a)) ? 1 === a.playState : !1
};
SndManagerIE.prototype.resumeSound = function(a) {
    (a = window.soundManager.getSoundById(a)) && a.resume()
};
SndManagerIE.prototype.setVolumeById = function(a, b) {
    var c = window.soundManager.getSoundById(a);
    c && 1 === c.playState && c.setVolume(100 * b)
};

function SndManagerWeb(a, b) {
    SndManager.call(this);
    SndManager.instance = this;
    this.soundjs = window.createjs;
    this.soundList = {};
    this.callback = b;
    var c = window.SwitEntryPoint.infoBrowser.browserVersion;
    window.SwitEntryPoint.infoBrowser.isIE && 10 > c && (Application.warn("Using SndManagerWeb for IE" + c), this.callbackBug = !0);
    window.SwitEntryPoint.infoBrowser.iDevice && 6 > window.SwitEntryPoint.infoBrowser.platformVersion && (Application.warn("IOS < 6"), this.callbackBug = this.soundjs.HTMLAudioPlugin.enableIOS = !0);
    c = Application.ASSETS_PATH +
        "media/sounds/";
    this.soundsLoaded = 0;
    this.soundsTotal = a.length;
    GuiLoader.instance && (GuiLoader.instance.totalFiles = this.soundsTotal);
    this.soundjs.Sound.alternateExtensions = ["mp3"];
    this.soundjs.Sound.addEventListener("fileload", this.soundjs.proxy(this.onFileload, this));
    for (var d = 0; d < a.length; d++) this.soundList[a[d].id] = a[d], this.soundjs.Sound.registerSound({
        id: a[d].id,
        src: c + a[d].file + ".ogg",
        data: a[d].instances
    });
    this.callbackBug && this.callback()
}
Application.subclass(SndManagerWeb, SndManager);
SndManagerWeb.prototype.onFileload = function(a) {
    this.soundsLoaded++;
    Application.info("SndManagerWeb preloading: " + a.id + " " + this.soundsLoaded + "/" + this.soundsTotal);
    this.callbackBug || (GuiLoader.instance && GuiLoader.instance.load(), this.soundsLoaded === this.soundsTotal && this.callback())
};
SndManagerWeb.prototype.onPlayComplete = function(a) {
    this.play(a.target.switId)
};
SndManagerWeb.prototype.play = function(a) {
    if (!this.m_muted)
        if ("undefined" === typeof this.soundList[a]) Application.warn("SndManagerWeb: sound with id [" + a + "] not found");
        else if (!this.soundjs.HTMLAudioPlugin.enableIOS || 0 != this.soundList[a].ios) {
        var b = null;
        this.soundjs.HTMLAudioPlugin.enableIOS ? (b = this.soundjs.Sound.play(a), b.addEventListener("complete", this.soundjs.proxy(this.onPlayComplete, this))) : b = this.soundjs.Sound.play(a, null, 0, 0, 0 === this.soundList[a].loops ? 999999 : this.soundList[a].loops - 1, this.soundList[a].vol);
        "Chrome" === window.SwitEntryPoint.infoBrowser.browserName && (b.pan = 1E-4);
        b.switId = a
    }
};
SndManagerWeb.prototype.stop = function(a) {
    for (var b = this.soundjs.Sound._instances, c = 0; c < b.length; ++c) b[c].switId === a && b[c].stop()
};
SndManagerWeb.prototype.pauseSound = function(a) {
    for (var b = this.soundjs.Sound._instances, c = 0; c < b.length; ++c) b[c].switId === a && (b[c].paused = !0)
};
SndManagerWeb.prototype.resumeSound = function(a) {
    for (var b = this.soundjs.Sound._instances, c = 0; c < b.length; ++c) b[c].switId === a && (b[c].paused = !1)
};
SndManagerWeb.prototype.setMasterVolume = function(a) {
    try {
        this.soundjs.Sound.setVolume(a)
    } catch (b) {
        Application.error("SndManagerWeb: " + b)
    }
};
SndManagerWeb.prototype.pauseAll = function() {
    for (var a = this.soundjs.Sound._instances, b = 0; b < a.length; ++b) a[b].paused = !0
};
SndManagerWeb.prototype.resumeAll = function() {
    if (!this.m_muted)
        for (var a = this.soundjs.Sound._instances, b = 0; b < a.length; ++b) a[b].paused = !1
};
SndManagerWeb.prototype.stopAllSounds = function() {
    this.soundjs.Sound.stop()
};
SndManagerWeb.prototype.removeAllSounds = function() {
    this.soundjs.Sound.removeAllSounds();
    this.soundjs.Sound = null
};
SndManagerWeb.prototype.toggleMute = function() {
    SndManager.prototype.toggleMute.call(this);
    this.m_muted ? this.soundjs.Sound.setMute(!0) : this.soundjs.Sound.setMute(!1)
};
SndManagerWeb.prototype.stopAllMusics = function() {
    for (var a = "", b = this.soundjs.Sound._instances, c = 0; c < b.length; ++c) a = b[c].switId, 0 === this.soundList[a].loops && b[c].stop(a)
};
SndManagerWeb.prototype.isPlayingSound = function(a) {
    for (var b = this.soundjs.Sound._instances, c = 0; c < b.length; ++c)
        if (b[c].switId === a) return b[c].playState === this.soundjs.Sound.PLAY_SUCCEEDED;
    return !1
};
SndManagerWeb.prototype.setVolumeById = function(a, b) {
    for (var c = this.soundjs.Sound._instances, d = 0; d < c.length; ++d) c[d].switId === a && c[d].playState === this.soundjs.Sound.PLAY_SUCCEEDED && c[d].setVolume(b)
};

function Actor(a, b, c) {
    this.m_x = "undefined" !== typeof b ? b : 0;
    this.m_y = "undefined" !== typeof c ? c : 0;
    this.clip = new Animation(a);
    this.setPosition(b, c);
    DebugObject.call(this)
}
Application.subclass(Actor, DebugObject);
Actor.prototype.free = function() {
    this.clip.free();
    this.clip = null
};
Actor.prototype.setX = function(a) {
    this.m_x = this.clip.position.x = a
};
Actor.prototype.setY = function(a) {
    this.m_y = this.clip.position.y = a
};
Actor.prototype.setPosition = function(a, b) {
    this.clip.position.x = a;
    this.clip.position.y = b;
    this.m_x = a;
    this.m_y = b
};
Actor.prototype.getX = function() {
    return this.m_x
};
Actor.prototype.getY = function() {
    return this.m_y
};
Actor.prototype.setScale = function(a) {
    this.clip.scale.x = a;
    this.clip.scale.y = a
};
Actor.prototype.setScaleX = function(a) {
    this.clip.scale.x = a
};
Actor.prototype.setScaleY = function(a) {
    this.clip.scale.y = a
};
Actor.prototype.setRotation = function(a) {
    this.clip.rotation = a
};
Actor.prototype.onEndAnimation = function(a, b) {
    if (null !== this.clip) this.clip.onEndAnimation(a, b)
};
Actor.prototype.onDebugDraw = function(a) {};
Actor.prototype.setClip = function(a) {
    null !== this.clip && this.clip.free();
    this.clip = Application.instance.getClip(a);
    this.clip.position.x = this.m_x;
    this.clip.position.y = this.m_y
};
Actor.prototype.update = function(a) {
    this.clip && (this.clip.position.x = this.m_x, this.clip.position.y = this.m_y, this.clip.update(a))
};

function Character(a, b, c) {
    this.states = [];
    this.currentState = "";
    this.actor = null;
    this.m_x = a;
    this.m_y = b;
    this.functions = [];
    this.canvas = c;
    this.m_lastFrame = this.depth = 0;
    this.worldActor = this.m_endAniFunction = this.m_endAniCaller = null;
    this.depth = 0
}
Character.prototype.onEndAnimation = function(a, b) {
    this.m_endAniCaller = a;
    this.m_endAniFunction = b
};
Character.prototype._endAnimation = function(a) {
    null !== this.m_endAniCaller && null !== this.m_endAniFunction && this.m_endAniFunction.call(this.m_endAniCaller, this.currentState)
};
Character.prototype.setDepth = function(a) {
    null !== this.actor && (this.actor.clip.depth = a);
    this.depth = a
};
Character.prototype.getState = function() {
    return this.currentState
};
Character.prototype.getX = function() {
    return this.m_x
};
Character.prototype.getY = function() {
    return this.m_y
};
Character.prototype.setX = function(a) {
    this.m_x = a;
    null !== this.actor && this.actor.setX(this.m_x)
};
Character.prototype.setY = function(a) {
    this.m_y = a;
    null !== this.actor && this.actor.setY(this.m_y)
};
Character.prototype.setPosition = function(a, b) {
    this.m_x = a;
    this.m_y = b;
    null !== this.actor && this.actor.setPosition(this.m_x, this.m_y)
};
Character.prototype.addState = function(a, b, c) {
    this.states[a] = b;
    c = "undefined" !== typeof c ? c : [];
    for (b = 0; b < c.length; b++) this.functions[a + "_" + c[b].frame] = c[b]
};
Character.prototype.gotoState = function(a, b) {
    b = "undefined" !== typeof b ? b : !0;
    this.states[a] ? (this.currentState = a, null !== this.actor && (this.canvas.removeChild(this.actor.clip), this.actor.free(), this.actor = null), this.actor = new Actor(this.states[a], this.m_x, this.m_y), this.actor.onEndAnimation(this, this._endAnimation), this.actor.clip.loop = b, this.canvas.addChild(this.actor.clip)) : Application.error("Character::gotoState() - State: [" + a + "] is not registered")
};
Character.prototype.update = function(a) {
    null !== this.actor && (this.actor.update(a), this.m_lastFrame !== this.actor.clip.currentFrame && (this.m_lastFrame = this.actor.clip.currentFrame, this.actor.setPosition(this.m_x, this.m_y), this.functions[this.currentState + "_" + this.actor.clip.currentFrame] && (a = this.functions[this.currentState + "_" + this.actor.clip.currentFrame], a.callback.call(a.caller))))
};
Character.prototype.onDebugDraw = function(a) {
    if (null !== this.actor) this.actor.onDebugDraw(a)
};
Character.prototype.compareStates = function(a, b) {
    return this.states[a] !== b
};
Character.prototype.free = function() {
    null !== this.actor && (this.canvas.removeChild(this.actor.clip), this.actor.free(), this.actor = null);
    this.worldActor = this.states = this.functions = this.canvas = null
};

function Layout() {}
Layout.ALIGN_TOP_LEFT = 0;
Layout.ALIGN_TOP_CENTER = 1;
Layout.ALIGN_CENTER = 2;
Layout.scale = 1;
Layout.dpi = 1;
Layout.align = Layout.ALIGN_CENTER;
Layout.resizeEnable = !0;
Layout.offsetX = 0;
Layout.offsetY = 0;
Layout.top = 0;
Layout.left = 0;
Layout.width = 0;
Layout.height = 0;
Layout.minAspectRatio = 1024 / 768;
Layout.maxAspectRatio = 16 / 9;
Layout.aspectRatio = Layout.minAspectRatio;
Layout.supports3dTransform = window.WebKitCSSMatrix || window.MSCSSMatrix;
Layout.onResize = function(a, b) {
    Layout.width = Math.floor(a);
    Layout.height = Math.floor(b);
    navigator.isCocoonJS && (Application.WIDE_SCREEN = !0);
    Layout.scale = 1;
    Layout.top = 0;
    Layout.left = 0;
    Layout.offsetX = 0;
    Layout.offsetY = 0;
    var c = a / Application.APP_WIDTH,
        d = b / Application.APP_HEIGHT;
    d < c ? (Layout.scale = d, Layout.left = Math.floor((a - Application.APP_WIDTH * Layout.scale) / 2)) : d > c && (Layout.scale = c, Layout.top = Math.floor((b - Application.APP_HEIGHT * Layout.scale) / 2));
    Layout.aspectRatio = Math.min(Layout.maxAspectRatio, Math.max(Layout.minAspectRatio,
        Layout.width / Layout.height));
    Application.WIDE_SCREEN ? (d < c ? (Layout.offsetX = Layout.left, Application.instance.renderer.resize(Math.ceil(a / Layout.scale), Application.APP_HEIGHT), Application.instance.canvas.position.x = Layout.offsetX / Layout.scale, Application.instance.canvas.position.y = 0, Application.instance.videoRenderer.resize(Math.ceil(a / Layout.scale), Application.APP_HEIGHT), Application.instance.videoCanvas.position.x = Layout.offsetX / Layout.scale, Application.instance.videoCanvas.position.y = 0) : (Layout.offsetY =
            Layout.top, Application.instance.renderer.resize(Application.APP_WIDTH, Math.ceil(b / Layout.scale)), Application.instance.canvas.position.x = 0, Application.instance.canvas.position.y = Layout.offsetY / Layout.scale, Application.instance.videoRenderer.resize(Application.APP_WIDTH, Math.ceil(b / Layout.scale)), Application.instance.videoCanvas.position.x = 0, Application.instance.videoCanvas.position.y = Layout.offsetY / Layout.scale), Application.log("posX: " + Application.instance.canvas.position.x), Application.log("posY: " +
            Application.instance.canvas.position.y), Application.instance.renderer.view.style.top = "0px", Application.instance.renderer.view.style.left = "0px", Application.instance.renderer.view.style["transform-origin"] = "0px 0px", Application.instance.renderer.view.style.transform = "scale(" + Layout.scale + ", " + Layout.scale + ")", Application.instance.videoRenderer.view.style.top = "0px", Application.instance.videoRenderer.view.style.left = "0px", Application.instance.videoRenderer.view.style["transform-origin"] = "0px 0px", Application.instance.videoRenderer.view.style.transform =
        "scale(" + Layout.scale + ", " + Layout.scale + ")") : (Application.instance.canvas.scale.x = Layout.scale, Application.instance.canvas.scale.y = Layout.scale, Application.instance.canvas.position.x = Layout.left, Application.instance.canvas.position.y = Layout.top, Application.log("Layout.left: " + Layout.left), Application.log("Layout.top: " + Layout.top), 0 !== Layout.left ? Application.instance.renderer.resize(a - Layout.left, Layout.scale * Application.APP_HEIGHT) : Application.instance.renderer.resize(Layout.scale * Application.APP_WIDTH,
        b - Layout.top))
};
Layout.fixInteractionEvent = function(a) {
    if (Application.WIDE_SCREEN) {
        var b = {
            data: {}
        };
        b.data.identifier = "undefined" !== typeof a.data.identifier ? a.data.identifier : 0;
        b.data.originalEvent = a.data.originalEvent;
        b.data.target = a.data.target;
        b.data.global = {};
        b.data.global.x = Math.floor(a.data.global.x - Application.instance.canvas.position.x);
        b.data.global.y = Math.floor(a.data.global.y - Application.instance.canvas.position.y);
        b.target = a.target;
        return b
    }
    return a
};
Layout.position = function(a, b, c) {
    if (a = document.getElementById(a)) a.style.top = b + "px", a.style.left = c + "px"
};
Layout.transform = function(a) {
    if (a = document.getElementById(a)) a.style.transformOrigin = "0 0", a.style.transform = "scale(" + Layout.scale + ", " + Layout.scale + ")", a.style.webkitTransformOrigin = "0 0", a.style.webkitTransform = "scale(" + Layout.scale + ", " + Layout.scale + ")", a.style.OTransformOrigin = "0 0", a.style.OTransform = "scale(" + Layout.scale + ", " + Layout.scale + ")", window.SwitEntryPoint.infoBrowser.isIE && (a.style.msTransformOrigin = window.config.settings.RIGHT_TO_LEFT ? "100% 0%" : "0 0", a.style.msTransform = "scale(" + Layout.scale +
        ", " + Layout.scale + ")")
};

function Point(a, b) {
    this.x = "undefined" === typeof a ? 0 : a;
    this.y = "undefined" === typeof b ? 0 : b
}
Point.prototype.distanceTo = function(a, b) {
    return Math.sqrt((a - this.x) * (a - this.x) + (b - this.y) * (b - this.y))
};

function Rectangle(a, b, c, d) {
    this.x = "undefined" !== typeof a ? a : 0;
    this.y = "undefined" !== typeof b ? b : 0;
    this.w = "undefined" !== typeof c ? c : 0;
    this.h = "undefined" !== typeof d ? d : 0
}
Rectangle.prototype.left = function() {
    return this.x
};
Rectangle.prototype.setLeft = function(a) {
    this.x = a
};
Rectangle.prototype.right = function() {
    return this.x + this.w
};
Rectangle.prototype.setRight = function(a) {
    a < this.x || (this.w = a - this.x)
};
Rectangle.prototype.top = function() {
    return this.y
};
Rectangle.prototype.setTop = function(a) {
    this.y = a
};
Rectangle.prototype.bottom = function() {
    return this.y + this.h
};
Rectangle.prototype.setBottom = function(a) {
    a < this.y || (this.h = a - this.y)
};
Rectangle.prototype.isEqual = function(a) {
    return this.x === a.x && this.y === a.y && this.w === a.w && this.h === a.h
};
Rectangle.prototype.intersectPoint = function(a, b) {
    return a >= this.x && a <= this.x + this.w && b >= this.y && b <= this.y + this.h
};
Rectangle.prototype.contains = function(a, b) {
    return a >= this.x && a <= this.x + this.w && b >= this.y && b <= this.y + this.h
};
Rectangle.prototype.intersectRect = function(a) {
    return this.right() >= a.x && this.x <= a.right() && this.bottom() >= a.y && this.y <= a.bottom()
};
Rectangle.prototype.intersection = function(a) {
    if (!this.intersectRect(a)) return null;
    var b = new Rectangle;
    b.x = this.x > a.x ? this.x : a.x;
    b.y = this.y > a.y ? this.y : a.y;
    b.setRight(this.right() < a.right() ? this.right() : a.right());
    b.setBottom(this.bottom() < a.bottom() ? this.bottom() : a.bottom());
    return b
};
Rectangle.prototype.containsRect = function(a) {
    return a.x >= this.x && a.y >= this.y && a.right() <= this.right() && a.bottom() <= this.bottom()
};
Rectangle.prototype.clone = function() {
    return new Rectangle(this.x, this.y, this.w, this.h)
};
Rectangle.prototype.copyRectangle = function(a) {
    this.x = a.x;
    this.y = a.y;
    this.w = a.w;
    this.h = a.h
};
Rectangle.prototype.isEmpty = function() {
    return 0 === this.w && 0 === this.h
};
Rectangle.prototype.setEmpty = function() {
    this.h = this.w = 0
};
Rectangle.prototype.toString = function() {
    return "x:" + this.x + " y:" + this.y + " w:" + this.w + " h:" + this.h
};

function SScreen(a, b, c, d) {
    this.screenParent = "undefined" === typeof d ? null : d;
    this.name = "";
    this.onPress = this.activeRelease = !1;
    this.m_titleImage = null;
    this.canvas = Application.instance.addDisplayContainer();
    Application.instance.canvas.addChild(this.canvas);
    this.canvas.hitArea = new Rectangle(.5 * -Application.APP_WIDTH, -100, 2 * Application.APP_WIDTH, Application.APP_HEIGHT + 200);
    this.canvas.addPressListener(this, this.onPointerPress);
    this.canvas.addReleaseListener(this, this.onPointerRelease);
    this.canvas.addPointerMoveListener(this,
        this.onPointerMove);
    this.blurBG = null;
    this.blurContent = Application.instance.addDisplayContainer();
    this.canvas.addChild(this.blurContent);
    this.frameWaitActionStop = 0;
    "" !== a && "undefined" !== typeof a && (this.clip = Application.instance.getClip(a), this.clip.screenLinked = this, this.frameWaitActionStop = this.clip.screenActionStop, this.canvas.addChild(this.clip));
    this.skipCode = 32;
    this.canvas.position.x = "undefined" === typeof b ? 0 : b;
    this.canvas.position.y = "undefined" === typeof c ? 0 : c;
    this.popup = null;
    this.controls = {};
    this.spaceBarEnabled = !1;
    this.lastInteractionControl = "";
    SScreen.parseControls(this, a);
    this.m_transitionFx = null;
    this.state = 0;
    this.init();
    for (var e in this.controls) "undefined" !== typeof this.controls[e].addOverListener && this.controls[e].addOverListener(this, this.onOverIn, this, this.onOverOut)
}
SScreen.prototype.onOverIn = function(a) {
    for (var b in this.controls) this.controls[b] !== a ? this.controls[b].state === GuiControl.ST_OVER && this.controls[b].gotoState(GuiControl.ST_OUT) : this.controls[b].state !== GuiControl.ST_OVER && this.controls[b].gotoState(GuiControl.ST_OVER)
};
SScreen.prototype.onOverOut = function(a) {
    for (var b in this.controls) this.controls[b].state === GuiControl.ST_OVER && this.controls[b].gotoState(GuiControl.ST_OUT)
};
SScreen.prototype.applyBlur = function(a) {
    if (!Application.instance.isMobileDevice) {
        var b = new Image;
        b.src = Application.instance.captureScreen();
        a = "undefined" !== typeof a ? a : 2;
        this.blurBG = new SSprite(b.src);
        this.blurBG.position.x = -Layout.left / Layout.scale;
        this.blurContent.addChild(this.blurBG);
        b = new window.PIXI.filters.BlurFilter;
        b.blur = a;
        this.blurBG.filters = [b]
    }
};
SScreen.prototype.createTransitionIn = function() {};
SScreen.prototype.createTransitionOut = function() {};
SScreen.prototype.onEndTransitionIn = function() {};
SScreen.prototype.onEndTransitionOut = function() {};
SScreen.prototype.onActionScreen = function() {};
SScreen.prototype.onActionBack = function() {};
SScreen.prototype.createTransition = function(a, b, c, d, e) {
    d = "undefined" !== typeof d ? d : null;
    null !== this.m_transitionFx && this.m_transitionFx.free();
    this.m_transitionFx = new SEffectAnimo(a, b, c, "undefined" !== typeof e ? e : this.clip, 1);
    this.m_transitionFx.onComplete(this, this.onEndTransition);
    this.m_transitionFx.params = d
};
SScreen.prototype.createCustomTransition = function(a, b, c) {
    b = "undefined" !== typeof b ? b : null;
    null !== this.m_transitionFx && this.m_transitionFx.free();
    this.m_transitionFx = new a(b, "undefined" !== typeof c ? c : this.clip);
    this.m_transitionFx.onEndAnimation(this, this.onEndTransition);
    if (Application.instance.isMobileDevice) this.m_transitionFx.onComplete()
};
SScreen.prototype.checkStateSound = function(a) {
    Application.instance.isSoundOn() ? (this.getControl(a + "On").canvas.visible = !0, this.getControl(a + "Off").canvas.visible = !1) : (this.getControl(a + "On").canvas.visible = !1, this.getControl(a + "Off").canvas.visible = !0)
};
SScreen.prototype.localizedTitle = function(a, b, c, d, e, f, g) {
    e = "undefined" === typeof e ? 0 : e;
    f = "undefined" === typeof f ? 0 : f;
    g = "undefined" === typeof g ? !1 : g;
    this.m_titleImage = Application.instance.getLocalizedImage(a + ".png");
    b.addChild(this.m_titleImage);
    this.m_titleImage.pivot.x = c;
    this.m_titleImage.pivot.y = d;
    this.m_titleImage.position.x = e;
    this.m_titleImage.position.y = f;
    g && Common.tween({
        parent: this,
        clip: this.m_titleImage,
        scale: 0
    }, {
        scale: 1
    }, 750, !0, 200, TweenEasing.BounceOut)
};
SScreen.prototype.getControl = function(a) {
    "undefined" === typeof this.controls[a] && Application.error("Control [" + a + "] no found");
    return this.controls[a]
};
SScreen.prototype.init = function() {};
SScreen.prototype.onDebugDraw = function(a) {};
SScreen.prototype.onEndTransition = function(a) {
    a.isAwaitingDelete = !0
};
SScreen.prototype.onUIPress = function(a) {
    if (null !== this.popup) this.popup.onUIPress(a);
    else this.lastInteractionControl = a.name
};
SScreen.prototype.onUIRelease = function(a) {
    if (null !== this.popup) this.popup.onUIRelease(a);
    else this.activeRelease = this.lastInteractionControl === a.name
};
SScreen.prototype.onUIPressAndRelease = function(a) {
    if (null !== this.popup) this.popup.onUIPressAndRelease(a)
};
SScreen.prototype.onUIMove = function(a) {
    if (null !== this.popup) this.popup.onUIMove(a)
};
SScreen.prototype.onUIOver = function(a) {
    if (null !== this.popup) this.popup.onUIOver(a)
};
SScreen.prototype.onUIOut = function(a) {
    if (null !== this.popup) this.popup.onUIOut(a)
};
SScreen.prototype.onStopScreen = function() {
    this.clip && this.clip.stop()
};
SScreen.prototype.onResumeScreen = function() {
    this.clip && this.clip.resume()
};
SScreen.prototype.onFinishScreen = function() {};
SScreen.prototype.onPointerPress = function(a) {};
SScreen.prototype.onPointerRelease = function(a) {};
SScreen.prototype.onPointerPressAndRelease = function(a) {};
SScreen.prototype.onPointerOver = function(a) {};
SScreen.prototype.onPointerMove = function(a) {};
SScreen.prototype.setX = function(a) {};
SScreen.prototype.setY = function(a) {};
SScreen.prototype.activePressBar = function() {
    this.spaceBarEnabled = !0
};
SScreen.prototype.onPressSpaceBar = function() {
    this.spaceBarEnabled = !1
};
SScreen.prototype.update = function(a) {
    null !== this.popup && this.popup.update(a);
    this.clip && this.clip.update(a);
    this.m_transitionFx && (this.m_transitionFx.isAwaitingDelete ? (this.m_transitionFx.free(), this.m_transitionFx = null) : this.m_transitionFx.update(a))
};
SScreen.prototype.onResize = function(a) {
    if (null !== this.popup) this.popup.onResize(a)
};
SScreen.prototype.onKeyDown = function(a) {
    if (null !== this.popup) this.popup.onKeyDown(a);
    if (this.spaceBarEnabled && a === this.skipCode) this.onPressSpaceBar()
};
SScreen.prototype.onKeyUp = function(a) {
    if (null !== this.popup) this.popup.onKeyUp(a)
};
SScreen.prototype.onActivate = function(a) {
    if (null !== this.popup) this.popup.onActivate(a)
};
SScreen.prototype.addPopup = function(a, b, c, d) {
    c = "undefined" === typeof c ? 0 : c;
    d = "undefined" === typeof d ? 0 : d;
    this.dropPopup();
    return this.popup = new a(b, c, d, this)
};
SScreen.prototype.dropPopup = function() {
    null !== this.popup && (this.popup.free(), this.popup = null)
};
SScreen.prototype.destroyToolTips = function() {};
SScreen.prototype.createTooltips = function(a, b, c, d, e) {};
SScreen.prototype.free = function() {
    this.blurBG && (this.blurContent.removeChild(this.blurBG), this.blurBG = null);
    var a = document.getElementById("MainCanvasDraw");
    a && (a.focus(), a.parentElement.focus());
    this.dropPopup();
    this.destroyToolTips();
    this.screenParent = null;
    for (var b in this.controls) this.controls[b].free(), this.controls[b] = null;
    this.controls = null;
    this.canvas && (Application.instance.canvas.hitArea = null, Application.instance.canvas.removeChild(this.canvas), this.canvas = null);
    document.getElementById("MainCanvasEvents") &&
        (document.getElementById("MainCanvasEvents").style.cursor = "default")
};
SScreen.parseControls = function(a, b) {
    var c = window.config.ui,
        d = Application.RIGHT_TO_LEFT ? "_rtl" : "_ltr",
        e = null,
        f = "",
        g;
    for (g in c)
        if (c[g].gui === b) {
            var h = a.clip.getInstance(c[g].control);
            if (h) {
                f = c[g]["font" + d];
                switch (Common.trim(c[g].type).toUpperCase()) {
                    case GuiControl.TYPE_TEXT:
                        e = new GuiText(h);
                        e.setClip(c[g].link);
                        e.setStyle({
                            size: parseInt(c[g]["size" + d], 0),
                            font: c[g]["size" + d] + "px " + f,
                            fill: c[g].color,
                            strokeThickness: parseInt(c[g].border, 10),
                            stroke: c[g].borderColor,
                            align: c[g]["align" + d] ? parseInt(Common.trim(c[g]["align" +
                                d
                            ]), 10) : GuiText.ALIGN_CENTER,
                            valign: c[g].valign ? parseInt(Common.trim(c[g].valign), 10) : GuiText.ALIGN_V_TOP,
                            wordWrap: c[g].wordWrap ? 1 === parseInt(Common.trim(c[g].wordWrap), 10) : !1,
                            wordWrapWidth: e.baseWidth
                        });
                        "undefined" !== typeof Application.strings[c[g].string] ? e.setTextLocalized(c[g].string) : Application.warn("SScreen: string/style id [" + c[g].string + "] no found");
                        break;
                    case GuiControl.TYPE_CLIP:
                        e = new GuiClip(h);
                        e.setClip(c[g].link);
                        break;
                    case GuiControl.TYPE_ON_OFF:
                        e = new GuiOnOff(h);
                        e.setOnClip(c[g].onLink);
                        e.setOffClip(c[g].offLink);
                        e.gotoState(GuiOnOff.ST_ON);
                        e.addPressListener(a, a.onUIPress);
                        e.addReleaseListener(a, a.onUIRelease);
                        break;
                    case GuiControl.TYPE_BUTTON:
                        e = new GuiButton(h);
                        e.setClip(c[g].link);
                        e.screenContainer = this;
                        e.addPressListener(a, a.onUIPress);
                        e.addReleaseListener(a, a.onUIRelease);
                        break;
                    case GuiControl.TYPE_ANI_BUTTON:
                        e = new GuiButtonState(h, c[g].link);
                        e.screenContainer = this;
                        e.addPressListener(a, a.onUIPress);
                        e.addReleaseListener(a, a.onUIRelease);
                        break;
                    case GuiControl.TYPE_4STATES:
                        e = new GuiThumbs4State(h,
                            c[g].link, c[g].disableLink, c[g].selectedLink, c[g].soonLink);
                        e.addPressListener(a, a.onUIPress);
                        e.addReleaseListener(a, a.onUIRelease);
                        break;
                    case GuiControl.TYPE_CLIP_MOUSE:
                        e = new GuiControlInteractive(h);
                        e.setClip(c[g].link);
                        e.addPressListener(a, a.onUIPress);
                        e.addReleaseListener(a, a.onUIRelease);
                        e.addMoveListener(a, a.onUIMove);
                        break;
                    case GuiControl.TYPE_CONTENT:
                        e = new GuiContent(h)
                }
                e.name = Common.trim(c[g].control);
                a.controls[c[g].control] = e
            }
        }
};

function SLoaderScreen(a, b, c, d, e, f, g) {
    SScreen.call(this, a);
    this.start = "undefined" === typeof d ? 0 : d;
    this.end = "undefined" === typeof e ? 100 : e;
    this.jsonFiles = b;
    this.loadedfiles = this.totalFiles = 0;
    this.gotoScreen = c;
    this.ready = !1;
    this.waitTime = 600;
    this.preload = "undefined" === typeof f ? !1 : f;
    this.extraAssets = g;
    this.btnNext = this.parseText = null;
    this.controls.mcGuiBtnNext && (this.btnNext = this.getControl("mcGuiBtnNext"), this.btnNext.clip.visible = !1);
    this.loadedJsonFiles = 0;
    if (this.jsonFiles)
        for (a = 0, b = null, Application.filesQuality(this.jsonFiles),
            a = 0; a < this.jsonFiles.length; a++)
            if (Application.jsonFiles[this.jsonFiles[a]]) this.onJsonLoaded(Application.jsonFiles[this.jsonFiles[a]]);
            else b = new SJsonLoader(this.jsonFiles[a]), b.addLoadedListener(this, this.onJsonLoaded), b.addErrorListener(this, this.onJsonError), b.load();
    this.preload && (this.waitTime = 0)
}
Application.subclass(SLoaderScreen, SScreen);
SLoaderScreen.prototype.free = function() {
    this.gotoScreen = this.jsonFiles = this.btnNext = this.txtLoading = null;
    SScreen.prototype.free.call(this)
};
SLoaderScreen.prototype.onJsonLoaded = function(a) {
    Application.log("[JSON loaded]" + a.url);
    this.loadedJsonFiles++;
    Application.jsonFiles[a.url] = a;
    if (this.loadedJsonFiles >= this.jsonFiles.length) this.onAllJsonLoaded()
};
SLoaderScreen.prototype.onJsonError = function(a) {
    Application.error("JSON no found " + a.url)
};
SLoaderScreen.prototype.onAllJsonLoaded = function() {
    Application.info("[ALL JSON COMPLETE]");
    var a = [],
        b;
    for (b = 0; b < this.jsonFiles.length; b++) {
        this.totalFiles += Application.jsonFiles[this.jsonFiles[b]].json.meta.atlas.length;
        var c = new SLoader(Application.jsonFiles[this.jsonFiles[b]]);
        c.addLoadListener(this, this.load);
        a.push(c)
    }
    this.extraAssets && (this.totalFiles += this.extraAssets.length, c = new SLoader({
        json: {
            meta: {
                atlas: this.extraAssets
            }
        },
        baseUrl: ""
    }), c.addLoadListener(this, this.load), a.push(c));
    for (b = 0; b <
        a.length; b++) a[b].load()
};
SLoaderScreen.prototype.onUIPress = function(a) {
    Application.instance.playSound("SND_UI_CLICK");
    switch (a.name) {
        case "mcGuiBtnNext":
            GuiManager.instance.gotoScreen(this.gotoScreen)
    }
};
SLoaderScreen.prototype.load = function() {
    this.loadedfiles++;
    this.loadedfiles === this.totalFiles && (this.ready = !0)
};
SLoaderScreen.prototype.update = function(a) {
    this.ready && (this.waitTime -= a, 0 > this.waitTime && (this.onLoadComplete(), this.ready = !1))
};
SLoaderScreen.prototype.onLoadComplete = function() {
    if (this.preload) Application.instance.onLoaderReady();
    else Application.instance.isMobileDevice && null != this.jsonFiles ? GuiMainMenu.doneFirstLoader ? GuiManager.instance.gotoScreen(this.gotoScreen) : this.btnNext && (this.btnNext.clip.visible = !0) : GuiManager.instance.gotoScreen(this.gotoScreen)
};

function DebugScreen(a, b, c, d) {
    SScreen.call(this, a, b, c, d)
}
Application.subclass(DebugScreen, SScreen);
DebugScreen.prototype.onUIPress = function(a) {
    Application.instance.playSound("SND_UI_CLICK");
    this.onResumeScreen()
};

function DebugScreenNano() {
    SScreen.call(this, "", 0, 0);
    DebugScreenNano.instance = this;
    this.fx = null;
    this.effectName = "";
    this.followCursor = !1;
    this.bgImage = null;
    this.canvasBg = Application.instance.addDisplayContainer();
    this.canvasEffect = Application.instance.addDisplayContainer();
    this.canvasGuides = Application.instance.addDisplayContainer();
    this.canvas.addChild(this.canvasBg);
    this.canvas.addChild(this.canvasEffect);
    this.canvas.addChild(this.canvasGuides);
    this.max = 0;
    this.centerX = .5 * Application.APP_WIDTH;
    this.centerY =
        .5 * Application.APP_HEIGHT;
    var a = new SGraphics;
    a.drawLine(this.centerX - 100, this.centerY, this.centerX + 100, this.centerY, 65280);
    a.drawLine(this.centerX, this.centerY - 100, this.centerX, this.centerY + 100, 65280);
    a.drawRectangle(10, 10, Application.APP_WIDTH - 20, Application.APP_HEIGHT - 20, 1, 65280);
    this.canvasGuides.addChild(a);
    this.m_debugText = new SPixiText("", {
        size: 15,
        font: "15px Arial",
        fill: "#00FF00"
    });
    this.m_debugText.position.x = 14;
    this.m_debugText.position.y = 12;
    this.canvas.addChild(this.m_debugText)
}
Application.subclass(DebugScreenNano, SScreen);
DebugScreenNano.prototype.onKeyDown = function(a) {
    switch (a) {
        case Common.KEY_F:
            this.followCursor = !this.followCursor, this.followCursor || (this.fx.x = this.centerX, this.fx.y = this.centerY)
    }
};
DebugScreenNano.prototype.onPointerPress = function(a) {
    "" !== this.effectName && this.createEffect(this.effectName, a.data.global.x, a.data.global.y)
};
DebugScreenNano.prototype.onPointerMove = function(a) {
    this.fx && this.followCursor && (this.fx.x = a.data.global.x, this.fx.y = a.data.global.y)
};
DebugScreenNano.prototype.setBackground = function(a) {
    this.bgImage && (this.canvasBg.removeChild(this.bgImage), this.bgImage = null);
    this.bgImage = window.PIXI.Sprite.fromImage(a, !1, PIXI.SCALE_MODES.DEFAULT);
    this.canvasBg.addChild(this.bgImage)
};
DebugScreenNano.prototype.createEffect = function(a, b, c) {
    this.fx && (this.fx.free(), this.fx = null);
    this.max = 0;
    this.effectName = a;
    this.fx = new NanoEffect(a, b || this.centerX, c || this.centerY, this.canvasEffect)
};
DebugScreenNano.prototype.update = function(a) {
    SScreen.prototype.update.call(this, a);
    if (this.fx) {
        this.fx.update(a);
        a = window.nano.effects[this.effectName];
        for (var b = 0; b < a.length; b++) this.fx.emittersIndex[a[b].emitter] && (this.fx.emittersIndex[a[b].emitter].ox = a[b].pos_x, this.fx.emittersIndex[a[b].emitter].oy = a[b].pos_y)
    }
    this.max < this.canvasEffect.countChildren() && (this.max = this.canvasEffect.countChildren());
    this.m_debugText.setText("Particles : " + this.canvasEffect.countChildren() + " fps : " + Application.instance.fps +
        (Application.RENDER_MODE === Application.RENDER_CANVAS ? " (canvas)" : " (webgl)") + " Max : " + this.max)
};
DebugScreenNano.prototype.addDebugText = function(a, b, c, d) {
    "undefined" === typeof d && (d = "#FF0000");
    "undefined" === typeof c && (c = 18);
    this.m_debugText = new SPixiText("", {
        size: c,
        font: c + "px Arial",
        fill: d
    });
    this.canvas.addChild(this.m_debugText);
    this.m_debugText.position.x = a;
    this.m_debugText.position.y = b
};
DebugScreenNano.prototype.setDebugText = function(a) {
    this.m_debugText && this.m_debugText.setText(a)
};

function ScreenManager() {
    this.currentScreen = null;
    this.currentScreenName = ""
}
ScreenManager.prototype.free = function() {
    this.currentScreen && this.currentScreen.free();
    this.currentScreen = null
};
ScreenManager.prototype.gotoScreen = function(a) {
    this.currentScreen && this.currentScreen.free();
    this.currentScreen = null;
    this.currentScreenName = a;
    Application.log("GO TO SCREEN :: " + a)
};
ScreenManager.prototype.update = function(a) {
    a > Application.MAX_DELTA_TIME && (a = Application.MAX_DELTA_TIME);
    this.currentScreen && this.currentScreen.update(a)
};
ScreenManager.prototype.onResize = function(a) {
    if (this.currentScreen) this.currentScreen.onResize(a)
};
ScreenManager.prototype.onKeyDown = function(a) {
    if (this.currentScreen) this.currentScreen.onKeyDown(a)
};
ScreenManager.prototype.onKeyUp = function(a) {
    if (this.currentScreen) this.currentScreen.onKeyUp(a)
};
ScreenManager.prototype.onActivate = function(a) {
    if (this.currentScreen) this.currentScreen.onActivate(a)
};
ScreenManager.prototype.onTilt = function(a) {};
ScreenManager.prototype.onDebugDraw = function(a) {
    if (null !== this.currentScreen) this.currentScreen.onDebugDraw(a)
};

function RotateScreen(a) {
    this.canvas = a;
    this.file = window.SwitEntryPoint.infoBrowser.isPhone ? "media/images/ui_images/gui_rotatescreen_phone.jpg" : "media/images/ui_images/gui_rotatescreen.jpg";
    this.bg = new PIXI.Graphics;
    this.bg.beginFill(0, 1);
    this.bg.drawRect(0, 0, 100, 100);
    this.image = PIXI.Sprite.fromImage(this.file, !1, PIXI.SCALE_MODES.DEFAULT);
    this.image.pivot.x = 150;
    this.image.pivot.y = 150;
    this.canvas.interactive = !0;
    this.animate = this.visible = !1
}
RotateScreen.prototype.show = function() {
    this.canvas.addChild(this.bg);
    this.canvas.addChild(this.image);
    Common.tween({
        parent: this,
        clip: this.image,
        scale: .2,
        onComplete: this.onCompleteAnimation
    }, {
        scale: 1
    }, 1500, !0, 150, TweenEasing.ElasticOut);
    this.animate = this.visible = !0
};
RotateScreen.prototype.onCompleteAnimation = function(a) {
    this.animate = !0
};
RotateScreen.prototype.hide = function() {
    this.canvas.removeChild(this.bg);
    this.canvas.removeChild(this.image);
    this.visible = !1
};
RotateScreen.prototype.onResize = function() {
    Application.WIDE_SCREEN ? (this.image.position.x = .5 * window.innerWidth / Layout.scale, this.image.position.y = .5 * window.innerHeight / Layout.scale, this.bg.width = window.innerWidth, this.bg.height = window.innerHeight, this.bg.scale.x /= Layout.scale, this.bg.scale.y /= Layout.scale) : (this.image.position.x = .5 * Application.APP_WIDTH, this.image.position.y = .5 * Application.APP_HEIGHT, this.bg.width = Application.APP_WIDTH, this.bg.height = Application.APP_HEIGHT)
};

function Vector2D(a, b) {
    this.x = "undefined" === typeof a ? 0 : a;
    this.y = "undefined" === typeof b ? 0 : b
}
Vector2D.prototype.set = function(a, b) {
    this.x = a;
    this.y = b
};
Vector2D.prototype.setVector = function(a, b) {
    this.x = a * Math.cos(b);
    this.y = a * Math.sin(b)
};
Vector2D.prototype.distanceTo = function(a, b) {
    return Math.sqrt((a - this.x) * (a - this.x) + (b - this.y) * (b - this.y))
};
Vector2D.prototype.distance = function(a) {
    return Math.sqrt((a.x - this.x) * (a.x - this.x) + (a.y - this.y) * (a.y - this.y))
};
Vector2D.prototype.clone = function() {
    return new Vector2D(this.x, this.y)
};
Vector2D.prototype.plus = function(a) {
    return new Vector2D(this.x + a.x, this.y + a.y)
};
Vector2D.prototype.minus = function(a) {
    return new Vector2D(this.x - a.x, this.y - a.y)
};
Vector2D.prototype.middle = function(a) {
    return new Vector2D(.5 * (this.x + a.x), .5 * (this.y + a.y))
};
Vector2D.prototype.orthogonal = function() {
    return new Vector2D(-this.y, this.x)
};
Vector2D.prototype.rotate = function(a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    var c = this.x * b - this.y * a;
    this.y = this.y * b + this.x * a;
    this.x = c
};
Vector2D.prototype.udir = function() {
    var a = this.clone();
    a.normalize();
    return a
};
Vector2D.prototype.projectionOn = function(a) {
    var b = a.dot(a);
    if (0 === b) return this.clone();
    var c = a.clone();
    c.scale(this.dot(a) / b);
    return c
};
Vector2D.prototype.dot = function(a) {
    return this.x * a.x + this.y * a.y
};
Vector2D.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y)
};
Vector2D.prototype.squaredLength = function() {
    return this.x * this.x + this.y * this.y
};
Vector2D.prototype.copy = function(a) {
    this.x = a.x;
    this.y = a.y
};
Vector2D.prototype.scale = function(a) {
    this.x *= a;
    this.y *= a
};
Vector2D.prototype.normalize = function() {
    var a = this.length();
    0 < a ? (this.x /= a, this.y /= a) : Application.warn("[WARN]: Vector2D.normalize: called on a zero-length vector.")
};
Vector2D.prototype.stretch = function(a) {
    var b = this.length();
    0 < b ? (this.x *= a / b, this.y *= a / b) : Application.warn("[WARN]: Vector2D.stretch: called on a zero-length vector.")
};
Vector2D.prototype.silentNormalize = function() {
    var a = this.length();
    0 < a && (this.x /= a, this.y /= a)
};
Vector2D.prototype.add = function(a) {
    this.x += a.x;
    this.y += a.y
};
Vector2D.prototype.subtract = function(a) {
    this.x -= a.x;
    this.y -= a.y
};
Vector2D.prototype.product = function(a) {
    return this.y * a.x - this.x * a.y
};
Vector2D.prototype.angle = function() {
    return Math.atan2(this.y, this.x)
};
Vector2D.prototype.isZero = function() {
    return 0 === this.y && 0 === this.x
};
Vector2D.prototype.toString = function() {
    return "V2D x:" + this.x + " y:" + this.y
};

function SGame(a) {
    SGame.instance = this;
    this.canvas = a;
    this.world = this.hud = null;
    this.score = this.lives = 0;
    this.showDebugCollision = this.isAwaitingDelete = this.isAwaitReset = !1;
    this.init()
}
SGame.instance = null;
SGame.prototype.free = function() {
    this.hud && this.hud.free();
    this.hud = null
};
SGame.prototype.init = function() {};
SGame.prototype.update = function(a) {
    this.hud && this.hud.update(a)
};
SGame.prototype.onDebugDraw = function(a) {};
SGame.prototype.toggleDebugCollision = function() {
    this.showDebugCollision = !this.showDebugCollision
};
SGame.prototype.onActivate = function(a) {};
SGame.prototype.onKeyDown = function(a) {};
SGame.prototype.onKeyUp = function(a) {};
SGame.prototype.onPointerPress = function(a) {};
SGame.prototype.onPointerRelease = function(a) {};
SGame.prototype.onPointerPressAndRelease = function(a) {};
SGame.prototype.onPointerOver = function(a) {};
SGame.prototype.onPointerMove = function(a) {};

function SEffect(a, b, c, d, e, f) {
    this.inPool = !1;
    this.name = a;
    this.canvas = d;
    this.clip = null;
    this.params = f || {};
    this.isAwaitingDelete = !1;
    this.type = 0;
    this.loops = "undefined" !== typeof e ? e : 1;
    this.m_repeat = 0;
    this.deleteAtTheEnd = !0;
    this.m_endCompleteCaller = this.m_endCompleteCallback = null
}
SEffect.prototype.create = function() {};
SEffect.TYPE_ANIMO = 1;
SEffect.TYPE_NANO = 2;
SEffect.TYPE_GUI = 3;
SEffect.prototype.fix = function(a) {
    this.clip.position.x = a.x;
    this.clip.position.y = a.y
};
SEffect.prototype.free = function() {
    this.inPool ? PoolClips.instance.releaseClip(this.clip) : this.clip && this.clip.parent && this.clip.parent.removeChild(this.clip);
    this.params = this.m_endCompleteCaller = this.m_endCompleteCallback = this.canvas = this.clip = null
};
SEffect.prototype.onComplete = function(a, b) {
    this.m_endCompleteCaller = a || null;
    this.m_endCompleteCallback = b || null
};
SEffect.prototype.onEndLoop = function() {
    this.m_repeat++;
    0 !== this.loops && this.m_repeat >= this.loops && (null !== this.m_endCompleteCallback && null !== this.m_endCompleteCaller && this.m_endCompleteCallback.call(this.m_endCompleteCaller, this), this.deleteAtTheEnd ? this.isAwaitingDelete = !0 : this.clip.gotoAndStop(this.clip.totalFrames - 1))
};
SEffect.prototype.update = function(a) {};

function SEffectAnimo(a, b, c, d, e, f) {
    SEffect.call(this, a, b, c, d, e, f);
    this.clip = PoolClips.instance.getClip(a);
    this.clip.position.x = b;
    this.clip.position.y = c;
    this.canvas.addChild(this.clip);
    this.clip.onEndAnimation(this, this.onEndLoop);
    this.type = SEffect.TYPE_ANIMO;
    this.inPool = !0
}
Application.subclass(SEffectAnimo, SEffect);
SEffectAnimo.prototype.update = function(a) {
    this.clip.update(a)
};

function SEffectNano(a, b, c, d, e) {
    NanoEffect.call(this, a, b, c, d, e);
    this.type = SEffect.TYPE_NANO;
    this.m_endCompleteCaller = this.m_endCompleteCallback = null
}
Application.subclass(SEffectNano, NanoEffect);
SEffectNano.prototype.fix = function(a, b) {
    this.x = a;
    this.y = b;
    for (var c = 0; c < this.emitters.length; c++)
        for (var d = 0; d < this.emitters[c].particles.length; d++) this.emitters[c].particles[d].ox = a + this.emitters[c].ox, this.emitters[c].particles[d].oy = b + this.emitters[c].oy
};
SEffectNano.prototype.onComplete = function(a, b) {
    this.m_endCompleteCaller = a || null;
    this.m_endCompleteCallback = b || null
};
SEffectNano.prototype.update = function(a) {
    NanoEffect.prototype.update.call(this, a);
    this.isAwaitingDelete && null !== this.m_endCompleteCallback && null !== this.m_endCompleteCaller && this.m_endCompleteCallback.call(this.m_endCompleteCaller, this)
};
SEffectNano.prototype.free = function() {
    NanoEffect.prototype.free.call(this);
    this.m_endCompleteCaller = this.m_endCompleteCallback = null
};

function SEffectGui(a, b, c, d, e, f) {
    SEffect.call(this, a, b, c, d, e, f);
    this.clip = Application.instance.getClip(a);
    this.canvas.addChild(this.clip);
    this.clip.position.x = b;
    this.clip.position.y = c;
    this.clip.onEndAnimation(this, this.onEndLoop);
    this.type = SEffect.TYPE_GUI;
    this.controls = {};
    this.lastInteractionControl = "";
    this.parseControls(a)
}
Application.subclass(SEffectGui, SEffect);
SEffectGui.prototype.update = function(a) {
    this.clip && this.clip.update(a)
};
SEffectGui.prototype.parseControls = function(a) {
    var b = window.config.ui,
        c = Application.RIGHT_TO_LEFT ? "_rtl" : "_ltr",
        d = null,
        e = "",
        f;
    for (f in b)
        if (b[f].gui === a) {
            var g = this.clip.getInstance(b[f].control);
            if (g) {
                e = b[f]["font" + c];
                switch (Common.trim(b[f].type).toUpperCase()) {
                    case GuiControl.TYPE_TEXT:
                        d = new GuiText(g);
                        d.setClip(b[f].link);
                        d.setStyle({
                            size: parseInt(b[f]["size" + c], 0),
                            font: b[f]["size" + c] + "px " + e,
                            fill: b[f].color,
                            strokeThickness: parseInt(b[f].border, 10),
                            stroke: b[f].borderColor,
                            align: b[f]["align" + c] ?
                                parseInt(Common.trim(b[f]["align" + c]), 10) : GuiText.ALIGN_CENTER,
                            valign: b[f].valign ? parseInt(Common.trim(b[f].valign), 10) : GuiText.ALIGN_V_TOP,
                            wordWrap: b[f].wordWrap ? 1 === parseInt(Common.trim(b[f].wordWrap), 10) : !1,
                            wordWrapWidth: d.baseWidth
                        });
                        "undefined" !== typeof Application.strings[b[f].string] ? d.setTextLocalized(b[f].string) : Application.warn("SEffectGui string id [" + b[f].string + "] no found");
                        break;
                    case GuiControl.TYPE_CLIP:
                        d = new GuiClip(g);
                        d.setClip(b[f].link);
                        break;
                    case GuiControl.TYPE_BUTTON:
                        d = new GuiButton(g);
                        d.setClip(b[f].link);
                        d.addPressListener(this, this.onUIPress);
                        break;
                    case GuiControl.TYPE_CLIP_MOUSE:
                        d = new GuiControlInteractive(g);
                        d.setClip(b[f].link);
                        d.addPressListener(this, this.onUIPress);
                        break;
                    case GuiControl.TYPE_CONTENT:
                        d = new GuiContent(g)
                }
                d.name = Common.trim(b[f].control);
                this.controls[b[f].control] = d
            }
        }
};
SEffectGui.prototype.getControl = function(a) {
    "undefined" === typeof this.controls[a] && Application.error("Control [" + a + "] no found");
    return this.controls[a]
};
SEffectGui.prototype.onUIPress = function(a) {
    this.onResumeScreen();
    this.lastInteractionControl = a.name
};
SEffectGui.prototype.onStopScreen = function() {
    this.clip && this.clip.stop()
};
SEffectGui.prototype.onResumeScreen = function() {
    this.clip && this.clip.resume()
};
SEffectGui.prototype.onFinishScreen = function() {};
SEffectGui.prototype.onKeyDown = function(a) {
    this.onResumeScreen()
};
SEffectGui.prototype.free = function() {
    for (var a in this.controls) this.controls[a].free(), this.controls[a] = null;
    this.clip = this.controls = null
};

function SEffectManager() {
    this.effects = [];
    this.m_k = this.m_len = 0
}
SEffectManager.prototype.clear = function() {
    for (var a = 0; a < this.effects.length; a++) this.effects[a].isAwaitingDelete = !0
};
SEffectManager.prototype.add = function(a) {
    this.effects.push(a)
};
SEffectManager.prototype.createEffect = function(a, b, c, d, e, f) {
    if (window.nano.effects[a]) return this.createEffectNano(a, b, c, d, f);
    var g = window.config["ui" + (Application.RIGHT_TO_LEFT ? "_rtl" : "")];
    if (g)
        for (var h = 0; h < g.length; h++)
            if (g[h].gui === a) return this.createEffectGui(a, b, c, d, e, f);
    return this.createEffectAnimo(a, b, c, d, e, f)
};
SEffectManager.prototype.createEffectAnimo = function(a, b, c, d, e, f) {
    a = new SEffectAnimo(a, b, c, d, e, f);
    this.add(a);
    return a
};
SEffectManager.prototype.createEffectNano = function(a, b, c, d, e) {
    a = new SEffectNano(a, b, c, d, e);
    this.add(a);
    return a
};
SEffectManager.prototype.createEffectGui = function(a, b, c, d, e, f) {
    a = new SEffectGui(a, b, c, d, e, f);
    this.add(a);
    return a
};
SEffectManager.prototype.update = function(a) {
    this.m_len = this.effects.length;
    for (this.m_k = 0; this.m_k < this.m_len; this.m_k++) this.effects[this.m_k].update(a), this.effects[this.m_k].isAwaitingDelete && (this.effects[this.m_k].free(), this.effects[this.m_k] = null, this.effects.splice(this.m_k, 1), this.m_k--, this.m_len--)
};

function ControlGroup() {
    this.controls = [];
    this.controlSelected = null
}
ControlGroup.prototype.addControl = function(a) {
    this.controls.push(a)
};
ControlGroup.prototype.onSelectControl = function(a) {
    for (var b = 0; b < this.controls.length; b++) this.controls[b].name === a ? (this.controls[b].gotoState(GuiControl.ST_SELECTED), this.controlSelected = this.controls[b]) : this.controls[b].gotoState(GuiControl.ST_ENABLE)
};
ControlGroup.prototype.free = function() {
    this.controlSelected = this.controls = null
};

function GuiControl(a) {
    a && 0 === a.children.length && (a.texture._frame.width = 0, a.texture._frame.height = 0);
    this.canvas = a;
    this.clip = null;
    this.clipName = this.name = "";
    this.state = 1;
    this.enabled = !0;
    this.screenContainer = null;
    this.isVisible = !0
}
GuiControl.prototype.setVisible = function(a) {
    this.canvas.visible = this.clip.visible = a
};
GuiControl.prototype.getOx = function() {
    return this.canvas.position.x
};
GuiControl.prototype.setOx = function(a) {
    this.canvas.position.x = a
};
GuiControl.prototype.setAlpha = function(a) {
    this.canvas.alpha = a
};
GuiControl.prototype.free = function() {
    for (; 0 < this.canvas.children.length;) this.canvas.removeChild(this.canvas.getChildAt(0));
    this.canvas = this.clip = this.screenContainer = null
};
GuiControl.prototype.setEnabled = function(a) {
    this.enabled = a
};
GuiControl.prototype.setClip = function(a) {
    this.clip = null;
    this.clipName = a;
    if (this.canvas) {
        for (; 0 < this.canvas.children.length;) this.canvas.removeChild(this.canvas.getChildAt(0));
        this.clip = Application.instance.getClip(this.clipName);
        this.canvas.addChild(this.clip)
    }
};
GuiControl.prototype.onResetState = function() {};
GuiControl.prototype.gotoState = function(a) {
    this.state = a
};
GuiControl.prototype.update = function(a) {};
GuiControl.TYPE_TEXT = "TEXT";
GuiControl.TYPE_CLIP = "CLIP";
GuiControl.TYPE_ON_OFF = "ON_OFF";
GuiControl.TYPE_BUTTON = "BUTTON";
GuiControl.TYPE_4STATES = "4STATES";
GuiControl.TYPE_CLIP_MOUSE = "CLIPMOUSE";
GuiControl.TYPE_CONTENT = "CONTENT";
GuiControl.TYPE_ANI_BUTTON = "ANI_BUTTON";
GuiControl.ST_ENABLE = 1;
GuiControl.ST_DISABLE = 2;
GuiControl.ST_SELECTED = 3;
GuiControl.ST_COMMING_SOON = 4;
GuiControl.ST_RELEASE = 5;
GuiControl.ST_OVER = 6;
GuiControl.ST_OUT = 7;
GuiControl.I_OX = 1;
GuiControl.I_OY = 2;
GuiControl.I_SCALE_X = 3;
GuiControl.I_SCALE_Y = 4;
GuiControl.I_SCALE = 5;
GuiControl.I_ROTATION = 6;
GuiControl.I_ALPHA = 7;

function GuiControlInteractive(a) {
    GuiControl.call(this, a);
    this.m_interactive = !1;
    this._moveCallback = this._moveCaller = this._pressAndReleaseCallback = this._pressAndReleaseCaller = this._releaseCallback = this._releaseCaller = this._pressCallback = this._pressCaller = null;
    this.commingSoonLink = this.outLink = this.overLink = this.releaseLink = this.selectedLink = this.disableLink = this.enableLink = "";
    this.onPressButton = !1;
    this._outCallback = this._outCaller = this._overCallback = this._overCaller = null;
    this.buttonMode = !1
}
Application.subclass(GuiControlInteractive, GuiControl);
GuiControlInteractive.prototype.free = function() {
    this.setInteractive(!1);
    this.screenContainer = this._moveCallback = this._moveCaller = this._pressAndReleaseCallback = this._pressAndReleaseCaller = this._releaseCallback = this._releaseCaller = this._pressCallback = this._pressCaller = this._outCaller = this._outCallback = this._overCallback = this._overCaller = null;
    GuiControl.prototype.free.call(this)
};
GuiControlInteractive.prototype.setInteractive = function(a) {
    this.m_interactive = a;
    this.clip && (this.clip.interactive = this.m_interactive, a ? (this.clip.self = this, this.clip.mousedown = function(a) {
            this.self.onPress(a)
        }, this.clip.touchstart = function(a) {
            this.self.onPress(a)
        }, this.clip.mouseup = function(a) {
            this.self.onRelease(a)
        }, this.clip.mouseupoutside = function(a) {
            this.self.onRelease(a)
        }, this.clip.touchend = function(a) {
            this.self.onRelease(a)
        }, this.clip.touchendoutside = function(a) {
            this.self.onRelease(a)
        }, this.clip.mousemove =
        function(a) {
            this.self.onMove(a)
        }, this.clip.touchmove = function(a) {
            this.self.onMove(a)
        }, this.clip.mouseover = function(a) {
            this.self.onOver(a)
        }, this.clip.mouseout = function(a) {
            this.self.onOut(a)
        }) : (this.clip.self = null, this.clip.mousedown = null, this.clip.touchstart = null, this.clip.mouseup = null, this.clip.mouseupoutside = null, this.clip.touchend = null, this.clip.touchendoutside = null, this.clip.mousemove = null, this.clip.touchmove = null, this.clip.mouseover = null, this.clip.mouseout = null), this.clip.buttonMode = !0)
};
GuiControlInteractive.prototype.setClip = function(a) {
    GuiControl.prototype.setClip.call(this, a);
    this.setInteractive(this.m_interactive)
};
GuiControlInteractive.prototype.addPressListener = function(a, b) {
    this._pressCaller = a;
    this._pressCallback = b
};
GuiControlInteractive.prototype.addReleaseListener = function(a, b) {
    this._releaseCaller = a;
    this._releaseCallback = b
};
GuiControlInteractive.prototype.addPressAndReleaseListener = function(a, b) {
    this._pressAndReleaseCaller = a;
    this._pressAndReleaseCallback = b
};
GuiControlInteractive.prototype.addMoveListener = function(a, b) {
    this._moveCallback = b;
    this._moveCaller = a
};
GuiControlInteractive.prototype.addOverListener = function(a, b, c, d) {
    this._overCallback = b;
    this._overCaller = a;
    this._outCallback = d;
    this._outCaller = c
};
GuiControlInteractive.prototype.onPress = function(a) {
    null !== this._pressCaller && null !== this._pressCallback && this._pressCallback.call(this._pressCaller, this)
};
GuiControlInteractive.prototype.onRelease = function(a) {
    null !== this._releaseCaller && null !== this._releaseCallback && this._releaseCallback.call(this._releaseCaller, this)
};
GuiControlInteractive.prototype.onPressAndRelease = function(a) {
    null !== this._pressAndReleaseCaller && null !== this._pressAndReleaseCallback && this._pressAndReleaseCallback.call(this._pressAndReleaseCaller, this)
};
GuiControlInteractive.prototype.onMove = function(a) {
    null !== this._moveCaller && null !== this._moveCallback && this._moveCallback.call(this._moveCaller, this, a)
};
GuiControlInteractive.prototype.onOver = function(a) {
    null !== this._overCaller && null !== this._overCallback && this._overCallback.call(this._overCaller, this, a);
    this.buttonMode && document.getElementById("MainCanvasEvents") && (document.getElementById("MainCanvasEvents").style.cursor = "pointer")
};
GuiControlInteractive.prototype.onOut = function(a) {
    null !== this._outCaller && null !== this._outCallback && this._outCallback.call(this._outCaller, this, a);
    document.getElementById("MainCanvasEvents") && (document.getElementById("MainCanvasEvents").style.cursor = "default")
};

function GuiThumbs4State(a, b, c, d, e) {
    GuiControlInteractive.call(this, a);
    this.enableLink = b || "";
    this.disableLink = c || "";
    this.selectedLink = d || "";
    this.commingSoonLink = e || "";
    this.gotoState(GuiControl.ST_ENABLE)
}
Application.subclass(GuiThumbs4State, GuiControlInteractive);
GuiThumbs4State.prototype.setEnabled = function(a) {
    (this.enabled = a) || this.gotoState(GuiControl.ST_DISABLE)
};
GuiThumbs4State.prototype.gotoState = function(a) {
    if (this.enabled) switch (a) {
        case GuiControl.ST_ENABLE:
            "" !== this.enableLink && (this.setClip(this.enableLink), this.setInteractive(!0), this.state = a);
            break;
        case GuiControl.ST_DISABLE:
            "" !== this.disableLink && (this.setClip(this.disableLink), this.setInteractive(!1), this.enabled = !1, this.state = a);
            break;
        case GuiControl.ST_SELECTED:
            "" !== this.selectedLink && (this.setClip(this.selectedLink), this.setInteractive(!1), this.state = a);
            break;
        case GuiControl.ST_COMMING_SOON:
            "" !==
            this.commingSoonLink && (this.setClip(this.commingSoonLink), this.setInteractive(!1), this.state = a, this.enabled = !1);
            break;
        case GuiControl.ST_OVER:
            "" !== this.overLink && (this.setClip(this.overLink), this.setInteractive(!0), this.state = a, this.enabled = !0)
    }
};

function GuiClip(a) {
    GuiControl.call(this, a)
}
Application.subclass(GuiClip, GuiControl);

function GuiOnOff(a) {
    GuiControlInteractive.call(this, a);
    this.setInteractive(!0);
    this.m_callbackOff = this.m_callbackOn = this.m_callerSwitch = this.m_offLink = this.m_onLink = null;
    this.buttonMode = !0
}
Application.subclass(GuiOnOff, GuiControlInteractive);
GuiOnOff.prototype.free = function() {
    this.m_callbackOff = this.m_callbackOn = this.m_callerSwitch = this.m_offLink = this.m_onLink = null;
    GuiControlInteractive.prototype.free.call(this)
};
GuiOnOff.prototype.onTurnOn = function(a, b) {
    this.m_callerSwitch = a;
    this.m_callbackOn = b
};
GuiOnOff.prototype.onTurnOff = function(a, b) {
    this.m_callerSwitch = a;
    this.m_callbackOff = b
};
GuiOnOff.prototype.setClip = function(a) {
    GuiControlInteractive.prototype.setClip.call(this, a);
    null !== this.clip && this.clip.stop()
};
GuiOnOff.prototype.setOnClip = function(a) {
    this.m_onLink = a
};
GuiOnOff.prototype.setOffClip = function(a) {
    this.m_offLink = a
};
GuiOnOff.prototype.setEnabled = function(a) {
    GuiControlInteractive.prototype.setEnabled.call(this, a);
    null !== this.clip && this.clip.gotoAndStop(this.enabled ? 1 : 4)
};
GuiOnOff.prototype.gotoState = function(a) {
    this.state = a;
    this.setClip(a === GuiOnOff.ST_ON ? this.m_onLink : this.m_offLink)
};
GuiOnOff.prototype.onPress = function(a) {
    this.enabled && (GuiControlInteractive.prototype.onPress.call(this, a), this.state === GuiOnOff.ST_OFF ? (this.gotoState(GuiOnOff.ST_ON), null != this.m_callerSwitch && null != this.m_callbackOn && this.m_callbackOn.call(this.m_callerSwitch)) : this.state === GuiOnOff.ST_ON && (this.gotoState(GuiOnOff.ST_OFF), null != this.m_callerSwitch && null != this.m_callbackOff && this.m_callbackOff.call(this.m_callerSwitch)))
};
GuiOnOff.prototype.onRelease = function(a) {
    this.enabled && GuiControlInteractive.prototype.onRelease.call(this, a)
};
GuiOnOff.ST_ON = 1;
GuiOnOff.ST_OFF = 2;

function GuiButton(a) {
    GuiControlInteractive.call(this, a);
    this.addOverListener(this, this.onOverCallback, this, this.onOutCallback);
    this.setInteractive(!0);
    this.buttonMode = !0
}
Application.subclass(GuiButton, GuiControlInteractive);
GuiButton.prototype.setClip = function(a) {
    GuiControlInteractive.prototype.setClip.call(this, a);
    null !== this.clip && this.clip.gotoAndStop(1)
};
GuiButton.prototype.setEnabled = function(a) {
    GuiControl.prototype.setEnabled.call(this, a);
    null !== this.clip && this.clip.gotoAndStop(this.enabled ? 1 : 4)
};
GuiButton.prototype.onPress = function(a) {
    this.enabled && (GuiControlInteractive.prototype.onPress.call(this, a), null !== this.clip && this.clip.gotoAndStop(2))
};
GuiButton.prototype.onRelease = function(a) {
    GuiControlInteractive.prototype.onRelease.call(this, a);
    null !== this.clip && this.clip.gotoAndStop(this.enabled ? 1 : 4)
};
GuiButton.prototype.onOverCallback = function(a) {
    null !== this.clip && this.clip.gotoAndStop(this.enabled ? 3 : 4);
    if (this.m_screenContainer && !Application.instance.isMobileDevice) this.m_screenContainer.onUIOver(this)
};
GuiButton.prototype.onOutCallback = function(a) {
    null !== this.clip && this.clip.gotoAndStop(this.enabled ? 1 : 4);
    if (this.m_screenContainer && !Application.instance.isMobileDevice) this.m_screenContainer.onUIOut(this)
};

function GuiButtonState(a, b) {
    GuiControlInteractive.call(this, a);
    this.outLink = b + "_out";
    this.overLink = b + "_over";
    this.enableLink = b + "_on";
    this.disableLink = b + "_off";
    this.releaseLink = b + "_out";
    this.selectedLink = b + "_press";
    this.onPressButton = !1;
    this.addOverListener(this, this.onOverCallback, this, this.onOutCallback);
    this.gotoState(GuiControl.ST_ENABLE);
    this.buttonMode = !0
}
Application.subclass(GuiButtonState, GuiControlInteractive);
GuiButtonState.prototype.setEnabled = function(a) {
    GuiControlInteractive.prototype.setEnabled.call(this, a);
    this.gotoState(this.enabled ? GuiControl.ST_ENABLE : GuiControl.ST_DISABLE)
};
GuiButtonState.prototype.onPress = function(a) {
    this.enabled && this.m_interactive && (GuiControlInteractive.prototype.onPress.call(this, a), this.gotoState(GuiControl.ST_SELECTED))
};
GuiButtonState.prototype.onRelease = function(a) {
    this.enabled && this.m_interactive && (GuiControlInteractive.prototype.onRelease.call(this, a), this.state === GuiControl.ST_SELECTED && this.gotoState(GuiControl.ST_RELEASE))
};
GuiButtonState.prototype.onOverCallback = function(a) {
    if (this.state !== GuiControl.ST_OVER && !this.onPressButton && this.m_interactive && (this.gotoState(GuiControl.ST_OVER), this.m_screenContainer && !Application.instance.isMobileDevice)) this.m_screenContainer.onUIOver(this)
};
GuiButtonState.prototype.onOutCallback = function(a) {
    if (this.state === GuiControl.ST_OUT || this.state === GuiControl.ST_RELEASE || this.onPressButton || !this.m_interactive) this.onPressButton && (this.onPressButton = !1, this.state === GuiControl.ST_SELECTED && this.gotoState(GuiControl.ST_OUT));
    else if (this.gotoState(GuiControl.ST_OUT), this.m_screenContainer && !Application.instance.isMobileDevice) this.m_screenContainer.onUIOut(this)
};
GuiButtonState.prototype.onResetState = function() {
    this.enabled && (this.onPressButton = !1, this.gotoState(GuiControl.ST_ENABLE))
};
GuiButtonState.prototype.setClip = function(a) {
    this.isVisible && GuiControlInteractive.prototype.setClip.call(this, a)
};
GuiButtonState.prototype.onFade = function(a, b) {
    b = "undefined" === typeof b ? 500 : b;
    var c = 0,
        d = 0;
    this.clip.visible = !0;
    if (this.isVisible = a) {
        if (1 === this.clip.alpha) return;
        this.gotoState(GuiControl.ST_ENABLE);
        c = 0;
        d = 1
    } else {
        if (0 === this.clip.alpha) return;
        c = 1;
        d = 0
    }
    Common.tween({
        parent: this,
        clip: this.clip,
        alpha: c
    }, {
        alpha: d
    }, b, !0, 0, TweenEasing.LinearNone);
    this.setInteractive(this.isVisible)
};
GuiButtonState.prototype.setVisible = function(a) {
    this.isVisible = a;
    GuiControl.prototype.setVisible.call(this, a)
};
GuiButtonState.prototype.update = function(a) {
    GuiControl.prototype.update.call(this, a)
};
GuiButtonState.prototype.gotoState = function(a) {
    switch (a) {
        case GuiControl.ST_ENABLE:
            this.m_interactive = !0;
            this.setClip(this.enableLink);
            this.state = a;
            break;
        case GuiControl.ST_DISABLE:
            this.m_interactive = !1;
            this.setClip(this.disableLink);
            this.enabled = !1;
            this.state = a;
            break;
        case GuiControl.ST_SELECTED:
            this.m_interactive = this.onPressButton = !0;
            this.setClip(this.selectedLink);
            this.state = a;
            break;
        case GuiControl.ST_RELEASE:
            this.m_interactive = !0;
            this.setClip(this.outLink);
            this.state = a;
            break;
        case GuiControl.ST_OVER:
            this.m_interactive = !0;
            this.setClip(this.overLink);
            this.state = a;
            break;
        case GuiControl.ST_OUT:
            this.m_interactive = !0, this.setClip(this.outLink), this.state = a
    }
};

function GuiText(a) {
    GuiControl.call(this, a);
    this.baseHeight = this.baseWidth = 0;
    this.textfield = this.style = null;
    this.isPixiText = !1
}
Application.subclass(GuiText, GuiControl);
GuiText.prototype.free = function() {
    this.textfield && (this.textfield.destroy(!0), this.canvas.removeChild(this.textfield), this.textfield = null);
    GuiControl.prototype.free.call(this)
};
GuiText.prototype.setText = function(a) {
    if (this.textfield) {
        this.textfield.setText(a);
        this.textfield.updateText();
        if (Application.RIGHT_TO_LEFT) switch (this.style.align) {
            case GuiText.ALIGN_CENTER:
                this.textfield.position.x = .5 * this.textfield._width;
                break;
            case GuiText.ALIGN_LEFT:
                this.textfield.position.x = this.textfield._width - .5 * this.baseWidth;
                break;
            case GuiText.ALIGN_RIGHT:
                this.textfield.position.x = .5 * this.baseWidth
        }
        if (!Application.RIGHT_TO_LEFT || Application.RIGHT_TO_LEFT && this.isPixiText) switch (this.style.align) {
            case GuiText.ALIGN_CENTER:
                this.textfield.position.x =
                    .5 * -this.textfield._width;
                break;
            case GuiText.ALIGN_LEFT:
                this.textfield.position.x = .5 * -this.baseWidth;
                break;
            case GuiText.ALIGN_RIGHT:
                this.textfield.position.x = .5 * -this.baseWidth + (this.baseWidth - this.textfield._width)
        }
        switch (this.style.valign) {
            case GuiText.ALIGN_V_TOP:
                this.textfield.position.y = .5 * -this.baseHeight;
                break;
            case GuiText.ALIGN_V_MIDDLE:
                this.textfield.position.y = .5 * -this.textfield._height;
                break;
            case GuiText.ALIGN_V_BOTTOM:
                this.textfield.position.y = .5 * this.baseHeight - this.textfield._height
        }
        this.textfield.position.x =
            this.offsetX + this.textfield.position.x;
        this.textfield.position.y = this.offsetY + this.textfield.position.y;
        this.isPixiText || (this.textfield.position.y += .5 * this.textfield._lineHeight)
    }
};
GuiText.prototype.setClip = function(a) {
    a = Application.instance.getClip(a).getChildAt(0);
    this.baseWidth = a.getBounds().width * a.scale.x;
    this.baseHeight = a.getBounds().height * a.scale.y;
    this.offsetX = a.position.x;
    this.offsetY = a.position.y;
    this.textfield = new SPixiText("", {});
    this.isPixiText = !0;
    this.style = this.textfield.style;
    this.canvas.addChild(this.textfield)
};
GuiText.prototype.setStyle = function(a) {
    this.textfield && (this.textfield.setStyle(a), this.style = this.textfield.style)
};
GuiText.prototype.setTextEmpty = function() {
    this.setTextLocalized("STR_EMPTY")
};
GuiText.prototype.setTextJoined = function(a, b, c, d) {
    d || -1 !== b.indexOf(c) ? this.setTextLocalized(a + ((10 <= c ? "" : "0") + c)) : Application.warn("GuiText::setTextJoined: value " + c + " not in range " + b + ".")
};
GuiText.prototype.setTextLocalized = function(a) {
    this.setText(Application.strings[a])
};
GuiText.prototype.setTextNumeric = function(a) {
    "number" === typeof a ? this.setText(a.toString()) : Application.warn("GuiText::setTextNumeric: text not numeric.")
};
GuiText.prototype.setTextRaw = function(a) {
    Application.warn("setTextRaw: " + a);
    this.setText(a)
};
GuiText.prototype.setTextReplace = function(a, b, c) {
    if (b.length !== c.length) Application.warn("GuiText::setTextReplace: array inputs do not have the same length.");
    else if (Application.strings[a]) {
        a = Application.strings[a];
        for (var d = 0; d < b.length; d++) a = a.replace(b[d], c[d]);
        this.setText(a)
    } else Application.warn("GuiText::setTextReplace: id " + a + " not found.")
};
GuiText.ALIGN_LEFT = 0;
GuiText.ALIGN_CENTER = 1;
GuiText.ALIGN_RIGHT = 2;
GuiText.ALIGN_V_TOP = 0;
GuiText.ALIGN_V_MIDDLE = 1;
GuiText.ALIGN_V_BOTTOM = 2;

function GuiSlider(a, b, c, d) {
    this.x = c;
    this.y = d;
    this.m_pressed = !1;
    this.canvas = a;
    this.m_collision = this.m_pointer = this.m_animation = null;
    this.m_nameClip = b;
    this.m_caller = this.m_callback = null;
    this.m_collisionPositionX = 0;
    this.createGuiSlider();
    this.m_currentIdTouch = -1;
    this.m_lastX = this.m_virtualPointerPositionX = 0
}
GuiSlider.HALF_TOTAL_DISTANCE = 50;
GuiSlider.POINTER_RADIO = 15;
GuiSlider.POINTER_RADIO_POW2 = 225;
GuiSlider.POINTER_NAME_INSTANCE = "pointer";
GuiSlider.COLLISION_NAME_INSTANCE = "mcCollision";
GuiSlider.prototype.linkFunction = function(a, b) {
    this.m_callback = b;
    this.m_caller = a
};
GuiSlider.prototype.createGuiSlider = function() {
    this.m_animation = Application.instance.getClip(this.m_nameClip);
    this.canvas.addChild(this.m_animation);
    this.m_animation.position.x = this.x;
    this.m_animation.position.y = this.y;
    this.m_pointer = this.m_animation.getInstance(GuiSlider.POINTER_NAME_INSTANCE);
    this.m_collision = this.m_animation.collisions[GuiSlider.COLLISION_NAME_INSTANCE];
    this.m_collisionPositionX = this.m_collision.x - this.m_pointer.position.x;
    this.m_animation.interactive = !0;
    this.m_animation.self =
        this;
    this.m_animation.mousedown = function(a) {
        this.self.onPointerPress(a)
    };
    this.m_animation.touchstart = function(a) {
        this.self.onPointerPress(a)
    };
    this.m_animation.mouseup = function(a) {
        this.self.onPointerRelease(a)
    };
    this.m_animation.mouseupoutside = function(a) {
        this.self.onPointerRelease(a)
    };
    this.m_animation.touchend = function(a) {
        this.self.onPointerRelease(a)
    };
    this.m_animation.touchendoutside = function(a) {
        this.self.onPointerRelease(a)
    };
    this.m_animation.mousemove = function(a) {
        this.self.onPointerMove(a)
    };
    this.m_animation.touchmove =
        function(a) {
            this.self.onPointerMove(a)
        }
};
GuiSlider.prototype.onPointerPress = function(a) {
    if (!Application.instance.isMobileDevice || -1 === this.m_currentIdTouch) {
        var b = this.x + this.m_virtualPointerPositionX - a.data.global.x - GuiSlider.HALF_TOTAL_DISTANCE,
            c = this.y - a.data.global.y;
        b * b + c * c < GuiSlider.POINTER_RADIO_POW2 && (Application.instance.isMobileDevice && (this.m_currentIdTouch = a.currentTouchEvent.identifier), this.m_lastX = a.data.global.x, this.m_pressed = !0)
    }
};
GuiSlider.prototype.onPointerRelease = function(a) {
    Application.instance.isMobileDevice && this.m_currentIdTouch !== a.currentTouchEvent.identifier || (this.m_pressed = !1, this.m_currentIdTouch = -1, this.m_virtualPointerPositionX > 2 * GuiSlider.HALF_TOTAL_DISTANCE ? this.m_virtualPointerPositionX = 2 * GuiSlider.HALF_TOTAL_DISTANCE : 0 > this.m_virtualPointerPositionX && (this.m_virtualPointerPositionX = 0))
};
GuiSlider.prototype.onPointerMove = function(a) {
    if ((!Application.instance.isMobileDevice || this.m_currentIdTouch === a.currentTouchEvent.identifier) && this.m_pressed) {
        var b = a.data.global.x - this.m_lastX;
        this.m_lastX = a.data.global.x;
        this.setPointerPosition((this.m_virtualPointerPositionX + b) / (2 * GuiSlider.HALF_TOTAL_DISTANCE))
    }
};
GuiSlider.prototype.setPointerPosition = function(a) {
    this.m_virtualPointerPositionX = a = 2 * a * GuiSlider.HALF_TOTAL_DISTANCE;
    this.updatePointerPosition(a)
};
GuiSlider.prototype.updatePointerPosition = function(a) {
    var b = this.m_pointerPositionX;
    this.m_pointerPositionX = a > 2 * GuiSlider.HALF_TOTAL_DISTANCE ? 2 * GuiSlider.HALF_TOTAL_DISTANCE : 0 > a ? 0 : a;
    this.m_pointerPositionX !== b && (this.m_pointer.position.x = this.m_pointerPositionX - GuiSlider.HALF_TOTAL_DISTANCE, this.m_collision.x = this.m_pointer.position.x + this.m_collisionPositionX, null !== this.m_callback && this.m_callback.call(this.m_caller, this, this.m_pointerPositionX / (2 * GuiSlider.HALF_TOTAL_DISTANCE)))
};
GuiSlider.prototype.free = function() {
    this.m_pointer = null;
    this.canvas.removeChild(this.m_animation);
    this.m_animation = null
};

function GuiContent(a) {
    GuiControl.call(this, a);
    this.clip = Application.instance.addDisplayContainer();
    this.canvas.addChild(this.clip)
}
Application.subclass(GuiContent, GuiControl);
GuiContent.prototype.update = function(a) {};

function DataMovement(a, b) {
    this.motionParams = null;
    var c = Common.getParams(a);
    this.isLoop = 1 == parseInt(c.loop, 10);
    this.isReverse = 1 == parseInt(c.reverse, 10);
    this.speed = parseFloat(c.speed);
    this.setMotionParams(b)
}
DataMovement.prototype.setMotionParams = function(a) {
    this.motionParams = [];
    a = a.split(";");
    for (var b = 0; b < a.length;) {
        var c = [],
            d = a[b].split(":");
        if (2 > d.length) Application.error("DataMovement::setMotionParams(): " + a[b]);
        else {
            c.push(d[0]);
            for (var d = d[1].split(","), e = 0; e < d.length;) c.push(d[e]), ++e;
            this.motionParams.push(c)
        }++b
    }
};
DataMovement.prototype.free = function() {
    this.motionParams = null
};

function WorldActor(a, b, c, d, e, f) {
    this.m_state = 0;
    this.m_character = null;
    this.id = WorldActor.ID_UNUSED;
    this.canRepeatState = !1;
    this.m_magic = this.m_health = this.m_depth = this.m_oldY = this.m_oldX = this.m_y = this.m_x = 0;
    this.m_scaleY = this.m_scaleX = this.m_scale = 1;
    this.m_cornersArray = this.m_control = this.m_manager = this.m_vehicle = this.pathPosition = this.m_corners = this.m_cornersArray = this.m_clip = this.m_boundsAttack = this.m_bounds = this.m_speed = null;
    this.m_canvas = a;
    this.m_world = b;
    this.isAwaitingDelete = this.m_flipX = this.m_limitRight =
        this.m_limitLeft = this.m_limitUp = this.m_limitBottom = this.m_isVehicle = this.isIdle = !1;
    this.isRangeControlled = !0;
    this.m_limitRight = this.m_limitLeft = this.m_limitUp = this.m_limitBottom = this.m_isFallingOverWall = !1;
    this.m_indexCornersArray = 0;
    this.setActorClip(f);
    this.setPosition(c, d);
    this.m_className = ""
}
WorldActor.ID_UNUSED = -1;
WorldActor.prototype.getClassName = function() {
    return this.m_className
};
WorldActor.prototype.getHealth = function() {
    return this.m_health
};
WorldActor.prototype.setHealth = function(a) {
    this.m_health = a
};
WorldActor.prototype.isFallingOverWall = function() {
    return this.m_isFallingOverWall
};
WorldActor.prototype.vehicle = function() {
    return this.m_vehicle
};
WorldActor.prototype.isVehicle = function() {
    return this.m_isVehicle
};
WorldActor.prototype.setFallingOverWall = function(a) {
    this.m_isFallingOverWall = a
};
WorldActor.prototype.setVehicle = function(a) {
    this.m_vehicle = a
};
WorldActor.prototype.setManager = function(a) {
    this.m_manager = a
};
WorldActor.prototype.clip = function() {
    return this.m_clip
};
WorldActor.prototype.bounds = function() {
    return this.m_bounds
};
WorldActor.prototype.speed = function() {
    return this.m_speed
};
WorldActor.prototype.world = function() {
    return this.m_world
};
WorldActor.prototype.control = function() {
    return this.m_control
};
WorldActor.prototype.limitBottom = function() {
    return this.m_limitBottom
};
WorldActor.prototype.limitUp = function() {
    return this.m_limitUp
};
WorldActor.prototype.limitLeft = function() {
    return this.m_limitLeft
};
WorldActor.prototype.limitRight = function() {
    return this.m_limitRight
};
WorldActor.prototype.depth = function() {
    return this.m_depth
};
WorldActor.prototype.scale = function() {
    return this.m_scale
};
WorldActor.prototype.magic = function() {
    return this.m_magic
};
WorldActor.prototype.getX = function() {
    return this.m_x
};
WorldActor.prototype.getY = function() {
    return this.m_y
};
WorldActor.prototype.flipX = function() {
    return this.m_flipX
};
WorldActor.prototype.canvas = function() {
    return this.m_canvas
};
WorldActor.prototype.onEnterZone = function(a) {};
WorldActor.prototype.onLeaveZone = function(a) {};
WorldActor.prototype.finishJumpUp = function() {};
WorldActor.prototype.setActorClip = function(a) {
    a = "undefined" === typeof a ? null : a;
    null !== a && (this.m_clip = Application.instance.getClip(a), this.m_canvas.addChild(this.m_clip), this.createCorners())
};
WorldActor.prototype.setPositionPoint = function(a) {
    this.m_oldX = this.m_x = a.x;
    this.m_oldY = this.m_y = a.y
};
WorldActor.prototype.setPosition = function(a, b) {
    this.m_oldX = this.m_x = a;
    this.m_oldY = this.m_y = b
};
WorldActor.prototype.setX = function(a) {
    this.m_oldX = this.m_x = a
};
WorldActor.prototype.setY = function(a) {
    this.m_oldY = this.m_y = a
};
WorldActor.prototype.setFlipX = function(a) {
    this.m_flipX = a;
    if (null !== this.m_clip) {
        if (this.m_flipX && 0 < this.m_clip.scale.x || !this.m_flipX && 0 > this.m_clip.scale.x) this.m_clip.scale.x = -this.m_clip.scale.x;
        this.createCorners()
    }
};
WorldActor.prototype.setScale = function(a) {
    this.m_scale != a && (null !== this.m_clip && this.m_clip.setScale(this.m_flipX ? -a : a, a), this.m_scaleY = this.m_scaleX = this.m_scale = a, this.createCorners())
};
WorldActor.prototype.setScaleX = function(a) {
    this.m_scaleX != a && (null !== this.m_clip && (this.m_clip.scale.x = this.m_flipX ? -a : a), this.m_scaleX = a, this.createCorners())
};
WorldActor.prototype.setScaleY = function(a) {
    this.m_scaleY != a && (null !== this.m_clip && (this.m_clip.scale.y = a), this.m_scaleY = a, this.createCorners())
};
WorldActor.prototype.setScaleXY = function(a, b) {
    this.setScaleX(a);
    this.setScaleY(b)
};
WorldActor.prototype.resize = function(a, b) {
    null !== this.m_clip && this.setScaleXY(a / this.m_clip.width, b / this.m_clip.height)
};
WorldActor.prototype.getBounds = function() {
    return null !== this.m_bounds ? new Rectangle(this.m_x + this.m_bounds.x, parseFloat(this.m_y + this.m_bounds.y), this.m_bounds.w, this.m_bounds.h) : null
};
WorldActor.prototype.boundsAttack = function() {
    return this.m_boundsAttack
};
WorldActor.prototype.getBoundsAttack = function() {
    return null !== this.m_boundsAttack ? new Rectangle(this.m_x + this.m_boundsAttack.x, parseFloat(this.m_y + this.m_boundsAttack.y), this.m_boundsAttack.w, this.m_boundsAttack.h) : null
};
WorldActor.prototype.createCorners = function() {
    var a = null;
    null !== this.m_bounds && (a = new Rectangle, a.x = this.m_bounds.x, a.y = this.m_bounds.y, a.w = this.m_bounds.w, a.h = this.m_bounds.h);
    if (null !== a) {
        this.m_corners = [];
        var b = this.m_scaleX,
            c = this.m_scaleY;
        this.m_scaleX == this.m_scaleY && (this.m_scale = this.m_scaleX);
        this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + a.h), 1, 1));
        Math.abs(b * a.w) > this.m_world.tileWidth() ? this.m_corners.push(new CollisionPoint(b * (a.x + .5 * a.w), c * (a.y + a.h), 0, 1)) : this.m_corners.push(null);
        this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y + a.h), -1, 1));
        c * a.h > 3 * this.m_world.tileHeight() ? (this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + .75 * a.h), 1, 0)), this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y + .75 * a.h), -1, 0)), this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + .5 * a.h), 1, 0)), this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y + .5 * a.h), -1, 0)), this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + .25 * a.h), 1, 0)), this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y +
            .25 * a.h), -1, 0))) : c * a.h > 2 * this.m_world.tileHeight() ? (this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + .67 * a.h), this.m_flipX ? -1 : 1, 0)), this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y + .67 * a.h), -1, 0)), this.m_corners.push(null), this.m_corners.push(null), this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + .33 * a.h), this.m_flipX ? -1 : 1, 0)), this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y + .33 * a.h), -1, 0))) : (c * a.h > this.m_world.tileHeight() ? (this.m_corners.push(null), this.m_corners.push(null),
            this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + .5 * a.h), 1, 0)), this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y + .5 * a.h), -1, 0))) : (this.m_corners.push(null), this.m_corners.push(null), this.m_corners.push(null), this.m_corners.push(null)), this.m_corners.push(null), this.m_corners.push(null));
        this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * a.y, 1, -1));
        Math.abs(b * a.w) > this.m_world.tileWidth() ? this.m_corners.push(new CollisionPoint(b * (a.x + .5 * a.w), c * a.y, 0, -1)) : this.m_corners.push(null);
        this.m_corners.push(new CollisionPoint(b *
            a.x, c * a.y, -1, -1));
        this.m_cornersArray = [];
        this.m_cornersArray.push([]);
        this.m_cornersArray.push([]);
        this.m_cornersArray.push([]);
        this.m_cornersArray.push([]);
        a = [];
        a.push([0, 1, 3, 2, 5, 7, 9]);
        a.push([2, 1, 4, 0, 6, 8, 11]);
        a.push([9, 10, 7, 11, 5, 3, 0]);
        a.push([11, 10, 8, 9, 6, 4, 2]);
        for (b = 0; b < this.m_cornersArray.length; b++)
            for (c = 0; c < a[b].length; c++) null != this.m_corners[a[b][c]] && this.m_cornersArray[b].push(this.m_corners[a[b][c]])
    } else this.m_cornersArray = null;
    this.updateBounds()
};
WorldActor.prototype.getCollision = function(a) {
    var b = null;
    if (a = this.m_clip.getCollision(a)) b = a.clone(), b.x = this.m_clip.scale.x * (0 > this.m_clip.scale.x) ? -b.x - b.w : b.x, b.y = this.m_clip.scale.y * (0 > this.m_clip.scale.y) ? -b.y - b.h : b.y;
    return b
};
WorldActor.prototype.updateBounds = function() {
    this.m_bounds = null;
    null !== this.m_clip && (this.m_bounds = this.getCollision("mcCollision")) && (this.m_bounds.x *= this.m_scaleX, this.m_bounds.y *= this.m_scaleY, this.m_bounds.w *= this.m_scaleX, this.m_bounds.h *= this.m_scaleY)
};
WorldActor.prototype.updateBoundsAttack = function() {
    this.m_boundsAttack = null;
    null !== this.m_clip && (this.m_boundsAttack = this.getCollision("mcCollisionAttack")) && (this.m_boundsAttack.x *= this.m_scaleX, this.m_boundsAttack.y *= this.m_scaleY, this.m_boundsAttack.w *= this.m_scaleX, this.m_boundsAttack.h *= this.m_scaleY)
};
WorldActor.prototype.isOverPlatform = function() {
    var a = null,
        a = this.m_bounds;
    if (this.m_vehicle) return !0;
    if (null !== a) {
        var b = this.m_x + a.x,
            c = this.m_y + 3;
        if (this.m_world.getCellInPosition(b + a.w, c) == WorldCollisionLayer.CELL_PLATFORM || this.m_world.getCellInPosition(this.m_x, c) == WorldCollisionLayer.CELL_PLATFORM || this.m_world.getCellInPosition(b, c) == WorldCollisionLayer.CELL_PLATFORM) return !0
    }
    return !1
};
WorldActor.prototype.gotoState = function(a) {
    a != this.m_state && (this.characterGotoState(a), this.m_state = a)
};
WorldActor.prototype.characterGotoState = function(a) {
    null === this.m_character || !this.canRepeatState && a === this.m_state || (this.m_character.gotoState(a), this.m_clip = this.m_character.clip, this.m_clip.scale.y = this.m_scaleY)
};
WorldActor.prototype.corners = function() {
    if (null === this.m_cornersArray) return null;
    this.m_indexCornersArray = 0 > this.m_speed.y ? 0 <= this.m_speed.x ? 2 : 3 : 0 > this.m_speed.x ? 1 : 0;
    return this.m_cornersArray[this.m_indexCornersArray]
};
WorldActor.prototype.update = function(a) {
    null !== this.m_clip && (this.m_clip.position.x = this.m_x - this.m_world.m_camera.m_x, this.m_clip.position.y = this.m_y - this.m_world.m_camera.m_y)
};
WorldActor.prototype.isInCamera = function(a) {
    return this.m_x + this.m_bounds.w / 3 > a.getX() && this.m_x - this.m_bounds.w / 3 < a.getX() + a.width && this.m_y > a.getY() && this.m_y - this.m_bounds.h < a.getY() + a.height
};
WorldActor.prototype.showInCamera = function(a) {
    this.m_character.setPosition(this.m_x - a.getX(), this.m_y - a.getY())
};
WorldActor.prototype.checkCollision = function() {
    return this.m_world.checkCollision(this)
};
WorldActor.prototype.applyImpulse = function(a, b) {
    this.m_oldX = this.m_x - a;
    this.m_oldY = this.m_y - b
};
WorldActor.prototype.hitTest = function(a) {
    if (null !== this.m_bounds) {
        var b = new Rectangle(this.m_bounds.x, this.m_bounds.y, this.m_bounds.w, this.m_bounds.h);
        b.x += this.m_x;
        b.y += this.m_y;
        if (null !== a.getBounds()) return b.intersectRect(a.getBounds())
    }
    return !1
};
WorldActor.prototype.hitIntersection = function(a) {
    if (null !== this.m_bounds) {
        var b = new Rectangle(this.m_bounds.x, this.m_bounds.y, this.m_bounds.w, this.m_bounds.h);
        b.x += this.m_x;
        b.y += this.m_y;
        a = a.getBounds();
        if (null !== a) return b.intersectRect(a)
    }
    return null
};
WorldActor.prototype.integrateVerlet = function(a) {
    var b = this.m_oldX,
        c = this.m_oldY;
    this.m_oldX = this.m_x;
    this.m_oldY = this.m_y;
    b = this.m_x - b;
    b < -this.m_control.maxVerletHorizontalDisplace ? b = -this.m_control.maxVerletHorizontalDisplace : b > this.m_control.maxVerletHorizontalDisplace && (b = this.m_control.maxVerletHorizontalDisplace);
    this.m_x += b;
    a = this.m_y - c + this.m_control.gravity * a * a;
    a < -this.m_control.maxVerletUpDisplace ? a = -this.m_control.maxVerletUpDisplace : a > this.m_control.maxVerletDownDisplace && (a = this.m_control.maxVerletDownDisplace);
    this.m_y += a
};
WorldActor.prototype.onDebugDraw = function(a) {
    null !== this.m_bounds && ContextGraphics.drawRectangle(a, this.m_x - this.m_world.camera().getX() + this.m_bounds.x, this.m_y - this.m_world.camera().getY() + this.m_bounds.y, this.m_bounds.w, this.m_bounds.h, 1, Common.COLOR_RED, Common.COLOR_NONE);
    null !== this.m_boundsAttack && ContextGraphics.drawRectangle(a, this.m_x - this.m_world.camera().getX() + this.m_boundsAttack.x, this.m_y - this.m_world.camera().getY() + this.m_boundsAttack.y, this.m_boundsAttack.w, this.m_boundsAttack.h, 1,
        Common.COLOR_BLUE, Common.COLOR_NONE);
    if (this.m_corners)
        for (var b = 0; b < this.m_cornersArray[this.m_indexCornersArray].length; b++) this.m_cornersArray[this.m_indexCornersArray][b] && ContextGraphics.drawCircle(a, this.m_x - this.m_world.camera().getX() + this.m_cornersArray[this.m_indexCornersArray][b].position.x, this.m_y - this.m_world.camera().getY() + this.m_cornersArray[this.m_indexCornersArray][b].position.y, 3, Common.COLOR_MAGENTA, Common.COLOR_MAGENTA)
};
WorldActor.prototype.onIdle = function(a) {
    this.isIdle = a;
    null !== this.m_clip && (this.m_clip.visible = !a)
};
WorldActor.prototype.free = function() {
    null !== this.m_character && (this.m_character.free(), this.m_clip = this.m_character = null);
    null !== this.m_clip && (this.m_clip.free(), this.m_canvas.removeChild(this.m_clip), this.m_clip = null);
    this.m_speed = this.m_world = this.m_canvas = this.m_bounds = this.pathPosition = null;
    if (null !== this.m_cornersArray)
        for (var a = 0; a < this.m_cornersArray.length; a++) this.m_cornersArray[a] = null;
    this.m_control = this.m_manager = this.m_vehicle = this.m_cornersArray = null
};

function SimpleWorldActor(a, b, c, d, e, f) {
    this.isIdle = !1;
    this.scale = 1;
    this.id = SimpleWorldActor.ID_UNUSED;
    this.isAwaitingDelete = !1;
    this.isRangeControlled = !0;
    this.m_x = c;
    this.m_y = d;
    this.m_state = "";
    this.m_clip = null;
    this.m_skin = "";
    this.m_character = null;
    Application.isLowDevice ? this.m_canvas = a : (this.m_canvas = new window.PIXI.Container, a.addChild(this.m_canvas));
    this.m_world = b;
    this.m_health = 0;
    this.m_flipX = !1;
    this.m_className = ""
}
SimpleWorldActor.ID_UNUSED = -1;
SimpleWorldActor.COLLISION = "mcCollision";
SimpleWorldActor.COLLISION_ATTACK = "mcCollisionAttack";
SimpleWorldActor.COLLISION_EXPEL = "mcCollisionExpel";
SimpleWorldActor.COLLISION_SPECIAL = "mcCollisionSpecial";
SimpleWorldActor.prototype.getClassName = function() {
    return this.m_className
};
SimpleWorldActor.prototype.setActorClip = function(a) {
    a = "undefined" === typeof a ? null : a;
    null !== a && (this.m_clip = PoolClips.instance.getClip(a), this.m_canvas.addChild(this.m_clip))
};
SimpleWorldActor.prototype.hitTest = function(a) {
    return this.m_clip.hitTest(a.m_clip)
};
SimpleWorldActor.prototype.hitCollisions = function(a, b, c) {
    return SDisplayObjectContainer.hitTestByBounds(this.m_clip, this.m_clip.getCollision(a), b.m_clip, b.m_clip.getCollision(c))
};
SimpleWorldActor.prototype.setPosition = function(a, b) {
    this.m_x = a;
    this.m_y = b;
    this.m_clip && (this.m_clip.position.x = this.m_x - this.m_world.m_camera.m_x, this.m_clip.position.y = this.m_y - this.m_world.m_camera.m_y)
};
SimpleWorldActor.prototype.setFlipX = function(a) {
    this.m_flipX !== a && this.m_clip && (this.m_flipX = a, this.m_clip.scale.x = this.scale * (this.m_flipX ? -1 : 1))
};
SimpleWorldActor.prototype.gotoState = function(a) {
    a != this.m_state && (this.characterGotoState(a), this.m_state = a)
};
SimpleWorldActor.prototype.characterGotoState = function(a) {
    a !== this.m_state && null !== this.m_character && (this.m_character.gotoState(a), this.m_clip = this.m_character.clip, this.m_clip.scale.x = this.m_flipX ? -this.scale : this.scale, this.m_clip.scale.y = this.scale, this.m_clip.position.x = this.m_x - this.m_world.m_camera.m_x, this.m_clip.position.y = this.m_y - this.m_world.m_camera.m_y)
};
SimpleWorldActor.prototype.update = function(a) {
    this.m_character && this.m_character.update(a);
    this.m_clip && (this.m_clip.position.x = this.m_x - this.m_world.m_camera.m_x, this.m_clip.position.y = this.m_y - this.m_world.m_camera.m_y)
};
SimpleWorldActor.prototype.onIdle = function(a) {
    this.isIdle = a;
    null !== this.m_clip && (this.m_clip.visible = !a)
};
SimpleWorldActor.prototype.free = function() {
    this.m_character && (this.m_character.free(), this.m_clip = this.m_character = null);
    this.m_clip && (PoolClips.instance.releaseClip(this.m_clip), this.m_clip = null);
    this.m_world = this.m_canvas = null
};

function EnvironmentActor(a, b, c, d) {
    this.isIdle = !1;
    this.m_npc = c;
    this.id = d;
    this.sx = this.m_npc.sx;
    this.sy = this.m_npc.sy;
    this.m_x = this.m_npc.x;
    this.m_y = this.m_npc.y;
    this.isAwaitingDelete = !1;
    this.isRangeControlled = !0;
    this.m_clip = null;
    this.m_canvas = a;
    this.m_world = b;
    this.m_flipX = !1;
    this.m_skin = ""; - 1 !== this.id && (this.m_skin = this.m_npc.skinName, this.setActorClip(this.m_skin))
}
EnvironmentActor.prototype.setActorClip = function(a) {
    a = "undefined" === typeof a ? null : a;
    null !== a && (this.m_clip && (PoolClips.instance.releaseClip(this.m_clip), this.m_clip = null), this.m_clip = PoolClips.instance.getClip(a), this.m_canvas.addChild(this.m_clip))
};
EnvironmentActor.prototype.setPosition = function(a, b) {
    this.m_x = a;
    this.m_y = b;
    this.m_clip && (this.m_clip.position.x = this.m_x - this.m_world.m_camera.m_x, this.m_clip.position.y = this.m_y - this.m_world.m_camera.m_y)
};
EnvironmentActor.prototype.update = function(a) {
    this.m_clip && (this.m_clip.position.x = this.m_x - this.m_world.m_camera.m_x, this.m_clip.position.y = this.m_y - this.m_world.m_camera.m_y, this.m_clip.update(a))
};
EnvironmentActor.prototype.onIdle = function(a) {
    this.isIdle = a;
    null !== this.m_clip && (this.m_clip.visible = !a)
};
EnvironmentActor.prototype.free = function() {
    this.m_clip && (PoolClips.instance.releaseClip(this.m_clip), this.m_clip = null);
    this.m_world = this.m_canvas = null
};

function Landmark(a, b, c) {
    SimpleWorldActor.call(this, a, b, c.x, c.y);
    this.skin = "landmark";
    this.m_character = new SimpleCharacter(this.m_x, this.m_y, this.m_canvas);
    this.m_character.addState(Landmark.ST_OFF, this.skin + "_off_stand");
    this.m_character.addState(Landmark.ST_ON, this.skin + "_on_stand");
    this.m_character.addState(Landmark.ST_TURNING_ON, this.skin + "_off_turn_on");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.gotoState(Landmark.ST_OFF)
}
Application.subclass(Landmark, SimpleWorldActor);
Landmark.ST_OFF = "off";
Landmark.ST_ON = "on";
Landmark.ST_TURNING_ON = "turning_on";
Landmark.prototype.update = function(a) {
    SimpleWorldActor.prototype.update.call(this, a);
    this.m_state === Landmark.ST_OFF && this.m_clip.hitTest(this.m_world.m_player.m_clip) && this.gotoState(Landmark.ST_TURNING_ON)
};
Landmark.prototype.onEndAnimation = function(a) {
    switch (a) {
        case Landmark.ST_TURNING_ON:
            this.gotoState(Landmark.ST_ON)
    }
};

function ActorControl(a) {
    this.maxSpeedAir = this.maxSpeedFloor = this.canClimb = this.canRun = this.runFactor = this.walkSpeed = this.airSpeed = this.maxVerletHorizontalDisplace = this.maxVerletDownDisplace = this.maxVerletUpDisplace = this.slopeFriction = this.friction = this.elasticity = this.gravity = 0;
    this.m_actor = a;
    this.m_forceY = this.m_forceX = 0;
    this.m_isInDashAttack = this.m_isInAction = this.m_isJumpingDown = this.m_isJumpingUp = this.m_isJumping = this.m_isRunning = !1;
    this.reset()
}
ActorControl.prototype.forceX = function() {
    return this.m_forceX
};
ActorControl.prototype.forceY = function() {
    return this.m_forceY
};
ActorControl.prototype.isRunning = function() {
    return this.m_isRunning
};
ActorControl.prototype.isJumping = function() {
    return this.m_isJumping
};
ActorControl.prototype.isJumpingUp = function() {
    return this.m_isJumpingUp
};
ActorControl.prototype.isJumpingDown = function() {
    return this.m_isJumpingDown
};
ActorControl.prototype.isInAction = function() {
    return this.m_isInAction
};
ActorControl.prototype.isInDashAttack = function() {
    return this.m_isInDashAttack
};
ActorControl.prototype.reset = function() {
    this.m_forceY = this.m_forceX = 0;
    this.m_isInAction = this.m_isRunning = this.m_isJumpingDown = this.m_isJumpingUp = this.m_isJumping = !1
};
ActorControl.prototype.loadData = function(a) {
    this.setDefaultData(a)
};
ActorControl.prototype.setDefaultData = function(a) {
    this.setData(a)
};
ActorControl.prototype.setData = function(a) {
    this.gravity = this.getData(a, "gravity");
    this.elasticity = this.getData(a, "elasticity");
    this.friction = this.getData(a, "friction");
    this.slopeFriction = this.getData(a, "slopeFriction");
    this.maxVerletUpDisplace = this.getData(a, "maxVerletUpDisplace");
    this.maxVerletDownDisplace = this.getData(a, "maxVerletDownDisplace");
    this.maxVerletHorizontalDisplace = this.getData(a, "maxVerletHorizontalDisplace")
};
ActorControl.prototype.getData = function(a, b) {
    if (null === a) Application.error("World:: data is null");
    else if (null === b) Application.error("World:: data is null: " + b);
    else {
        if (null !== a[b]) return a[b];
        Application.error("Property not found: " + b)
    }
};
ActorControl.prototype.getOptionalData = function(a, b, c) {
    if ("undefined" === a) Application.error("World:: data is null");
    else if ("undefined" === b) Application.error("World:: data is null: " + b);
    else {
        if (null != a[b]) return a[b];
        Application.error("Optional property not found: " + b + " using: " + c);
        return c
    }
};
ActorControl.prototype.update = function(a) {};
ActorControl.prototype.onCollison = function(a, b) {};
ActorControl.prototype.free = function() {
    this.m_actor = null
};

function Camera(a, b, c, d, e, f, g) {
    this.m_x = "undefined" !== typeof f ? f : 0;
    this.m_y = "undefined" !== typeof g ? g : 0;
    this.m_world = a;
    this.m_fixedX = this.m_world.cameraXMin == this.m_world.cameraXMax;
    this.m_fixedY = this.m_world.cameraYMax == this.m_world.cameraYMin;
    this.m_scale = 1;
    this.m_width = b;
    this.m_height = c;
    this.screenX = "undefined" !== typeof d ? d : 0;
    this.screenY = "undefined" !== typeof e ? e : 0;
    this.leftLimit = Math.round(this.m_world.cameraXMin * this.m_width);
    this.rightLimit = Math.round(this.m_world.cameraXMax * this.m_width);
    this.upLimit =
        Math.round(this.m_world.cameraYMin * this.m_height);
    this.downLimit = Math.round(this.m_world.cameraYMax * this.m_height);
    this.parallaxX = this.m_world.width() > this.m_width;
    this.parallaxY = this.m_world.height() > this.m_height;
    this.blendXOffset = this.blendYOffset = this.blendSpeed = this.old_m_y = this.old_m_x = 0;
    this.blendToTarget = this.blendToPos = null;
    this.breakOnReach = this.onBlendTimer = this.isBlending = !1;
    this.blendTimer = 0;
    this.blendCallbackParam = this.blendCallback = this.blendCaller = null;
    this.blendZoom = 0;
    this.isZoomBlending = !1;
    this.currentZoom = 1;
    this.followTarget = this.m_world.m_player;
    this.m_lockState = Camera.LOCK_OFF;
    this.m_move = null;
    this.m_moveSpeed = .5;
    this.fixWidthRatio = Layout.aspectRatio / Layout.minAspectRatio * this.m_width;
    this.fixOffsetX = .5 * (this.fixWidthRatio - this.m_width);
    this.centerPos = {
        x: 0,
        y: 0
    };
    this.setCenter()
}
Camera.LOCK_OFF = 0;
Camera.LOCK_IN = 1;
Camera.LOCK_ON = 2;
Camera.LOCK_OUT = 3;
Camera.BLENDING = 4;
Camera.prototype.setCenter = function() {
    this.centerPos.x = this.m_x - this.fixOffsetX + .5 * this.fixWidthRatio;
    this.centerPos.y = this.m_y + .5 * this.m_height
};
Camera.prototype.getCornerPos = function(a) {
    var b = {
        x: 0,
        y: 0
    };
    b.x = a.x - (-this.fixOffsetX + .5 * this.fixWidthRatio);
    b.y = a.y - .5 * this.m_height;
    return b
};
Camera.prototype.getX = function() {
    return this.m_x
};
Camera.prototype.getY = function() {
    return this.m_y
};
Camera.prototype.setX = function(a) {
    this.m_x = a
};
Camera.prototype.setY = function(a) {
    this.m_y = a
};
Camera.prototype.scale = function() {
    return this.m_scale
};
Camera.prototype.width = function() {
    return this.m_width
};
Camera.prototype.height = function() {
    return this.m_height
};
Camera.prototype.setWidth = function(a) {
    this.m_width = a
};
Camera.prototype.setHeight = function(a) {
    this.m_height = a
};
Camera.prototype.isLocked = function() {
    return this.m_lockState === Camera.LOCK_ON
};
Camera.prototype.resetBlending = function() {
    this.blendToTarget = this.blendToPos = null;
    this.isBlending = !1
};
Camera.prototype.doBlend = function(a) {
    var b, c;
    if (this.isBlending) {
        this.blendToTarget ? (b = this.blendToTarget.m_x + this.fixOffsetX + this.blendXOffset, c = this.blendToTarget.m_y + this.blendYOffset) : (b = this.blendToPos.x + this.blendXOffset, c = this.blendToPos.y + this.blendYOffset);
        this.m_x += this.lerp(this.m_x, b - .5 * this.fixWidthRatio, this.blendSpeed, a);
        this.m_y += this.lerp(this.m_y, c - .5 * this.m_height, this.blendSpeed, a);
        a = b - .5 * this.fixWidthRatio - this.m_x;
        c = c - .5 * this.m_height - this.m_y;
        a = 0 > a ? -a : a;
        c = 0 > c ? -c : c;
        b = !1;
        var d =
            .5 * this.m_width * (1 - Layout.aspectRatio / Layout.minAspectRatio);
        this.m_x < -d ? (b = !0, this.m_x = -d) : this.m_x > this.m_world.width() - this.width() && (b = !0, this.m_x = this.m_world.width() - this.width());
        d = !1;
        0 > this.m_y ? (this.m_y = 0, d = !0) : this.m_y > this.m_world.height() - this.height() && (this.m_y = this.m_world.height() - this.height(), d = !0);
        var e = !1;
        (1 > a || b) && (1 > c || d) && (e = !0);
        e && (this.blendCaller && (this.blendCallback.call(this.blendCaller, this.blendCallbackParam), this.blendCaller = null), this.breakOnReach && this.resetBlending());
        return !0
    }
    return !1
};
Camera.prototype.update = function(a) {
    this.setCenter();
    this.isZoomBlending && this.doZoomBlending(a);
    if (!this.doBlend(a))
        if (this.m_lockState !== Camera.LOCK_OFF) switch (this.m_lockState) {
            case Camera.LOCK_IN:
            case Camera.LOCK_OUT:
                this.m_move && (this.m_x = this.m_move.getX(), this.m_move.update(a))
        } else this.checkPosition(this.m_world.player().getX(), this.m_world.player().getY()), a = .5 * this.m_width * (1 - Layout.aspectRatio / Layout.minAspectRatio), this.m_x < -a ? this.m_x = -a : this.m_x > this.m_world.width() - this.width() && (this.m_x =
            this.m_world.width() - this.width()), 0 > this.m_y ? this.m_y = 0 : this.m_y > this.m_world.height() - this.height() && (this.m_y = this.m_world.height() - this.height())
};
Camera.prototype.checkPosition = function(a, b) {
    this.m_fixedX ? this.m_x = a - this.leftLimit : (this.m_x + this.leftLimit > a && (this.m_x = a - this.leftLimit), this.m_x + this.rightLimit < a && (this.m_x = a - this.rightLimit));
    this.m_fixedY ? this.m_y = b - this.upLimit : (this.m_y + this.upLimit > b && (this.m_y = b - this.upLimit), this.m_y + this.downLimit < b && (this.m_y = b - this.downLimit))
};
Camera.prototype.setScale = function(a) {
    this.m_scale = a;
    this.m_world.setScale(a)
};
Camera.prototype.onDebugDraw = function(a) {
    var b = Layout.aspectRatio / Layout.minAspectRatio;
    ContextGraphics.drawRectangle(a, .5 * this.m_width * (1 - b), 0, this.m_width * b, this.m_height, 2, Common.COLOR_RED, Common.COLOR_NONE)
};
Camera.prototype.free = function() {
    this.m_world = null
};
Camera.prototype.doBlendWithTarget = function(a, b, c, d, e, f, g, h) {
    this.isBlending || (this.m_lockState = Camera.BLENDING, this.old_m_x = this.m_x, this.old_m_y = this.m_y, this.blendYOffset = c, this.blendXOffset = b, this.blendToTarget = a, this.blendSpeed = d, this.blendCaller = f, this.blendCallback = g, this.blendCallbackParam = h, this.isBlending = !0, this.breakOnReach = e)
};
Camera.prototype.doBlendWithPos = function(a, b, c, d, e, f, g, h, k) {
    this.isBlending || (this.m_lockState = Camera.BLENDING, a = this.getCornerPos({
            x: a + c,
            y: b + d
        }), a.x < this.fixOffsetX ? a.x = this.fixOffsetX : a.x > this.m_world.width() - this.width() && (a.x = this.m_world.width() - this.width()), 0 > a.y ? a.y = 0 : a.y > this.m_world.height() - this.height() && (a.y = this.m_world.height() - this.height()), this.old_m_x = this.m_x, this.old_m_y = this.m_y, this.blendXOffset = this.blendYOffset = 0, this.blendSpeed = e, this.blendCaller = g, this.blendCallback = h, this.blendCallbackParam =
        k, this.blendToPos = {
            x: a.x + .5 * this.fixWidthRatio,
            y: a.y + .5 * this.m_height
        }, this.isBlending = !0, this.breakOnReach = f)
};
Camera.prototype.stopBlending = function() {
    this.m_lockState = Camera.LOCK_OFF;
    this.isBlending = !1;
    this.blendToTarget = this.blendCallbackParam = this.blendCallback = this.blendCaller = null
};
Camera.prototype.lerp = function(a, b, c, d) {
    return d / 1E3 * c * (b - a)
};
Camera.prototype.lock = function(a, b) {
    this.m_move && (this.m_move.free(), this.m_move = null);
    a ? this.m_lockState === Camera.LOCK_OFF && (Application.log("LOCKING CAMERA"), this.m_lockState = Camera.LOCK_IN) : this.m_lockState === Camera.LOCK_ON && (Application.log("UNLOCKING CAMERA"), this.m_lockState = Camera.LOCK_OUT, this.m_move = new LinearMovement(this.m_x, this.m_y, this.m_moveSpeed), this.m_move.setCallbacks(this, this.onEndMovement, null), this.m_move.gotoPosition(this.m_world.player().getX() - (a ? .5 * this.m_width : this.leftLimit),
        this.m_y), this.m_move.gotoPosition(b - (a ? .5 * this.m_width : this.leftLimit), this.m_y))
};
Camera.prototype.onEndMovement = function(a) {
    this.m_move && (this.m_x = this.m_move.getX(), this.m_move.free(), this.m_move = null);
    this.m_lockState === Camera.LOCK_IN ? (Application.log("LOCKED CAMERA"), this.m_lockState = Camera.LOCK_ON) : (this.m_lockState === Camera.LOCK_OUT && Application.log("UNLOCKED CAMERA"), this.m_lockState = Camera.LOCK_OFF)
};
Camera.prototype.setBlendingZoom = function(a) {
    this.blendZoom = a;
    this.isZoomBlending = !0
};
Camera.prototype.doZoomBlending = function(a) {
    this.fixOffsetX *= this.currentZoom;
    this.fixWidthRatio *= this.currentZoom;
    this.m_height *= this.currentZoom;
    this.currentZoom += Common.lerp(this.currentZoom, this.blendZoom, 5, a);
    GuiGame.instance.canvasBackground.scale.x = this.currentZoom;
    GuiGame.instance.canvasBackground.scale.y = this.currentZoom;
    GuiGame.instance.canvasGame.scale.x = this.currentZoom;
    GuiGame.instance.canvasGame.scale.y = this.currentZoom;
    GuiGame.instance.canvasEffects.scale.x = this.currentZoom;
    GuiGame.instance.canvasEffects.scale.y =
        this.currentZoom;
    this.fixOffsetX /= this.currentZoom;
    this.fixWidthRatio /= this.currentZoom;
    this.m_height /= this.currentZoom; - .1 <= this.currentZoom - this.blendZoom && .1 >= this.currentZoom - this.blendZoom && (this.isZoomBlending = !1)
};

function CollisionPoint(a, b, c, d) {
    this.position = new Vector2D(a, b);
    this.normal = new Vector2D(c, d)
}
CollisionPoint.prototype.toString = function() {
    return "\n[COLL] " + this.position + " " + this.normal
};

function MobileObject(a, b, c, d, e, f) {
    WorldActor.call(this, a, b, d, e, -1, c);
    this.m_motionController = null;
    this.m_speed = new Vector2D;
    this.m_prevX = this.m_x;
    this.m_prevY = this.m_y;
    this.m_motionController = new MotionController(this.m_x, this.m_y, f);
    this.m_motionController.startMotion();
    this.pause = !1
}
Application.subclass(MobileObject, WorldActor);
MobileObject.prototype.update = function(a) {
    this.pause || (this.m_motionController.update(a), this.m_x = this.m_motionController.getX(), this.m_y = this.m_motionController.getY(), this.m_speed.x = (this.m_x - this.m_prevX) / a, this.m_speed.y = (this.m_y - this.m_prevY) / a, this.m_prevX = this.m_x, this.m_prevY = this.m_y)
};
MobileObject.prototype.free = function() {
    this.m_motionController.free();
    this.m_speed = this.m_motionController = null;
    WorldActor.prototype.free.call(this)
};

function MobilePlatform(a, b, c, d, e) {
    MobileObject.call(this, a, b, c, d.x, d.y, e);
    this.isRangeControlled = !d.alwaysAwake;
    this.m_isVehicle = !0;
    this.m_world.addMobilePlatform(this);
    this.updateBounds()
}
Application.subclass(MobilePlatform, MobileObject);
MobilePlatform.prototype.update = function(a) {
    PlayerSettings.instance.isInLiberation ? this.m_x < this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX - 100 || this.m_x > this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX + this.m_world.m_camera.fixWidthRatio + 100 || this.m_y < this.m_world.m_camera.m_y - 100 || this.m_y > this.m_world.m_camera.m_y + this.m_world.m_camera.m_height + 100 ? this.m_isVehicle = !1 : MobileObject.prototype.update.call(this, a) : (this.m_isVehicle = !0, MobileObject.prototype.update.call(this, a))
};
MobilePlatform.prototype.showInCamera = function(a) {
    WorldActor.prototype.update.call(this, a)
};

function Npc() {
    this.sy = this.sx = this.y = this.x = this.id = 0;
    this.canvas = null;
    this.params = ""
}
Npc.prototype.free = function() {
    this.canvas = null
};

function NpcManager(a) {
    this.m_world = a;
    this.m_height = this.m_width = 0;
    this.m_showCollisions = !1;
    this.m_buffer = [];
    this.m_actors = [];
    this.m_enviromentAnimations = [];
    this.m_landmarks = [];
    this.m_player = null;
    this.visibleWidth = Application.config.settings.APP_WIDTH;
    this.visibleHeight = Application.config.settings.APP_HEIGHT;
    this.enemyManager = this.m_updateableObject = this.allNpc = null
}
NpcManager.prototype.free = function() {
    var a;
    for (a = 0; a < this.m_buffer.length; a++) this.m_buffer[a].free();
    this.m_buffer = null;
    for (a = 0; a < this.m_actors.length; a++) this.m_actors[a].free(), this.m_actors[a] = null;
    this.m_world = this.m_actors = null
};
NpcManager.prototype.collisionsOn = function() {
    return this.m_showCollisions
};
NpcManager.prototype.getActors = function() {
    return this.m_actors
};
NpcManager.prototype.init = function(a) {};
NpcManager.prototype.setPlayer = function(a) {
    this.m_player = a
};
NpcManager.prototype.showCollision = function(a) {
    this.m_showCollisions = a
};
NpcManager.prototype.addNpc = function(a) {
    this.m_buffer.push(a)
};
NpcManager.prototype.add = function(a) {
    a.setManager && a.setManager(this);
    this.m_actors.push(a)
};
NpcManager.prototype.setUpdateableObject = function(a) {
    this.m_updateableObject = a
};
NpcManager.prototype.getUpdateableObject = function() {
    return this.m_updateableObject
};
NpcManager.prototype.onDebugDraw = function(a) {
    for (var b = 0; b < this.m_actors.length; b++)
        if (this.m_actors[b].onDebugDraw) this.m_actors[b].onDebugDraw(a)
};
NpcManager.prototype.saveData = function(a) {
    null !== this.m_player && this.m_player.saveData();
    for (a = this.m_actors.length - 1; 0 <= a; a--) this.m_actors[a] && this.m_actors[a].saveData()
};
NpcManager.prototype.update = function(a) {
    for (var b = 0; b < this.m_actors.length; b++) this.m_actors[b].isAwaitingDelete ? (this.m_actors[b].free(), this.m_actors[b] = null, this.m_actors.splice(b--, 1)) : this.doActorUpdate(this.m_actors[b], a);
    for (b = this.m_enviromentAnimations.length - 1; 0 <= b; b--) {
        var c = this.m_enviromentAnimations[b];
        this.doActorUpdate(c, a);
        c.isAwaitingDelete && (c.free(), this.m_enviromentAnimations.splice(b, 1))
    }
    for (b = this.m_landmarks.length - 1; 0 <= b; b--) c = this.m_landmarks[b], this.doActorUpdate(c, a), c.isAwaitingDelete &&
        (c.free(), this.m_landmarks.splice(b, 1))
};
NpcManager.prototype.doActorUpdate = function(a, b) {
    if (a.isRangeControlled && (a.m_x < this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX - 500 || a.m_x > this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX + this.m_world.m_camera.fixWidthRatio + 500 || a.m_y < this.m_world.m_camera.m_y - 500 || a.m_y > this.m_world.m_camera.m_y + this.m_world.m_camera.m_height + 500)) {
        if (!a.isIdle) a.onIdle(!0)
    } else {
        if (a.isIdle) a.onIdle(!1);
        a.update(b)
    }
};
NpcManager.prototype.getActorByUniqueID = function(a) {
    for (var b = 0; b < this.m_actors.length; ++b)
        if (this.m_actors[b].uniqueId == a) return this.m_actors[b];
    return null
};
NpcManager.prototype.reset = function() {
    for (var a = 0; a < this.m_actors.length; a++) this.m_actors[a].free(), this.m_actors[a] = null;
    this.m_actors = null;
    this.m_actors = []
};

function Player(a, b, c, d) {
    WorldActor.call(this, a, b, c, d);
    this.m_collision = null;
    this.m_freeMovement = !1;
    this.m_factorSpeedY = this.m_factorSpeedX = 1;
    this.m_isDead = this.m_isInvulnerable = !1;
    this.m_move = null;
    this.m_debugCollisionOn = !1;
    this.m_speed = new Vector2D(0, 0);
    this.m_state = "";
    this.isGrounded = this.useSeparatedAnimations = this.m_isActionMove = !1
}
Application.subclass(Player, WorldActor);
Player.MAX_DT = 35;
Player.dtFix = 0;
Player.FACTOR_WALL_ALONE = 1;
Player.FACTOR_WALL_WITH_ENEmy = .5;
Player.MAX_LIMIT_SPEED_IMPULSE = 20;
Player.ST_PLAYER_STAND = "st100";
Player.ST_PLAYER_STAND_2 = "st101";
Player.ST_PLAYER_WALK = "st102";
Player.ST_PLAYER_RUN = "st103";
Player.ST_PLAYER_JUMP_UP = "st104";
Player.ST_PLAYER_JUMP_DOWN = "st105";
Player.ST_PLAYER_HIT = "st106";
Player.ST_PLAYER_LOSE = "st107";
Player.ST_PLAYER_WIN = "st108";
Player.ST_PLAYER_LAND = "st109";
Player.ST_PLAYER_JUMP_SPECIAL = "st110";
Player.ST_PLAYER_CELEBRATE = "st204";
Player.prototype.collision = function() {
    return this.m_collision
};
Player.prototype.isInvulnerable = function() {
    return this.m_isInvulnerable
};
Player.prototype.isDead = function() {
    return this.m_isDead
};
Player.prototype.setIsDead = function(a) {
    this.m_isDead = a
};
Player.prototype.state = function() {
    return this.m_state
};
Player.prototype.character = function() {
    return this.m_character
};
Player.prototype.factorSpeedX = function() {
    return this.m_factorSpeedX
};
Player.prototype.setFactorSpeedX = function(a) {
    this.m_factorSpeedX = a
};
Player.prototype.factorSpeedY = function() {
    return this.m_factorSpeedY
};
Player.prototype.setFactorSpeedY = function(a) {
    this.m_factorSpeedY = a
};
Player.prototype.setFlipX = function(a) {
    WorldActor.prototype.setFlipX.call(this, a)
};
Player.prototype.gotoState = function(a) {
    if (!this.m_isDead && (this.canRepeatState || a !== this.m_state)) {
        this.characterGotoState(a);
        switch (a) {
            case Player.ST_PLAYER_LAND:
                this.onFloor();
                break;
            case Player.ST_PLAYER_LOSE:
                this.m_isDead = !0
        }
        if (this.m_control.isInAction()) this.m_control.onAction(!1);
        this.m_clip = this.m_character.clip;
        this.m_scaleX == this.m_scaleY ? (this.m_clip.scale.x = this.useSeparatedAnimations ? this.m_scale : this.m_flipX ? -this.m_scale : this.m_scale, this.m_clip.scale.y = this.m_scale) : (this.m_clip.scale.x =
            this.useSeparatedAnimations ? this.m_scaleX : this.m_flipX ? -this.m_scaleX : this.m_scaleX, this.m_clip.scale.y = this.m_scaleY);
        this.m_state = a;
        this.canRepeatState = !1
    }
};
Player.prototype.createCorners = function() {
    var a = null;
    null !== this.m_bounds && (a = new Rectangle, a.x = this.m_bounds.x, a.y = this.m_bounds.y, a.w = this.m_bounds.w, a.h = this.m_bounds.h);
    if (null !== a) {
        this.m_corners = [];
        var b = this.m_flipX ? -this.m_scaleX : this.m_scaleX,
            c = this.m_scaleY,
            d = this.m_flipX ? -1 : 1;
        this.m_scaleX == this.m_scaleY && (this.m_scale = this.m_scaleX);
        this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + a.h), d, 1));
        Math.abs(b * a.w) > this.m_world.tileWidth() ? this.m_corners.push(new CollisionPoint(b * (a.x +
            .5 * a.w), c * (a.y + a.h), 0, 1)) : this.m_corners.push(null);
        this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y + a.h), -d, 1));
        c * a.h > 3 * this.m_world.tileHeight() ? (this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + .75 * a.h), d, 0)), this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y + .75 * a.h), -d, 0)), this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + .5 * a.h), d, 0)), this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y + .5 * a.h), -d, 0)), this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + .25 * a.h), d, 0)),
            this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y + .25 * a.h), -d, 0))) : c * a.h > 2 * this.m_world.tileHeight() ? (this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + .67 * a.h), d, 0)), this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y + .67 * a.h), -d, 0)), this.m_corners.push(null), this.m_corners.push(null), this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + .33 * a.h), d, 0)), this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y + .33 * a.h), -d, 0))) : (c * a.h > this.m_world.tileHeight() ? (this.m_corners.push(null), this.m_corners.push(null),
            this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * (a.y + .5 * a.h), d, 0)), this.m_corners.push(new CollisionPoint(b * a.x, c * (a.y + .5 * a.h), -d, 0))) : (this.m_corners.push(null), this.m_corners.push(null), this.m_corners.push(null), this.m_corners.push(null)), this.m_corners.push(null), this.m_corners.push(null));
        this.m_corners.push(new CollisionPoint(b * (a.x + a.w), c * a.y, d, -1));
        Math.abs(b * a.w) > this.m_world.tileWidth() ? this.m_corners.push(new CollisionPoint(b * (a.x + .5 * a.w), c * a.y, 0, -1)) : this.m_corners.push(null);
        this.m_corners.push(new CollisionPoint(b *
            a.x, c * a.y, -d, -1));
        this.m_cornersArray = [];
        this.m_cornersArray.push([]);
        this.m_cornersArray.push([]);
        this.m_cornersArray.push([]);
        this.m_cornersArray.push([]);
        a = [];
        this.m_flipX ? (a.push([2, 1, 4, 0, 6, 8, 11]), a.push([0, 1, 3, 2, 5, 7, 9]), a.push([11, 10, 8, 9, 6, 4, 2]), a.push([9, 10, 7, 11, 5, 3, 0])) : (a.push([0, 1, 3, 2, 5, 7, 9]), a.push([2, 1, 4, 0, 6, 8, 11]), a.push([9, 10, 7, 11, 5, 3, 0]), a.push([11, 10, 8, 9, 6, 4, 2]));
        for (b = 0; b < this.m_cornersArray.length; b++)
            for (c = 0; c < a[b].length; c++) this.m_corners[a[b][c]] && this.m_cornersArray[b].push(this.m_corners[a[b][c]])
    } else this.m_cornersArray =
        null;
    this.updateBounds()
};
Player.prototype.onSpringCollision = function(a, b, c, d) {
    switch (c) {
        case 1:
            this.m_control.onCustomJump(b);
            break;
        case 2:
            this.m_control.onCustomJumpDirected(a, b);
            break;
        case 3:
            this.m_control.onCustomJumpDirected(a, b);
            break;
        case 4:
            this.m_control.onCustomJumpDirected(a, b)
    }
};
Player.prototype.onEndAnimation = function(a) {
    a == Player.ST_PLAYER_JUMP_UP ? this.gotoState(Player.ST_PLAYER_JUMP_DOWN) : a == Player.ST_PLAYER_LAND && this.gotoState(Player.ST_PLAYER_STAND)
};
Player.prototype.onKeyDown = function(a) {
    if (!this.m_isDead && this.m_state !== Player.ST_PLAYER_WIN && this.m_state !== Player.ST_PLAYER_LOSE && this.m_state !== Player.ST_PLAYER_CELEBRATE) switch (a) {
        case PlayerControl.CMD_LEFT_A:
            this.m_control.onLeft(!0);
            break;
        case PlayerControl.CMD_RIGHT_A:
            this.m_control.onRight(!0);
            break;
        case PlayerControl.CMD_DOWN_A:
            this.m_control.onDown(!0)
    }
};
Player.prototype.onKeyUp = function(a) {
    switch (a) {
        case PlayerControl.CMD_LEFT_A:
            this.m_control.onLeft(!1);
            break;
        case PlayerControl.CMD_RIGHT_A:
            this.m_control.onRight(!1);
            break;
        case PlayerControl.CMD_DOWN_A:
            this.m_control.onDown(!1), this.m_control.onJumpDown(!1)
    }
};
Player.prototype.moveFree = function(a) {
    var b = this.m_control.isRunning() ? 3 : 1,
        c = this.m_control.forceX();
    0 != c && (this.m_x += b * this.m_control.debugSpeed * c * a);
    var d = this.m_control.forceY();
    0 != d && (this.m_y += b * this.m_control.debugSpeed * d * a);
    this.m_speed.x = c;
    this.m_speed.y = d;
    this.m_oldX = this.m_x;
    this.m_oldY = this.m_y;
    this.m_debugCollisionOn && (a = this.checkCollision()) && (this.m_x += a.x, this.m_y += a.y)
};
Player.prototype.update = function(a) {
    Player.dtFix = a > Player.MAX_DT ? Player.MAX_DT : a;
    this.m_control.update(Player.dtFix);
    if (this.m_freeMovement) this.moveFree(a);
    else {
        this.m_character.update(a);
        var b = this.m_y;
        this.integrateVerlet(a);
        null !== this.m_vehicle && (isNaN(this.m_vehicle.speed().y) ? Application.warn("(fix)Vehicle speed Y is NaN") : 0 < this.m_vehicle.speed().y && (this.m_y += 1.5 * a * this.m_vehicle.speed().y), isNaN(this.m_vehicle.speed().x) ? Application.warn("(fix)Vehicle speed X is NaN") : this.m_oldX = this.m_x +=
            a * this.m_vehicle.speed().x);
        var c = this.m_control.forceX();
        if (0 != c) {
            var d;
            d = !this.m_control.isInAction() && this.m_state !== Player.ST_PLAYER_HIT && this.m_state !== Player.ST_PLAYER_WIN && this.m_state !== Player.ST_PLAYER_LOSE && this.m_state !== Player.ST_PLAYER_CELEBRATE || this.m_control.isJumping() ? !this.m_control.isJumping() && this.m_collision ? this.m_control.walkSpeed * c * a * a : this.m_control.airSpeed * c * a * a : 0;
            this.m_x += d;
            this.m_state === Player.ST_PLAYER_WIN || this.m_state === Player.ST_PLAYER_LOSE || this.m_state === Player.ST_PLAYER_HIT ||
                this.m_state === Player.ST_PLAYER_CELEBRATE || this.m_control.isJumping() || this.m_control.isInAction() || this.m_isActionMove || this.m_state != Player.ST_PLAYER_WALK && this.gotoState(Player.ST_PLAYER_WALK);
            this.useSeparatedAnimations ? (-1 === c && !this.m_flipX || 1 === c && this.m_flipX) && this.setFlipX(-1 === c) : 0 > c * (this.m_flipX ? -1 : 1) && this.setFlipX(!this.m_flipX)
        } else -.5 < this.m_speed.x && .5 > this.m_speed.x && (this.m_state == Player.ST_PLAYER_WALK || this.m_state == Player.ST_PLAYER_RUN) && !this.m_control.isJumping() && this.gotoState(Player.ST_PLAYER_STAND);
        this.m_control.isJumpingUp() && (this.m_y += this.m_control.deltaHeight());
        this.m_speed.x = this.m_x - this.m_oldX;
        !this.m_control.isJumping() && this.m_collision ? this.m_control.getWasImpulsed() ? c = Player.MAX_LIMIT_SPEED_IMPULSE : (c = this.m_factorSpeedX * this.m_control.maxSpeedFloor, this.m_control.isRunning() && (c *= this.m_control.runFactor)) : this.m_control.getWasImpulsed() ? c = Player.MAX_LIMIT_SPEED_IMPULSE : (c = this.m_factorSpeedX * this.m_control.maxSpeedAir * Player.dtFix, this.m_control.isRunning() && (c *= this.m_control.runFactor));
        this.m_speed.x < -c && (this.m_x = this.m_oldX - c);
        this.m_speed.x > c && (this.m_x = this.m_oldX + c);
        this.m_speed.y = this.m_y - this.m_oldY;
        this.m_world.checkZones(this);
        this.m_collision = this.m_world.checkCollision(this);
        this.m_control.onCollision(this.m_collision, a);
        this.isGrounded = !1;
        if (this.m_collision) {
            d = new Vector2D(this.m_x - this.m_oldX, this.m_y - this.m_oldY);
            c = d.projectionOn(this.m_collision);
            d = d.minus(c);
            this.m_vehicle ? c.scale(0) : c.scale(1 + Number(this.m_control.elasticity));
            this.m_isFallingOverWall ? this.m_isFallingOverWall = !1 : (d.scale(a * this.m_control.friction), c.add(d));
            this.m_oldX += c.x + this.m_collision.x;
            this.m_oldY += c.y + this.m_collision.y;
            this.m_x += this.m_collision.x;
            if (0 != this.m_collision.y) {
                var e = this.m_y + this.m_collision.y - b;
                this.m_y = -1 < e && 1 > e ? b : this.m_y + this.m_collision.y
            }
            this.isGrounded = 0 > e || null !== this.m_vehicle
        }
        this.m_world.checkWorldBoundaries(this);
        if (this.m_y - this.m_clip.height > this.m_world.height()) this.onPlayerFellOutOfWorld()
    }
};
Player.prototype.onFloor = function() {};
Player.prototype.applyImpulse = function(a, b) {
    this.m_isDead || WorldActor.prototype.applyImpulse.call(this, a, b)
};
Player.prototype.integrateVerlet = function(a) {
    var b = this.m_oldX,
        c = this.m_oldY;
    this.m_oldX = this.m_x;
    this.m_oldY = this.m_y;
    b = this.m_x - b;
    b < -this.m_control.maxVerletHorizontalDisplace ? b = -this.m_control.maxVerletHorizontalDisplace : b > this.m_control.maxVerletHorizontalDisplace && (b = this.m_control.maxVerletHorizontalDisplace);
    this.m_x += b;
    this.m_control.isJumpingUp() || (a = this.m_y - c + this.m_control.gravity * a * a, a < -this.m_control.maxVerletUpDisplace ? a = -this.m_control.maxVerletUpDisplace : a > this.m_control.maxVerletDownDisplace &&
        (a = this.m_control.maxVerletDownDisplace), this.m_y += a)
};
Player.prototype.resetControl = function() {
    null !== this.m_control && this.m_control.reset()
};
Player.prototype.resetMovement = function() {
    this.m_oldX = this.m_x;
    this.m_oldY = this.m_y
};
Player.prototype.toogleFreeMovement = function() {
    (this.m_isInvulnerable = this.m_freeMovement = !this.m_freeMovement) || this.resetControl();
    Application.log("FreeMove: " + this.m_freeMovement)
};
Player.prototype.toogleDebugCollision = function() {
    this.m_debugCollisionOn = !this.m_debugCollisionOn;
    Application.log("Player collision: " + this.m_debugCollisionOn)
};
Player.prototype.onEnemyCollision = function(a, b) {
    return !1
};
Player.prototype.onPlayerFellOutOfWorld = function() {};
Player.prototype.free = function() {
    null !== this.m_control && (this.m_control.free(), this.m_control = null);
    this.m_corners = null;
    WorldActor.prototype.free.call(this)
};

function PlayerControl(a, b) {
    this.debugSpeed = this.climbJumpUp = this.climbFactor = this.climbCornerSpeed = this.climbSpeed = 0;
    this.TIME_FALL = 75;
    this.TIME_LAND = 400;
    this.m_smallJumpTimer = 0;
    this.m_jumpAllowed = !1;
    this.m_floatingTimer = 0;
    this.m_horizontalBuffer = [0, 0];
    this.m_verticalBuffer = [0, 0];
    this.m_timeJumping = this.m_deltaHeight = 0;
    this.m_canDoubleJump = this.m_doubleJumpEnabled = !1;
    this.m_jumpDownTimer = this.m_doubleJumpSpeed = this.m_doubleJumpEnd = this.m_doubleJumpStart = this.m_smallJumpSpeed = this.m_smallJumpTime =
        this.m_jumpRunSpeed = this.m_jumpInitSpeed = this.m_jumpSpeed = 0;
    this.m_jumpDownAllowed = !1;
    this.m_jumpDownInterval = 0;
    this.m_isCatchEnemy = this.m_canJumpDown = !1;
    this.m_impulseY = this.m_impulseX = 0;
    this.m_wasImpulsed = !1;
    ActorControl.call(this, a);
    this.loadData(b);
    this.m_impulseX = 0
}
Application.subclass(PlayerControl, ActorControl);
PlayerControl.CMD_LEFT_A = Common.KEY_LEFT;
PlayerControl.CMD_LEFT_B = Common.KEY_A;
PlayerControl.CMD_RIGHT_A = Common.KEY_RIGHT;
PlayerControl.CMD_RIGHT_B = Common.KEY_D;
PlayerControl.CMD_UP_A = Common.KEY_UP;
PlayerControl.CMD_UP_B = Common.KEY_W;
PlayerControl.CMD_DOWN_A = Common.KEY_DOWN;
PlayerControl.CMD_DOWN_B = Common.KEY_S;
PlayerControl.CMD_CROSS = Common.KEY_X;
PlayerControl.CMD_CIRCLE = Common.KEY_Z;
PlayerControl.CMD_SQUARE = Common.KEY_C;
PlayerControl.CDM_TRIANGLE = Common.KEY_B;
PlayerControl.CMD_R1 = Common.KEY_V;
PlayerControl.CMD_R2 = Common.KEY_8;
PlayerControl.prototype.deltaHeight = function() {
    return this.m_deltaHeight
};
PlayerControl.prototype.isCatchEnemy = function() {
    return this.m_isCatchEnemy
};
PlayerControl.prototype.getWasImpulsed = function() {
    return this.m_wasImpulsed
};
PlayerControl.prototype.setWasImpulsed = function(a) {
    this.m_wasImpulsed = a
};
PlayerControl.prototype.horizontalBuffer = function() {
    return this.m_horizontalBuffer[0]
};
PlayerControl.prototype.verticalBuffer = function() {
    return this.m_verticalBuffer[0]
};
PlayerControl.prototype.forceX = function() {
    return this.m_isRunning ? this.runFactor * this.m_forceX : this.m_forceX
};
PlayerControl.prototype.onCompleteJump = function() {
    this.m_isJumping = !1;
    this.m_actor.gotoState(Player.ST_PLAYER_STAND)
};
PlayerControl.prototype.onActiveDash = function(a) {
    this.m_isRunning = !0
};
PlayerControl.prototype.activeDoubleJump = function(a) {
    this.m_canDoubleJump = this.m_doubleJumpEnabled = a
};
PlayerControl.prototype.loadData = function(a) {
    ActorControl.prototype.loadData.call(this, a);
    var b = PlayerSettings.instance.getPlayer() - 1;
    this.debugSpeed = this.getData(a, "debugSpeed");
    this.walkSpeed = this.getData(a, "walkSpeed");
    this.airSpeed = this.getData(a, "airSpeed");
    this.runFactor = this.getData(a, "runFactor");
    this.canClimb = 1 == this.getData(a, "canClimb");
    this.canRun = 1 == this.getData(a, "canRun");
    this.maxSpeedFloor = this.getData(a, "maxSpeedFloor");
    this.maxSpeedAir = this.getData(a, "maxSpeedAir");
    this.m_jumpSpeed = -window.config.players[b].jumpInitSpeed;
    this.m_jumpRunSpeed = -window.config.players[b].jumpRunInitSpeed;
    this.m_smallJumpTime = this.getData(a, "smallJumpTime");
    this.m_smallJumpSpeed = -this.getData(a, "smallJumpSpeed");
    this.m_doubleJumpStart = this.getData(a, "doubleJumpStart");
    this.m_doubleJumpEnd = this.getData(a, "doubleJumpEnd");
    this.m_doubleJumpSpeed = -window.config.players[b].doubleJumpSpeed;
    this.m_jumpDownInterval = this.getOptionalData(a, "jumpDownTime", -1);
    this.m_canJumpDown = 0 < this.m_jumpDownInterval;
    this.canClimb &&
        (this.climbFactor = 1 - this.getOptionalData(a, "climbFactor", .75), this.climbSpeed = -this.getOptionalData(a, "climbSpeed", .33), this.climbCornerSpeed = -this.getOptionalData(a, "climbCornerSpeed", .5), this.climbJumpUp = -this.getOptionalData(a, "climbJumpUp", 1.1))
};
PlayerControl.prototype.reset = function() {
    ActorControl.prototype.reset.call(this);
    this.m_horizontalBuffer[0] = 0;
    this.m_horizontalBuffer[1] = 0;
    this.m_verticalBuffer[0] = 0;
    this.m_timeJumping = this.m_deltaHeight = this.m_verticalBuffer[1] = 0;
    this.m_smallJumpTimer = -1;
    this.m_floatingTimer = this.TIME_FALL;
    this.m_jumpAllowed = !0;
    this.m_jumpDownTimer = -1;
    this.m_jumpDownAllowed = !0
};
PlayerControl.prototype.onCollision = function(a, b) {
    if (a) 0 > a.y && this.m_isJumping && (this.m_isJumping = this.m_isInAction = !1, this.m_actor.gotoState(Player.ST_PLAYER_LAND), this.m_floatingTimer = this.TIME_LAND), this.m_floatingTimer < this.TIME_FALL && (this.m_floatingTimer = this.TIME_FALL), null != this.m_actor.vehicle() && this.m_floatingTimer < this.TIME_LAND && (this.m_floatingTimer = this.TIME_LAND), 0 != a.y && (this.m_isJumpingUp = !1), this.m_wasImpulsed = !1;
    else {
        var c = this.m_actor.world().getTileBelow(this.m_actor.getX(),
            this.m_actor.getY());
        0 < this.m_floatingTimer && c !== WorldCollisionLayer.CELL_DIAG_UP_LEFT && c !== WorldCollisionLayer.CELL_DIAG_UP_RIGHT && c !== WorldCollisionLayer.CELL_MD_UP_LEFT && c !== WorldCollisionLayer.CELL_MD_UP_RIGHT && c !== WorldCollisionLayer.CELL_HMD_UP_LEFT && c !== WorldCollisionLayer.CELL_HMD_UP_RIGHT && (this.m_floatingTimer -= b, 0 >= this.m_floatingTimer && !this.m_isJumping && (this.m_actor.gotoState(Player.ST_PLAYER_JUMP_DOWN), this.m_isJumping = !0))
    }
};
PlayerControl.prototype.onLeft = function(a) {
    a ? (1 == this.m_horizontalBuffer[0] && (this.m_horizontalBuffer[1] = 1), this.m_horizontalBuffer[0] = -1) : (-1 == this.m_horizontalBuffer[0] && (this.m_horizontalBuffer[0] = this.m_horizontalBuffer[1]), this.m_horizontalBuffer[1] = 0)
};
PlayerControl.prototype.onRight = function(a) {
    a ? (-1 == this.m_horizontalBuffer[0] && (this.m_horizontalBuffer[1] = -1), this.m_horizontalBuffer[0] = 1) : (1 == this.m_horizontalBuffer[0] && (this.m_horizontalBuffer[0] = this.m_horizontalBuffer[1]), this.m_horizontalBuffer[1] = 0)
};
PlayerControl.prototype.onUp = function(a) {
    a ? (1 == this.m_verticalBuffer[0] && (this.m_verticalBuffer[1] = 1), this.m_verticalBuffer[0] = -1) : (-1 == this.m_verticalBuffer[0] && (this.m_verticalBuffer[0] = this.m_verticalBuffer[1]), this.m_verticalBuffer[1] = 0)
};
PlayerControl.prototype.onDown = function(a) {
    a ? (-1 == this.m_verticalBuffer[0] && (this.m_verticalBuffer[1] = -1), this.m_verticalBuffer[0] = 1) : (1 == this.m_verticalBuffer[0] && (this.m_verticalBuffer[0] = this.m_verticalBuffer[1]), this.m_verticalBuffer[1] = 0)
};
PlayerControl.prototype.onRun = function(a) {
    this.canRun && (this.m_isRunning = a)
};
PlayerControl.prototype.stopMovement = function() {
    this.m_horizontalBuffer = [0, 0];
    this.m_impulseX = this.m_forceX = 0;
    this.m_actor.m_speed.x = 0;
    this.m_actor.m_x = this.m_actor.m_oldX
};
PlayerControl.prototype.onCustomJump = function(a) {
    this.m_actor.gotoState(Player.ST_PLAYER_JUMP_UP);
    this.m_isJumpingUp = this.m_isJumping = !0;
    this.m_timeJumping = 0;
    this.m_smallJumpTimer = -1;
    this.m_jumpInitSpeed = a;
    this.m_canDoubleJump = !1
};
PlayerControl.prototype.onCustomJumpDirected = function(a, b) {
    this.m_actor.gotoState(Player.ST_PLAYER_JUMP_UP);
    this.m_isJumpingUp = this.m_isJumping = !0;
    this.m_timeJumping = 0;
    this.m_smallJumpTimer = -1;
    this.m_jumpInitSpeed = b;
    this.m_impulseX = a;
    this.m_wasImpulsed = this.m_canDoubleJump = !0
};
PlayerControl.prototype.onJumpDown = function(a) {
    this.m_canJumpDown && (a ? (this.m_jumpDownAllowed && !this.m_isJumping && this.m_actor.isOverPlatform() && (this.m_jumpDownAllowed = !1, this.m_isJumpingDown = !0, this.m_jumpDownTimer = this.m_jumpDownInterval, this.m_actor.gotoState(Player.ST_PLAYER_JUMP_DOWN)), this.m_jumpDownAllowed = !1) : this.m_jumpDownAllowed = !0)
};
PlayerControl.prototype.onJump = function(a) {
    a ? this.m_jumpAllowed && (this.m_isJumping ? this.m_canDoubleJump && this.m_timeJumping >= this.m_doubleJumpStart && this.m_timeJumping <= this.m_doubleJumpEnd && this.doDoubleJump() : (this.m_actor.gotoState(Player.ST_PLAYER_JUMP_UP), this.m_smallJumpTimer = this.m_smallJumpTime, this.m_isJumpingUp = this.m_isJumping = !0, this.m_jumpAllowed = !1, this.m_timeJumping = 0, this.m_canDoubleJump = this.m_doubleJumpEnabled, this.m_jumpInitSpeed = this.m_isRunning ? this.m_actor.factorSpeedY() * this.m_jumpRunSpeed :
        this.m_actor.factorSpeedY() * this.m_jumpSpeed)) : (this.m_isJumpingUp && 0 < this.m_smallJumpTimer && (this.m_jumpInitSpeed = this.m_smallJumpSpeed), this.m_jumpAllowed = !0)
};
PlayerControl.prototype.doDoubleJump = function() {
    this.m_actor.gotoState(Player.ST_PLAYER_JUMP_SPECIAL);
    this.m_smallJumpTimer = this.m_smallJumpTime;
    this.m_isJumpingUp = !0;
    this.m_canDoubleJump = this.m_jumpAllowed = !1;
    this.m_timeJumping = 0;
    this.m_jumpInitSpeed = this.m_doubleJumpSpeed
};
PlayerControl.prototype.onAction = function(a) {
    this.m_isInAction = a
};
PlayerControl.prototype.onCatchEnemy = function(a) {
    this.m_isCatchEnemy = a
};
PlayerControl.prototype.onDashAttack = function(a) {
    this.m_isInDashAttack = a
};
PlayerControl.prototype.resetJump = function() {
    this.m_isJumping = this.m_isInAction = !1;
    this.m_floatingTimer = this.TIME_LAND
};
PlayerControl.prototype.update = function(a) {
    0 < this.m_jumpDownTimer && (this.m_jumpDownTimer -= a, 0 >= this.m_jumpDownTimer && (this.m_isJumpingDown = !1));
    this.m_isJumping && (this.m_timeJumping += a, this.m_deltaHeight = this.m_jumpInitSpeed * a + 2 * this.gravity * this.m_timeJumping * a, 0 < this.m_deltaHeight && (this.m_isJumpingUp && (this.m_isJumpingUp = !1, this.m_actor.finishJumpUp()), this.m_deltaHeight = 0), 0 < this.m_smallJumpTimer && (this.m_smallJumpTimer -= a));
    this.m_forceX = 0 != this.m_horizontalBuffer[0] ? this.m_horizontalBuffer[0] :
        0 != this.m_horizontalBuffer[1] ? this.m_horizontalBuffer[1] : 0;
    this.m_forceY = 0 != this.m_verticalBuffer[0] ? this.m_verticalBuffer[0] : 0 != this.m_verticalBuffer[1] ? this.m_verticalBuffer[1] : 0;
    0 != this.m_impulseX && (this.m_forceX += this.m_impulseX, this.m_impulseX = 0)
};

function World(a, b) {
    this.playerInitY = this.playerInitX = 0;
    this.showCollisions = !1;
    this.cameraInitHeight = this.cameraInitWidth = this.cameraInitY = this.cameraInitX = this.cameraXMin = this.cameraXMax = this.cameraYMin = this.cameraYMax = this.cameraScreenY = this.cameraScreenX = this.cameraHeight = this.cameraWidth = 0;
    this.useEmbeddedAssets = !1;
    this.m_rangeTilesBelow = 0;
    this.m_game = b;
    this.m_layers = [];
    this.m_playerCanvas = null;
    this.m_objectsCanvas = [];
    this.m_player = null;
    this.m_layerNames = [];
    this.m_markers = this.m_collisions = null;
    this.m_pointY = this.m_pointX = this.m_height = this.m_width = 0;
    this.m_effectManager = this.m_worldData = this.m_actorManager = this.m_camera = null;
    this.canvasEffects = new window.PIXI.Container;
    this.canvas = a
}
World.prototype.game = function() {
    return this.m_game
};
World.prototype.setScale = function(a) {
    this.setScaleX(a);
    this.setScaleY(a)
};
World.prototype.setScaleX = function(a) {
    for (var b = 0; b < this.m_layers.length; b++) this.m_layers[b].setScaleX(a)
};
World.prototype.setScaleY = function(a) {
    for (var b = 0; b < this.m_layers.length; b++) this.m_layers[b].setScaleY(a)
};
World.prototype.setX = function(a) {
    for (var b = 0; b < this.m_layers.length; b++) this.m_layers[b].setX(a)
};
World.prototype.setY = function(a) {
    for (var b = 0; b < this.m_layers.length; b++) this.m_layers[b].setY(a)
};
World.prototype.objectCanvas = function() {
    return this.m_objectsCanvas[0]
};
World.prototype.player = function() {
    return this.m_player
};
World.prototype.camera = function() {
    return this.m_camera
};
World.prototype.width = function() {
    return this.m_width
};
World.prototype.height = function() {
    return this.m_height
};
World.prototype.tileWidth = function() {
    return this.m_collisions.tileWidth()
};
World.prototype.tileHeight = function() {
    return this.m_collisions.tileHeight()
};
World.prototype.actorManager = function() {
    return this.m_actorManager
};
World.prototype.getLayer = function(a) {
    return this.m_layerNames[a]
};
World.prototype.getPoint = function(a) {
    return this.m_markers.getPoint(a)
};
World.prototype.getZone = function(a) {
    return this.m_markers.getZone(a)
};
World.prototype.getCircle = function(a) {
    return this.m_markers.getCircle(a)
};
World.prototype.getSpawnPosition = function(a) {
    return this.m_markers.getSpawnPosition(a)
};
World.prototype.spawnPoints = function() {
    return this.m_markers.spawnPoints()
};
World.prototype.loadData = function(a, b) {
    this.m_worldData = window[a];
    var c = this.m_worldData.properties;
    this.m_width = this.getData(c, "width");
    this.m_height = this.getData(c, "height");
    this.showCollisions = 1 === this.getData(c, "showCollisions");
    Application.instance.isMobileDevice && (this.showCollisions = !1);
    this.playerInitX = this.getData(c, "playerX");
    this.playerInitY = this.getData(c, "playerY");
    this.cameraInitWidth = this.cameraWidth = this.getData(c, "cameraWidth");
    this.cameraInitHeight = this.cameraHeight = this.getData(c,
        "cameraHeight");
    0 >= this.cameraWidth && (this.cameraWidth = Application.APP_WIDTH);
    0 >= this.cameraHeight && (this.cameraHeight = Application.APP_HEIGHT);
    this.cameraScreenX = this.getData(c, "cameraScreenX");
    this.cameraScreenY = this.getData(c, "cameraScreenY");
    this.cameraYMax = this.getData(c, "cameraYMax");
    this.cameraYMin = this.getData(c, "cameraYMin");
    this.cameraXMax = this.getData(c, "cameraXMax");
    this.cameraXMin = this.getData(c, "cameraXMin");
    this.useEmbeddedAssets = this.getData(c, "useEmbeddedAssets");
    this.createCamera();
    this.createNpcManagers();
    this.createLayers()
};
World.prototype.createCamera = function() {
    this.m_camera = new Camera(this, this.cameraWidth, this.cameraHeight, this.cameraScreenX, this.cameraScreenY)
};
World.prototype.createNpcManagers = function() {};
World.prototype.addNpc = function(a, b) {
    var c = new Npc;
    c.id = a.id;
    c.x = a.x;
    c.y = a.y;
    c.canvas = b;
    c.params = a.params;
    this.m_actorManager.addNpc(c)
};
World.prototype.createLayers = function() {
    this.m_layerNames = [];
    for (var a = this.m_worldData.layerTypes, b = 0; b < a.length; b++) this.addLayer(a[b].type, a[b]);
    null === this.m_playerCanvas && (this.m_playerCanvas = this.m_objectsCanvas[0]);
    this.canvas.addChild(this.canvasEffects);
    this.m_worldData = null
};
World.prototype.addLayer = function(a, b) {
    if (a === WorldBaseLayer.ID_OBJECTS)
        if (0 <= b.name.indexOf("fx_")) {
            if (!Application.isLowDevice) {
                Application.log("Creating effect layer");
                var c = new WorldFxEnviromentLayer(this, b);
                this.m_layerNames[c.name()] = c;
                this.m_layers.push(c)
            }
        } else {
            c = Application.instance.addDisplayContainer();
            this.canvas.addChild(c);
            this.m_objectsCanvas.push(c);
            for (var d = 0; d < b.object.length; d++) this.addNpc(b.object[d], c)
        } else a === WorldBaseLayer.ID_SPRITES ? Application.isLowDevice || (Application.log("Creating sprite layer"),
        c = new WorldSpriteLayer(this, b), this.m_layerNames[c.name()] = c, this.m_layers.push(c)) : a === WorldBaseLayer.ID_MARKERS ? null === this.m_markers ? (this.m_markers = new WorldMarkerLayer(this, b), this.m_layers.push(this.m_markers)) : this.m_markers.loadData(b) : a === WorldBaseLayer.ID_PLAYER ? (this.m_playerCanvas = Application.instance.addDisplayContainer(), this.canvas.addChild(this.m_playerCanvas)) : a === WorldBaseLayer.ID_COLLISIONS ? (this.m_collisions = new WorldCollisionLayer(this, b), this.m_layerNames[this.m_collisions.name()] =
        this.m_collisions, this.m_layers.push(this.m_collisions), this.m_rangeTilesBelow = 2 * this.m_collisions.tileHeight()) : (c = new WorldTileLayer(this, b), this.m_layerNames[c.name()] = c, this.m_layers.push(c))
};
World.prototype.createEffect = function(a, b, c, d) {
    return Application.instance.effectManager.createEffect(a, b, c, this.canvasEffects, d)
};
World.prototype.createContainerEffect = function(a, b, c, d) {
    var e = Application.instance.addDisplayContainer();
    a = Application.instance.effectManager.createEffect(a, 0, 0, e, 1);
    this.canvasEffects.addChild(e);
    e.position.x = b;
    e.position.y = c;
    e.scale.x = d;
    e.scale.y = d;
    return a
};
World.prototype.init = function() {
    this.setX(this.m_camera.screenX);
    this.setY(this.m_camera.screenY);
    for (var a = 0; a < this.m_layers.length; a++) this.m_layers[a].init()
};
World.prototype.getTileBelow = function(a, b) {
    if (null !== this.m_collisions) return this.m_collisions.getTileBelow(a, b, this.m_rangeTilesBelow);
    Application.error("getTileBelow: no collisions");
    return WorldCollisionLayer.CELL_EMPTY
};
World.prototype.getFloorCollision = function(a, b) {
    if (null !== this.m_collisions) return this.m_collisions.getFloorCollision(a, b);
    Application.error("getFloorCollision: no collisions");
    return new Vector2D(a, b)
};
World.prototype.getMaxFloorRange = function(a, b, c) {
    if (null !== this.m_collisions) return "undefined" === typeof c && (c = World.MAX_SCAN_FLOOR), this.m_collisions.getMaxFloorRange(a, b, c);
    Application.error("getMaxFloorRange: no collisions");
    return new Rectangle(a, b)
};
World.prototype.getMaxFloorRangeElevations = function(a, b, c) {
    if (null !== this.m_collisions) return "undefined" === typeof c && (c = World.MAX_SCAN_FLOOR), this.m_collisions.getMaxFloorRangeElevations(a, b, c);
    Application.error("getMaxFloorRangeElevations: no collisions");
    return new Rectangle(a, b)
};
World.prototype.getRayCollision = function(a, b, c, d) {
    if (null !== this.m_collisions) return this.m_collisions.getRayCollision(a, b, c, d);
    Application.error("getRayCollision: no collisions");
    return null
};
World.prototype.onDebugDraw = function(a) {
    this.m_player.onDebugDraw(a);
    this.m_actorManager.onDebugDraw(a);
    this.m_camera.onDebugDraw(a);
    if (null !== this.m_markers) this.m_markers.onDebugDraw(a)
};
World.prototype.showCollision = function(a) {
    this.m_collisions.setVisible(a)
};
World.prototype.refreshCollision = function() {};
World.prototype.setCollisionCell = function(a, b, c) {
    this.m_collisions.setCell(a, b, c)
};
World.prototype.getTilePosition = function(a, b) {
    return this.m_collisions.getTilePosition(a, b)
};
World.prototype.setRangeCollisionCell = function(a, b, c, d, e, f) {
    for (; a <= c; a++)
        for (var g = b; g <= d; g++) this.setCollisionCell(a, g, e);
    f && this.refreshCollision()
};
World.prototype.getCellInPosition = function(a, b) {
    return this.m_collisions.getCellInPosition(a, b)
};
World.prototype.checkZones = function(a) {
    if (null !== this.m_markers)
        for (var b = this.m_markers.actionZones.length, c = 0; c < b; c++) {
            var d = this.m_markers.actionZones[c];
            d.intersectRect(a.getBounds()) ? d.active || (d.active = !0, a.onEnterZone(d)) : d.active && (d.active = !1, a.onLeaveZone(d))
        }
};
World.prototype.checkWorldBoundaries = function(a) {
    var b = null,
        b = a.bounds();
    null !== b && (a.limitLeft() && a.getX() + b.left < this.m_collisions.tileWidth() && a.setX(this.m_collisions.tileWidth() - b.left), a.limitRight() && a.getX() + b.right > this.m_width - this.m_collisions.tileWidth() && a.setX(this.m_width - this.m_collisions.tileWidth() - b.right), a.limitUp() && 0 >= a.getY() + b.top && a.setY(-b.top), a.limitBottom() && a.getY() + b.bottom >= this.m_height && a.setY(this.m_height - b.bottom))
};
World.prototype.checkCollision = function(a) {
    var b = new Vector2D(0, 0),
        c = a.corners();
    if (null !== c) {
        for (var d = !1, e = 0; e < c.length; e++)
            if (c[e]) {
                var f = c[e];
                this.m_pointX = ~~(a.getX() + f.position.x);
                this.m_pointY = ~~(a.getY() + f.position.y);
                var g = this.m_collisions.checkCollision(this.m_pointX, this.m_pointY, f.normal, a);
                g && (0 == b.x && 0 != g.x && (b.x += g.x), 0 == b.y && 0 != g.y && (b.y += g.y));
                !d && (g = this.m_collisions.checkPlatforms(this.m_pointX, this.m_pointY, f.normal, a)) && (d = !0, 0 == b.x && 0 != g.x && (b.x += g.x), 0 == b.y && 0 != g.y && (b.y +=
                    g.y));
                if (0 !== b.x && 0 !== b.y) break
            }
        return 0 !== b.y || 0 !== b.x ? b : null
    }
};
World.prototype.update = function(a) {
    var b = 0;
    this.m_actorManager.update(a);
    for (b = 0; b < this.m_layers.length; b++) this.m_layers[b].visible() && this.m_layers[b].render();
    this.canvasEffects.position.x = -this.m_camera.m_x;
    this.canvasEffects.position.y = -this.m_camera.m_y
};
World.prototype.addMobilePlatform = function(a) {
    this.m_collisions.addMobilePlatform(a)
};
World.prototype.getData = function(a, b) {
    if (null === a) Application.error("World:: data is null");
    else if (null === b) Application.error("World:: data is null: " + b);
    else {
        if ("undefined" !== typeof a[b]) return a[b];
        Application.error("Property not found: " + b)
    }
};
World.prototype.getOptionalData = function(a, b, c) {
    if ("undefined" === typeof a) Application.error("World:: data is undefined");
    else if ("undefined" === typeof b) Application.error("World:: data is undefined: " + b);
    else {
        if ("undefined" !== typeof a[b]) return a[b];
        Application.error("Optional property not found: " + b + " using: " + c);
        return c
    }
};
World.prototype.showPhysicZone = function(a, b, c, d, e) {};
World.prototype.free = function() {
    null !== this.m_player && (this.m_player.free(), this.m_player = null);
    this.m_actorManager.free();
    this.m_actorManager = null;
    this.m_playerCanvas !== this.m_objectsCanvas[0] && (this.canvas.removeChild(this.m_playerCanvas), this.m_playerCanvas = null);
    for (var a = this.m_objectsCanvas.length - 1; 0 <= a; a--) this.canvas.removeChild(this.m_objectsCanvas[a]);
    this.m_collisions = this.m_objectsCanvas = null;
    null !== this.m_markers && (this.m_markers.free(), this.m_markers = null);
    null !== this.m_camera && (this.m_camera.free(),
        this.m_camera = null);
    for (a = 0; a < this.m_layers.length; a++) this.m_layers[a].free(), this.m_layers[a] = null;
    this.m_layers = this.m_layerNames = null
};
World.MAX_SCAN_FLOOR = 750;

function WorldBaseLayer(a, b) {
    this.m_name = "";
    this.m_type = this.m_parallaxXFactor = this.m_y = this.m_x = this.m_height = this.m_width = 0;
    this.m_world = a;
    this.m_canvas = null;
    this.m_useEmbeddedAssets = !1;
    this.m_name = b.name;
    this.m_width = b.width || b.parallaxW;
    this.m_height = b.height || b.parallaxH;
    this.m_offsetX = 0;
    b.offsetX && (this.m_offsetX = b.offsetX);
    this.m_offsetY = 0;
    b.offsetY && (this.m_offsetY = b.offsetY);
    Application.log(" Layer: " + this.m_name + " w:" + this.m_width + " h:" + this.m_height + " ox:" + this.m_offsetX + " oy:" + this.m_offsetY);
    this.m_useEmbeddedAssets = this.m_world.useEmbeddedAssets;
    this.m_canvas = new window.PIXI.Container;
    a.canvas.addChild(this.m_canvas);
    this.m_type = 0
}
WorldBaseLayer.prototype.getX = function() {
    return this.m_x
};
WorldBaseLayer.prototype.getY = function() {
    return this.m_y
};
WorldBaseLayer.prototype.width = function() {
    return this.m_width
};
WorldBaseLayer.prototype.height = function() {
    return this.m_height
};
WorldBaseLayer.prototype.visible = function() {
    return !0
};
WorldBaseLayer.prototype.name = function() {
    return this.m_name
};
WorldBaseLayer.prototype.setX = function(a) {
    this.m_x = a
};
WorldBaseLayer.prototype.setY = function(a) {
    this.m_y = a
};
WorldBaseLayer.prototype.refresh = function() {};
WorldBaseLayer.prototype.init = function() {
    this.m_world.camera().parallaxX && (this.m_parallaxXFactor = (this.m_width - this.m_world.camera().width()) / (this.m_world.width() - this.m_world.camera().width()));
    this.m_world.camera().parallaxY && (this.m_parallaxYFactor = (this.m_height - this.m_world.camera().height()) / (this.m_world.height() - this.m_world.camera().height()));
    this.render()
};
WorldBaseLayer.prototype.render = function() {
    this.m_world.m_camera.parallaxX && (this.m_canvas.position.x = this.m_offsetX - this.parallaxX());
    this.m_world.m_camera.parallaxY && (this.m_canvas.position.y = this.m_offsetY - this.parallaxY())
};
WorldBaseLayer.prototype.parallaxX = function() {
    return ~~(this.m_world.m_camera.m_x * this.m_parallaxXFactor)
};
WorldBaseLayer.prototype.parallaxY = function() {
    return ~~(this.m_world.m_camera.m_y * this.m_parallaxYFactor)
};
WorldBaseLayer.prototype.free = function() {
    this.m_world && (this.m_world = this.m_canvas = null)
};
WorldBaseLayer.TYPE_COLLISIONS = 1;
WorldBaseLayer.TYPE_TILES = 2;
WorldBaseLayer.TYPE_SPRITES = 3;
WorldBaseLayer.TYPE_OBJECTS = 4;
WorldBaseLayer.TYPE_MARKERS = 5;
WorldBaseLayer.TYPE_BOX2D = 6;
WorldBaseLayer.ID_PLAYER = "player";
WorldBaseLayer.ID_COLLISIONS = "collision";
WorldBaseLayer.ID_TILES = "cell";
WorldBaseLayer.ID_SPRITES = "sprites";
WorldBaseLayer.ID_OBJECTS = "objects";
WorldBaseLayer.ID_MARKERS = "markers";
WorldBaseLayer.ID_BOX2D = "b2d";

function WorldTileLayer(a, b) {
    WorldBaseLayer.call(this, a, b);
    this.m_tileHeight = this.m_tileWidth = this.m_rows = this.m_columns = 0;
    this.m_tiles = null;
    this.m_maxY = this.m_maxX = this.m_minY = this.m_minX = 0;
    this.m_bitmapData = null;
    this.m_buffer = [];
    this.m_bufferY = this.m_bufferX = this.m_bufferHeight = this.m_bufferWidth = 0;
    this.m_type = WorldBaseLayer.ID_TILES;
    this.m_columns = b.cols;
    this.m_rows = b.rows;
    this.m_tileWidth = b.tileW;
    this.m_tileHeight = b.tileH;
    this.m_tiles = b.image;
    this.m_bitmapData = b.matrix;
    this.m_tempRow = this.m_tempCol =
        0
}
Application.subclass(WorldTileLayer, WorldBaseLayer);
WorldTileLayer.TILE_SCALE = .01;
WorldTileLayer.prototype.tileWidth = function() {
    return this.m_tileWidth
};
WorldTileLayer.prototype.tileHeight = function() {
    return this.m_tileHeight
};
WorldTileLayer.prototype.getTileName = function(a) {
    return 0 <= a && a < this.m_tiles.length ? this.m_tiles[a] : null
};
WorldTileLayer.prototype.getBufferCell = function(a, b) {
    return this.m_buffer[(a + this.m_bufferX) % this.m_bufferWidth + (b + this.m_bufferY) % this.m_bufferHeight * this.m_bufferWidth]
};
WorldTileLayer.prototype.setBufferCell = function(a, b, c) {
    this.m_buffer[(a + this.m_bufferX) % this.m_bufferWidth + (b + this.m_bufferY) % this.m_bufferHeight * this.m_bufferWidth] = c
};
WorldTileLayer.prototype.initCell = function(a, b) {
    var c = this.getCell(a + this.m_minX, b + this.m_minY);
    if (0 < c) {
        var d = null,
            d = PoolClips.instance.getClip(this.getTileName(c - 1));
        this.m_canvas.addChild(d);
        d.parent = this.m_canvas;
        d.setPosition((a + this.m_minX) * this.m_tileWidth, (b + this.m_minY) * this.m_tileHeight);
        d.setScale((1 + WorldTileLayer.TILE_SCALE / Layout.scale) * Application.DPI);
        this.setBufferCell(a, b, d)
    }
};
WorldTileLayer.prototype.refresh = function() {
    WorldBaseLayer.prototype.refresh.call(this);
    for (var a = this.m_bufferY = this.m_bufferX = 0; a < this.m_bufferWidth;) {
        for (var b = 0; b < this.m_bufferHeight;) {
            var c = this.m_buffer[a + b * this.m_bufferWidth];
            c && (this.m_canvas.removeChild(c), this.m_buffer[a + b * this.m_bufferWidth] = null);
            this.initCell(a, b);
            ++b
        }++a
    }
};
WorldTileLayer.prototype.init = function() {
    WorldBaseLayer.prototype.init.call(this);
    this.m_bufferWidth = Math.ceil(this.m_world.camera().width() * (Layout.maxAspectRatio / Layout.minAspectRatio) / this.m_tileWidth + 1);
    this.m_bufferHeight = Math.ceil(this.m_world.camera().height() / this.m_tileHeight + 1);
    this.m_bufferY = this.m_bufferX = 0;
    this.m_buffer = [];
    this.m_minX = ~~((this.m_world.camera().getX() + .5 * this.m_world.camera().width() * (1 - Layout.aspectRatio / Layout.minAspectRatio)) / this.m_tileWidth);
    0 > this.m_minX && (this.m_minX =
        0);
    this.m_maxX = this.m_minX + this.m_bufferWidth;
    this.m_minY = ~~(this.m_world.camera().getY() / this.m_tileHeight);
    0 > this.m_minY && (this.m_minY = 0);
    this.m_maxY = this.m_minY + this.m_bufferHeight;
    for (var a = 0; a < this.m_bufferWidth;) {
        for (var b = 0; b < this.m_bufferHeight;) this.initCell(a, b), ++b;
        ++a
    }
};
WorldTileLayer.prototype.getCellInPosition = function(a, b) {
    this.m_tempCol = ~~(a / this.m_tileWidth);
    this.m_tempRow = ~~(b / this.m_tileHeight);
    return 0 <= this.m_tempCol && 0 <= this.m_tempRow && this.m_tempCol < this.m_columns && this.m_tempRow < this.m_rows && this.m_bitmapData[this.m_tempCol] ? this.m_bitmapData[this.m_tempCol][this.m_tempRow] : 0
};
WorldTileLayer.prototype.getCell = function(a, b) {
    return 0 <= a && 0 <= b && a < this.m_columns && b < this.m_rows && this.m_bitmapData[a] ? this.m_bitmapData[a][b] : 0
};
WorldTileLayer.prototype.setCell = function(a, b, c) {
    0 <= a && 0 <= b && a < this.m_columns && b < this.m_rows && (this.m_bitmapData[a] || (this.m_bitmapData[a] = Common.createArraySize(this.m_rows, 0)), this.m_bitmapData[a][b] = c);
    return 0
};
WorldTileLayer.prototype.addTileCell = function(a, b, c, d) {
    var e = this.getCell(a, b);
    if (0 < e) {
        var f = null,
            f = PoolClips.instance.getClip(this.getTileName(e - 1));
        this.m_canvas.addChild(f);
        f.parent = this.m_canvas;
        f.setPosition(a * this.m_tileWidth, b * this.m_tileHeight);
        f.setScale((1 + WorldTileLayer.TILE_SCALE / Layout.scale) * Application.DPI);
        this.setBufferCell(c, d, f)
    }
};
WorldTileLayer.prototype.render = function() {
    var a = !1,
        b = 0,
        c = 0,
        d = 0,
        e = "bg" === this.m_name.substr(0, 2) ? -this.m_world.m_camera.fixOffsetX : 0;
    if (this.m_world.camera().parallaxX) {
        d = this.parallaxX();
        b = ~~((d + .5 * this.m_world.camera().width() * (1 - Layout.aspectRatio / Layout.minAspectRatio)) / this.m_tileWidth);
        c = b - this.m_minX;
        if (c <= -this.m_bufferWidth || c >= this.m_bufferWidth) a = !0;
        else if (b > this.m_minX) {
            for (var f = 0; f < c;) {
                for (var g = 0; g < this.m_bufferHeight;) {
                    var h = this.getBufferCell(f, g);
                    h && (PoolClips.instance.releaseClip(h),
                        this.setBufferCell(f, g, null));
                    this.addTileCell(f + this.m_maxX, g + this.m_minY, f, g);
                    ++g
                }++f
            }
            this.m_bufferX = (this.m_bufferX + c) % this.m_bufferWidth
        } else if (b < this.m_minX) {
            for (f = 1; f <= -c;) {
                for (g = 0; g < this.m_bufferHeight;) {
                    if (h = this.getBufferCell(this.m_bufferWidth - f, g)) PoolClips.instance.releaseClip(h), this.setBufferCell(this.m_bufferWidth - f, g, null);
                    this.addTileCell(this.m_minX - f, g + this.m_minY, this.m_bufferWidth - f, g);
                    ++g
                }++f
            }
            this.m_bufferX = (this.m_bufferWidth + this.m_bufferX + c) % this.m_bufferWidth
        }
        0 != c && (this.m_minX =
            b, this.m_maxX = this.m_minX + this.m_bufferWidth);
        this.m_canvas.position.x = this.m_offsetX - Math.floor(d) + e
    }
    if (this.m_world.camera().parallaxY) {
        d = this.parallaxY();
        b = ~~(d / this.m_tileHeight);
        c = b - this.m_minY;
        if (c <= -this.m_bufferHeight || c >= this.m_bufferHeight) a = !0;
        else if (b > this.m_minY) {
            for (g = 0; g < c;) {
                for (f = 0; f < this.m_bufferWidth;) {
                    if (h = this.getBufferCell(f, g)) PoolClips.instance.releaseClip(h), this.setBufferCell(f, g, null);
                    this.addTileCell(f + this.m_minX, g + this.m_maxY, f, g);
                    ++f
                }++g
            }
            this.m_bufferY = (this.m_bufferY +
                c) % this.m_bufferHeight
        } else if (b < this.m_minY) {
            for (g = 1; g <= -c;) {
                for (f = 0; f < this.m_bufferWidth;) {
                    if (h = this.getBufferCell(f, this.m_bufferHeight - g)) PoolClips.instance.releaseClip(h), this.setBufferCell(f, this.m_bufferHeight - g, null);
                    this.addTileCell(f + this.m_minX, this.m_minY - g, f, this.m_bufferHeight - g);
                    ++f
                }++g
            }
            this.m_bufferY = (this.m_bufferHeight + this.m_bufferY + c) % this.m_bufferHeight
        }
        0 != c && (this.m_minY = b, this.m_maxY = this.m_minY + this.m_bufferHeight);
        this.m_canvas.position.y = this.m_offsetY - Math.floor(d)
    }
    a && this.refresh()
};
WorldTileLayer.prototype.free = function() {
    for (var a = 0; a < this.m_bufferWidth;) {
        for (var b = 0; b < this.m_bufferHeight;) {
            var c = this.m_buffer[a + b * this.m_bufferWidth];
            c && PoolClips.instance.releaseClip(c);
            ++b
        }++a
    }
    WorldBaseLayer.prototype.free.call(this)
};

function WorldCollisionLayer(a, b) {
    this.m_tileY = this.m_tileX = 0;
    this.m_platforms = this.m_frames = null;
    this.m_sw0 = this.m_dy = this.m_dx = this.m_number = 0;
    WorldTileLayer.call(this, a, b);
    this.m_type = WorldBaseLayer.TYPE_COLLISIONS;
    this.m_frames = [];
    for (var c = WorldCollisionLayer.CELL_EMPTY; c <= WorldCollisionLayer.CELL_HALF_HORIZONTAL;) this.m_frames.push(WorldCollisionLayer.COLLISION_SET + c), ++c;
    this.m_platforms = [];
    this.setVisible(!1)
}
Application.subclass(WorldCollisionLayer, WorldTileLayer);
WorldCollisionLayer.prototype.setX = function(a) {
    this.m_x = a
};
WorldCollisionLayer.prototype.setY = function(a) {
    this.m_y = a
};
WorldCollisionLayer.prototype.name = function() {
    return this.m_name
};
WorldCollisionLayer.prototype.tileHeight = function() {
    return this.m_tileHeight
};
WorldCollisionLayer.prototype.addMobilePlatform = function(a) {
    this.m_platforms.push(a)
};
WorldCollisionLayer.prototype.checkPlatforms = function(a, b, c, d) {
    d.setVehicle(null);
    if (0 < c.y && 0 < d.speed().y && !d.control().isJumpingDown())
        for (c = 0; c < this.m_platforms.length;) {
            if (this.m_platforms[c].isVehicle()) {
                var e = this.m_platforms[c].getX(),
                    f = this.m_platforms[c].bounds().x,
                    g = this.m_platforms[c].getY(),
                    h = this.m_platforms[c].bounds().y;
                if (a <= e + f + this.m_platforms[c].bounds().w && a >= e + f && b >= g + h && b <= g + h + this.m_platforms[c].bounds().h) return d.setVehicle(this.m_platforms[c]), new Vector2D(0, g + h - b)
            }++c
        }
    return null
};
WorldCollisionLayer.prototype.setVisible = function(a) {
    a ? this.m_world.canvas.addChild(this.m_canvas) : this.m_world.canvas.removeChild(this.m_canvas)
};
WorldCollisionLayer.prototype.checkCollision = function(a, b, c, d) {
    this.m_tileX = ~~(a / this.m_tileWidth);
    this.m_tileY = ~~(b / this.m_tileHeight);
    this.m_dy = this.m_dx = 0;
    this.m_sw0 = this.getCell(this.m_tileX, this.m_tileY);
    switch (this.m_sw0) {
        case WorldCollisionLayer.CELL_PLATFORM:
            if (0 < c.y && !d.control().isJumpingUp() && !d.control().isJumpingDown()) {
                if (0 < c.x && this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_DIAG_UP_LEFT) return this.m_dy = a - this.m_tileX * this.m_tileWidth, new Vector2D(0, this.m_tileY *
                    this.m_tileHeight - b - this.m_dy);
                if (0 > c.x && this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_DIAG_UP_RIGHT) return this.m_dy = (this.m_tileX + 1) * this.m_tileWidth - a, new Vector2D(0, this.m_tileY * this.m_tileHeight - b - this.m_dy);
                if (0 < d.speed().y && this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_EMPTY && (d.speed().y >= WorldCollisionLayer.MAX_VY_SPEED_PLATFORM || b - this.m_tileY * this.m_tileHeight <= .5 * this.m_tileHeight)) return new Vector2D(0, this.m_tileY * this.m_tileHeight - b)
            }
            break;
        case WorldCollisionLayer.CELL_HALF_HORIZONTAL:
            if (0 < c.y && !d.control().isJumpingUp() && (this.m_dy = b - (this.m_tileY + .5) * this.m_tileWidth, 0 < this.m_dy)) return new Vector2D(0, -this.m_dy);
            break;
        case WorldCollisionLayer.CELL_DIAG_UP_RIGHT:
            if (0 < c.y && !d.control().isJumpingUp() && (this.m_dx = a - this.m_tileX * this.m_tileWidth, this.m_dy = b - this.m_tileY * this.m_tileWidth, this.m_dx < this.m_dy && 0 >= c.x)) {
                if (0 === d.control().forceX()) return new Vector2D(0, this.m_dx - this.m_dy);
                this.m_dx = .5 * (this.m_dy - this.m_dx);
                this.m_number =
                    d.control().slopeFriction * this.m_dx;
                return new Vector2D(this.m_dx + this.m_number, -this.m_dx + this.m_number)
            }
            break;
        case WorldCollisionLayer.CELL_HMD_UP_RIGHT:
            if (0 < c.y && !d.control().isJumpingUp() && (this.m_dx = a - this.m_tileX * this.m_tileWidth, this.m_dy = b - this.m_tileY * this.m_tileWidth, this.m_dx < 2 * this.m_dy)) return new Vector2D(0, -b + (.5 * this.m_dx + this.m_tileY * this.m_tileWidth));
            break;
        case WorldCollisionLayer.CELL_MD_UP_RIGHT:
            if (0 < c.y && !d.control().isJumpingUp() && (this.m_dx = a - this.m_tileX * this.m_tileWidth,
                    this.m_dy = b - (this.m_tileY + .5) * this.m_tileWidth, this.m_dx < 2 * this.m_dy)) return new Vector2D(0, -b + (.5 * this.m_dx + (this.m_tileY + .5) * this.m_tileWidth));
            break;
        case WorldCollisionLayer.CELL_DIAG_UP_LEFT:
            if (0 < c.y && !d.control().isJumpingUp() && (this.m_dx = (this.m_tileX + 1) * this.m_tileWidth - a, this.m_dy = b - this.m_tileY * this.m_tileWidth, this.m_dx < this.m_dy && 0 <= c.x)) {
                if (0 === d.control().forceX()) return new Vector2D(0, this.m_dx - this.m_dy);
                this.m_dx = .5 * (this.m_dy - this.m_dx);
                this.m_number = d.control().slopeFriction * this.m_dx;
                return new Vector2D(-this.m_dx - this.m_number, -this.m_dx + this.m_number)
            }
            break;
        case WorldCollisionLayer.CELL_HMD_UP_LEFT:
            var e = .52;
            if (0 < c.y && !d.control().isJumpingUp() && (this.m_dx = -a + this.m_tileWidth * (this.m_tileX + 1), this.m_dy = b - (this.m_tileY - (e - .5)) * this.m_tileWidth, this.m_dx * e < this.m_dy)) return new Vector2D(0, -b + (e * this.m_dx + (this.m_tileY - (e - .5)) * this.m_tileWidth));
            break;
        case WorldCollisionLayer.CELL_MD_UP_LEFT:
            var e = .52,
                f = 1 - e;
            if (0 < c.y && !d.control().isJumpingUp() && (this.m_dx = -a + this.m_tileWidth * (this.m_tileX +
                    1), this.m_dy = b - (this.m_tileY + f) * this.m_tileWidth, this.m_dx * e < this.m_dy)) return new Vector2D(0, -b + (e * this.m_dx + (this.m_tileY + f) * this.m_tileWidth));
            break;
        case WorldCollisionLayer.CELL_FULL:
            if (0 === c.x) return 0 < c.y ? new Vector2D(0, this.m_tileY * this.m_tileHeight - b) : new Vector2D(0, (this.m_tileY + 1) * this.m_tileHeight - b);
            if (0 === c.y)
                if (d.speed().y >= WorldCollisionLayer.MIN_VY_FRICTION && d.setFallingOverWall(!0), 0 < c.x) {
                    if (this.getCell(this.m_tileX - 1, this.m_tileY) === WorldCollisionLayer.CELL_EMPTY) return new Vector2D(this.m_tileX *
                        this.m_tileWidth - a, 0)
                } else {
                    if (this.getCell(this.m_tileX + 1, this.m_tileY) === WorldCollisionLayer.CELL_EMPTY) return new Vector2D((this.m_tileX + 1) * this.m_tileWidth - a, 0)
                } else if (0 < c.y) {
                if (this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_MD_UP_LEFT) return this.m_dx = 0, this.m_dy = this.m_tileY * this.m_tileHeight - .5 * (a - this.m_tileX * this.m_tileWidth) - b, new Vector2D(this.m_dx, this.m_dy);
                if (this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_MD_UP_RIGHT) return this.m_dx = 0, this.m_dy =
                    this.m_tileY * this.m_tileHeight - .5 * this.m_tileHeight - -.5 * (a - this.m_tileX * this.m_tileWidth) - b, new Vector2D(this.m_dx, this.m_dy);
                if (this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_HMD_UP_LEFT) return this.m_dx = 0, this.m_dy = this.m_tileY * this.m_tileHeight - .5 * (a - this.m_tileX * this.m_tileWidth) - b, new Vector2D(this.m_dx, this.m_dy);
                if (this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_HMD_UP_RIGHT) return this.m_dx = 0, this.m_dy = this.m_tileY * this.m_tileHeight - .5 * this.m_tileHeight -
                    -.5 * (a - this.m_tileX * this.m_tileWidth) - b, new Vector2D(this.m_dx, this.m_dy);
                if (this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_HALF_HORIZONTAL && (this.m_dx = 0, this.m_dy = b - (this.m_tileY + .5) * this.m_tileWidth, 0 < this.m_dy)) return new Vector2D(0, -this.m_dy);
                if (0 < c.x) {
                    if (this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_DIAG_UP_LEFT) {
                        if (this.getCell(this.m_tileX - 1, this.m_tileY) === WorldCollisionLayer.CELL_DIAG_UP_LEFT) {
                            this.m_dx = a - this.m_tileX * this.m_tileWidth;
                            this.m_dx +=
                                b - this.m_tileY * this.m_tileHeight;
                            if (0 === d.control().forceX()) return new Vector2D(0, -this.m_dx);
                            this.m_dx /= 2;
                            this.m_number = d.control().slopeFriction * this.m_dx;
                            return new Vector2D(-this.m_dx - this.m_number, -this.m_dx + this.m_number)
                        }
                        this.m_dy = a - this.m_tileX * this.m_tileWidth;
                        return new Vector2D(0, this.m_tileY * this.m_tileHeight - b - this.m_dy)
                    }
                    if (this.getCell(this.m_tileX - 1, this.m_tileY) === WorldCollisionLayer.CELL_DIAG_UP_LEFT) {
                        if (this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_FULL) return this.m_dx =
                            a - this.m_tileX * this.m_tileWidth, this.m_dx = .5 * (this.m_dx + b - this.m_tileY * this.m_tileHeight), this.m_number = -this.m_dx - d.control().slopeFriction * this.m_dx, a + this.m_number > this.m_tileX * this.m_tileWidth ? new Vector2D(-a + this.m_tileX * this.m_tileWidth, -b + this.m_tileY * this.m_tileHeight) : new Vector2D(this.m_number, -this.m_dx + d.control().slopeFriction * this.m_dx);
                        if (this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_EMPTY) return this.m_dx = a - this.m_tileX * this.m_tileWidth, this.m_dx = .5 * (this.m_dx +
                            b - this.m_tileY * this.m_tileHeight), this.m_number = -this.m_dx - d.control().slopeFriction * this.m_dx, a + this.m_number > this.m_tileX * this.m_tileWidth || 0 === d.control().forceX() ? new Vector2D(0, -b + this.m_tileY * this.m_tileHeight) : new Vector2D(this.m_number, -this.m_dx + d.control().slopeFriction * this.m_dx)
                    } else {
                        if (this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_FULL) {
                            if (this.getCell(this.m_tileX - 1, this.m_tileY) === WorldCollisionLayer.CELL_FULL) return new Vector2D(this.m_tileX * this.m_tileWidth -
                                a, this.m_tileY * this.m_tileHeight - b);
                            d.speed().y >= WorldCollisionLayer.MIN_VY_FRICTION && d.setFallingOverWall(!0);
                            return new Vector2D(this.m_tileX * this.m_tileWidth - a, 0)
                        }
                        return this.getCell(this.m_tileX - 1, this.m_tileY) === WorldCollisionLayer.CELL_FULL ? new Vector2D(0, this.m_tileY * this.m_tileHeight - b) : b - this.m_tileY * this.m_tileHeight > a - this.m_tileX * this.m_tileWidth ? (d.speed().y >= WorldCollisionLayer.MIN_VY_FRICTION && d.setFallingOverWall(!0), new Vector2D(this.m_tileX * this.m_tileWidth - a, 0)) : new Vector2D(0,
                            this.m_tileY * this.m_tileHeight - b)
                    }
                } else {
                    if (this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_DIAG_UP_RIGHT) {
                        if (this.getCell(this.m_tileX + 1, this.m_tileY) === WorldCollisionLayer.CELL_DIAG_UP_RIGHT) {
                            this.m_dx = (this.m_tileX + 1) * this.m_tileWidth - a;
                            this.m_dx += b - this.m_tileY * this.m_tileHeight;
                            if (0 === d.control().forceX()) return new Vector2D(0, -this.m_dx);
                            this.m_dx /= 2;
                            this.m_number = d.control().slopeFriction * this.m_dx;
                            return new Vector2D(this.m_dx + this.m_number, -this.m_dx + this.m_number)
                        }
                        this.m_dy =
                            (this.m_tileX + 1) * this.m_tileWidth - a;
                        return new Vector2D(0, this.m_tileY * this.m_tileHeight - b - this.m_dy)
                    }
                    if (this.getCell(this.m_tileX + 1, this.m_tileY) === WorldCollisionLayer.CELL_DIAG_UP_RIGHT) {
                        if (this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_FULL) return this.m_dx = (this.m_tileX + 1) * this.m_tileWidth - a, this.m_dx = .5 * (this.m_dx + b - this.m_tileY * this.m_tileHeight), this.m_number = this.m_dx + d.control().slopeFriction * this.m_dx, a + this.m_number < (this.m_tileX + 1) * this.m_tileWidth ? new Vector2D((this.m_tileX +
                            1) * this.m_tileWidth - a, -b + this.m_tileY * this.m_tileHeight) : new Vector2D(this.m_number, -this.m_dx + d.control().slopeFriction * this.m_dx);
                        if (this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_EMPTY) return this.m_dx = (this.m_tileX + 1) * this.m_tileWidth - a, this.m_dx = .5 * (this.m_dx + b - this.m_tileY * this.m_tileHeight), this.m_number = this.m_dx + d.control().slopeFriction * this.m_dx, a + this.m_number < (this.m_tileX + 1) * this.m_tileWidth || 0 === d.control().forceX() ? new Vector2D(0, -b + this.m_tileY * this.m_tileHeight) :
                            new Vector2D(this.m_number, -this.m_dx + d.control().slopeFriction * this.m_dx)
                    } else {
                        if (this.getCell(this.m_tileX, this.m_tileY - 1) === WorldCollisionLayer.CELL_FULL) {
                            if (this.getCell(this.m_tileX + 1, this.m_tileY) === WorldCollisionLayer.CELL_FULL) return new Vector2D((this.m_tileX + 1) * this.m_tileWidth - a, this.m_tileY * this.m_tileHeight - b);
                            d.speed().y >= WorldCollisionLayer.MIN_VY_FRICTION && d.setFallingOverWall(!0);
                            return new Vector2D((this.m_tileX + 1) * this.m_tileWidth - a, 0)
                        }
                        return this.getCell(this.m_tileX + 1, this.m_tileY) ===
                            WorldCollisionLayer.CELL_FULL ? new Vector2D(0, this.m_tileY * this.m_tileHeight - b) : b - this.m_tileY * this.m_tileHeight > (this.m_tileX + 1) * this.m_tileWidth - a ? (d.speed().y >= WorldCollisionLayer.MIN_VY_FRICTION && d.setFallingOverWall(!0), new Vector2D((this.m_tileX + 1) * this.m_tileWidth - a, 0)) : new Vector2D(0, this.m_tileY * this.m_tileHeight - b)
                    }
                }
            } else {
                if (0 < c.x) {
                    if (this.getCell(this.m_tileX, this.m_tileY + 1) === WorldCollisionLayer.CELL_FULL) {
                        if (this.getCell(this.m_tileX - 1, this.m_tileY) === WorldCollisionLayer.CELL_FULL) return new Vector2D(this.m_tileX *
                            this.m_tileWidth - a, (this.m_tileY + 1) * this.m_tileHeight - b);
                        d.speed().y >= WorldCollisionLayer.MIN_VY_FRICTION && d.setFallingOverWall(!0);
                        return new Vector2D(this.m_tileX * this.m_tileWidth - a, 0)
                    }
                    return this.getCell(this.m_tileX - 1, this.m_tileY) === WorldCollisionLayer.CELL_FULL ? new Vector2D(0, (this.m_tileY + 1) * this.m_tileHeight - b) : (this.m_tileY + 1) * this.m_tileHeight - b > a - this.m_tileX * this.m_tileWidth ? (d.setFallingOverWall(!0), new Vector2D(this.m_tileX * this.m_tileWidth - a, 0)) : new Vector2D(0, (this.m_tileY + 1) * this.m_tileHeight -
                        b)
                }
                if (this.getCell(this.m_tileX, this.m_tileY + 1) === WorldCollisionLayer.CELL_FULL) {
                    if (this.getCell(this.m_tileX + 1, this.m_tileY) === WorldCollisionLayer.CELL_FULL) return new Vector2D((this.m_tileX + 1) * this.m_tileWidth - a, (this.m_tileY + 1) * this.m_tileHeight - b);
                    d.speed().y >= WorldCollisionLayer.MIN_VY_FRICTION && d.setFallingOverWall(!0);
                    return new Vector2D((this.m_tileX + 1) * this.m_tileWidth - a, 0)
                }
                return this.getCell(this.m_tileX + 1, this.m_tileY) === WorldCollisionLayer.CELL_FULL ? new Vector2D(0, (this.m_tileY + 1) * this.m_tileHeight -
                    b) : (this.m_tileY + 1) * this.m_tileHeight - b > (this.m_tileX + 1) * this.m_tileWidth - a ? (d.speed().y >= WorldCollisionLayer.MIN_VY_FRICTION && d.setFallingOverWall(!0), new Vector2D((this.m_tileX + 1) * this.m_tileWidth - a, 0)) : new Vector2D(0, (this.m_tileY + 1) * this.m_tileHeight - b)
            }
    }
    return null
};
WorldCollisionLayer.prototype.getMaxFloorRange = function(a, b, c) {
    for (var d = ~~(b / this.m_tileHeight), e = ~~(a / this.m_tileWidth); d < this.m_height;) {
        if (this.getCell(e, d) != WorldCollisionLayer.CELL_EMPTY) {
            for (b = e - 1; this.getCell(b, d) != WorldCollisionLayer.CELL_EMPTY && this.getCell(b, d - 1) === WorldCollisionLayer.CELL_EMPTY && !(a - --b * this.m_tileWidth >= c););
            var f = (b + 1) * this.m_tileWidth;
            for (b = e + 1; this.getCell(b, d) != WorldCollisionLayer.CELL_EMPTY && this.getCell(b, d - 1) === WorldCollisionLayer.CELL_EMPTY && !(++b * this.m_tileWidth -
                    a >= c););
            return new Rectangle(f, d * this.m_tileHeight, b * this.m_tileWidth - f)
        }++d
    }
    Application.warn("getMaxFloorRange: no floor found at x:" + a + " y:" + b);
    return new Rectangle(a, b, 0)
};
WorldCollisionLayer.prototype.getMaxFloorRangeElevations = function(a, b, c) {
    for (var d = ~~(b / this.m_tileHeight), e = ~~(a / this.m_tileWidth); d < this.m_height;) {
        var f = this.getCell(e, d);
        if (f != WorldCollisionLayer.CELL_EMPTY) {
            b = ~~((a - c) / this.m_tileWidth);
            var g = !0,
                h = e,
                k = d;
            do {
                switch (f) {
                    case WorldCollisionLayer.CELL_FULL:
                    case WorldCollisionLayer.CELL_PLATFORM:
                        switch (this.getCell(h - 1, k)) {
                            case WorldCollisionLayer.CELL_EMPTY:
                                g = !1;
                                break;
                            default:
                                switch (this.getCell(h - 1, k - 1)) {
                                    case WorldCollisionLayer.CELL_FULL:
                                        g = !1;
                                        break;
                                    case WorldCollisionLayer.CELL_DIAG_UP_RIGHT:
                                        --k
                                }
                        }
                        break;
                    case WorldCollisionLayer.CELL_DIAG_UP_LEFT:
                        switch (this.getCell(h - 1, k + 1)) {
                            case WorldCollisionLayer.CELL_EMPTY:
                                g = !1;
                                break;
                            default:
                                ++k
                        }
                        break;
                    case WorldCollisionLayer.CELL_DIAG_UP_RIGHT:
                        switch (this.getCell(h - 1, k - 1)) {
                            case WorldCollisionLayer.CELL_EMPTY:
                                this.getCell(h - 1, k) === WorldCollisionLayer.CELL_EMPTY && (g = !1);
                                break;
                            case WorldCollisionLayer.CELL_FULL:
                                g = !1;
                                break;
                            case WorldCollisionLayer.CELL_DIAG_UP_RIGHT:
                                --k
                        }
                        break;
                    case WorldCollisionLayer.CELL_EMPTY:
                        g = !1
                }
                f = this.getCell(--h, k)
            } while (g && h >= b);
            var m = (h + 1) * this.m_tileWidth,
                l = k * this.m_tileHeight,
                g = !0;
            b = ~~((a + c) / this.m_tileWidth);
            ++b;
            h = e;
            k = d;
            f = this.getCell(e, d);
            do {
                switch (f) {
                    case WorldCollisionLayer.CELL_FULL:
                    case WorldCollisionLayer.CELL_PLATFORM:
                        switch (this.getCell(h + 1, k)) {
                            case WorldCollisionLayer.CELL_EMPTY:
                                g = !1;
                                break;
                            default:
                                switch (this.getCell(h + 1, k - 1)) {
                                    case WorldCollisionLayer.CELL_FULL:
                                        g = !1;
                                        break;
                                    case WorldCollisionLayer.CELL_DIAG_UP_LEFT:
                                        --k
                                }
                        }
                        break;
                    case WorldCollisionLayer.CELL_DIAG_UP_LEFT:
                        switch (this.getCell(h +
                            1, k - 1)) {
                            case WorldCollisionLayer.CELL_EMPTY:
                                this.getCell(h + 1, k) === WorldCollisionLayer.CELL_EMPTY && (g = !1);
                                break;
                            case WorldCollisionLayer.CELL_FULL:
                                g = !1;
                                break;
                            case WorldCollisionLayer.CELL_DIAG_UP_LEFT:
                                --k
                        }
                        break;
                    case WorldCollisionLayer.CELL_DIAG_UP_RIGHT:
                        switch (this.getCell(h + 1, k + 1)) {
                            case WorldCollisionLayer.CELL_EMPTY:
                                g = !1;
                                break;
                            default:
                                ++k
                        }
                        break;
                    case WorldCollisionLayer.CELL_EMPTY:
                        g = !1
                }
                f = this.getCell(++h, k)
            } while (g && h <= b);
            return new Rectangle(m, l, h * this.m_tileWidth - m, k * this.m_tileHeight - l)
        }++d
    }
    Application.warn("getMaxFloorRange: no floor found at x:" +
        a + " y:" + b);
    return new Rectangle(a, b, 0)
};
WorldCollisionLayer.prototype.getFloorCollision = function(a, b) {
    for (var c = ~~(b / this.m_tileHeight), d = ~~(a / this.m_tileWidth); c < this.m_height;) {
        var e = this.getCell(d, c);
        if (e != WorldCollisionLayer.CELL_EMPTY) {
            switch (e) {
                case WorldCollisionLayer.CELL_DIAG_UP_LEFT:
                case WorldCollisionLayer.CELL_DIAG_UP_RIGHT:
                    switch (e) {
                        case WorldCollisionLayer.CELL_DIAG_UP_LEFT:
                            return new Vector2D(a, c * this.m_tileHeight + (d + 1) * this.m_tileWidth - a)
                    }
                    return new Vector2D(a, c * this.m_tileHeight + a - d * this.m_tileWidth)
            }
            return new Vector2D(a,
                c * this.m_tileHeight)
        }++c
    }
    Application.warn("getFloorCollision: no floor found");
    return new Vector2D(a, b)
};
WorldCollisionLayer.prototype.getTilePosition = function(a, b) {
    return new Point(~~(a / this.m_tileWidth), ~~(b / this.m_tileHeight))
};
WorldCollisionLayer.prototype.getTileBelow = function(a, b, c) {
    var d = 0;
    for (a = ~~(a / this.m_tileWidth); d <= c;) {
        var e = this.getCell(a, ~~(b / this.m_tileHeight));
        if (e != WorldCollisionLayer.CELL_EMPTY) return e;
        b += this.m_tileHeight;
        d += this.m_tileHeight
    }
    return WorldCollisionLayer.CELL_EMPTY
};
WorldCollisionLayer.prototype.getRayCollision = function(a, b, c, d) {
    b = ~~(b / this.m_tileHeight);
    for (c = ~~(a / this.m_tileWidth); b < this.m_height;) {
        if (this.getCell(c, b) != WorldCollisionLayer.CELL_EMPTY) return new Vector2D(a, b * this.m_tileHeight);
        ++b
    }
    return null
};
WorldCollisionLayer.prototype.addTileCell = function(a, b, c, d) {};
WorldCollisionLayer.prototype.initCell = function(a, b) {};
WorldCollisionLayer.prototype.parallaxX = function() {
    return this.m_world.camera().getX()
};
WorldCollisionLayer.prototype.parallaxY = function() {
    return this.m_world.camera().getY()
};
WorldCollisionLayer.prototype.render = function() {
    this.m_world.showCollisions && WorldTileLayer.prototype.render.call(this)
};
WorldCollisionLayer.CELL_EMPTY = 0;
WorldCollisionLayer.CELL_FULL = 1;
WorldCollisionLayer.CELL_DIAG_UP_LEFT = 2;
WorldCollisionLayer.CELL_DIAG_UP_RIGHT = 3;
WorldCollisionLayer.CELL_DIAG_DOWN_RIGHT = 4;
WorldCollisionLayer.CELL_DIAG_DOWN_LEFT = 5;
WorldCollisionLayer.CELL_PLATFORM = 6;
WorldCollisionLayer.CELL_FULL_ICE = 7;
WorldCollisionLayer.CELL_FULL_WATER = 8;
WorldCollisionLayer.CELL_FULL_SAND = 9;
WorldCollisionLayer.CELL_MD_UP_LEFT = 10;
WorldCollisionLayer.CELL_MD_UP_RIGHT = 11;
WorldCollisionLayer.CELL_HMD_UP_LEFT = 12;
WorldCollisionLayer.CELL_HMD_UP_RIGHT = 13;
WorldCollisionLayer.CELL_HALF_HORIZONTAL = 14;
WorldCollisionLayer.COLLISION_SET = "coll_";
WorldCollisionLayer.MIN_VY_FRICTION = -2;
WorldCollisionLayer.MAX_VY_SPEED_PLATFORM = -2;

function PhysicZone(a, b, c, d, e, f) {
    Rectangle.call(this, b - d / 2, c - e / 2, d, e);
    this.type = 0;
    this.active = !1;
    this.params = Common.getParams(f);
    switch (a) {
        case PhysicZone.ID_CLIMB:
            this.type = PhysicZone.CLIMB;
            break;
        case PhysicZone.ID_CAMERA:
            this.type = PhysicZone.CAMERA;
            break;
        case PhysicZone.ID_FLUID:
            this.type = PhysicZone.FLUID;
            break;
        case PhysicZone.ID_FORCE:
            this.type = PhysicZone.FORCE;
            break;
        case PhysicZone.ID_FRICTION:
            this.type = PhysicZone.FRICTION;
            break;
        default:
            Application.error("Invalid physic zone")
    }
}
Application.subclass(PhysicZone, Rectangle);
PhysicZone.CLIMB = 1;
PhysicZone.FLUID = 2;
PhysicZone.FORCE = 3;
PhysicZone.FRICTION = 4;
PhysicZone.CAMERA = 5;
PhysicZone.ID_CLIMB = "climb";
PhysicZone.ID_FLUID = "fluid";
PhysicZone.ID_FORCE = "force";
PhysicZone.ID_CAMERA = "camera";
PhysicZone.ID_FRICTION = "friction";

function WorldMarkerLayer(a, b) {
    WorldBaseLayer.call(this, a, b);
    this.m_width = a.width();
    this.m_height = a.height();
    this.m_type = WorldBaseLayer.TYPE_MARKERS;
    this.actionZones = [];
    this.loadData(b)
}
Application.subclass(WorldMarkerLayer, WorldBaseLayer);
WorldMarkerLayer.ID_PHYSICS = "physics";
WorldMarkerLayer.prototype.loadData = function(a) {
    var b = 0,
        b = a.rectangle.length;
    if (this.m_name == WorldMarkerLayer.ID_PHYSICS)
        for (var c = 0; c < b;) {
            var d = new PhysicZone(a.rectangle[c].type, a.rectangle[c].x, a.rectangle[c].y, a.rectangle[c].w, a.rectangle[c].h, null == a.rectangle[c].params ? "" : a.rectangle[c].params);
            this.actionZones.push(d);
            ++c
        }
};
WorldMarkerLayer.prototype.onDebugDraw = function(a) {
    for (var b = 0; b < this.actionZones.length; b++) ContextGraphics.drawRectangle(a, this.actionZones[b].x, this.actionZones[b].y, this.actionZones[b].w, this.actionZones[b].h, 2, Common.COLOR_YELLOW, Common.COLOR_NONE)
};
WorldMarkerLayer.prototype.render = function() {
    this.m_world.showCollisions && WorldBaseLayer.prototype.render.call(this)
};
WorldMarkerLayer.prototype.free = function() {
    var a = 0;
    if (this.actionZones) {
        for (; a < this.actionZones.length;) this.actionZones[a] = null, ++a;
        this.actionZones = null
    }
    WorldBaseLayer.prototype.free.call(this)
};

function WorldSpriteLayer(a, b) {
    WorldBaseLayer.call(this, a, b);
    this.m_type = WorldBaseLayer.TYPE_SPRITES;
    for (var c = b.image.length, d = 0; d < c;) {
        var e = Application.instance.getClip(b.image[d].image);
        b.image[d].sx && (e.scale.x = b.image[d].sx);
        b.image[d].sy && (e.scale.y = b.image[d].sy);
        e.setPosition(b.image[d].x, b.image[d].y);
        b.image[d].rot && (e.rotation = b.image[d].rot);
        if (b.image[d].blend) {
            var f = b.image[d].blend;
            2 == f ? e.blendMode = PIXI.BLEND_MODES.ADD : 3 == f && (e.blendMode = PIXI.BLEND_MODES.MULTIPLY)
        }
        this.m_canvas.addChild(e);
        ++d
    }
}
Application.subclass(WorldSpriteLayer, WorldBaseLayer);

function WorldFxEnviromentLayer(a, b) {
    WorldBaseLayer.call(this, a, b);
    for (var c = b.object.length, d = 0, e = null; d < c;) e = new window.PIXI.Container, e.position.x = b.object[d].x, e.position.y = b.object[d].y, e.scale.x = b.object[d].sx || 1, e.scale.y = b.object[d].sy || 1, e.rotation = b.object[d].rot || 0, this.m_canvas.addChild(e), Application.instance.effectManager.createEffect(b.object[d].name, 0, 0, e), ++d
}
Application.subclass(WorldFxEnviromentLayer, WorldBaseLayer);

function Global() {}
Global.baseScale = 1;
Global.minScale = 1;
Global.maxScale = 1;
Global.offsetZoomX = 0;
Global.offsetZoomY = 0;
Global.data = null;
Global.screenCapture = null;
Global.PLAYER_1 = 1;
Global.PLAYER_2 = 2;
Global.TYPE_DEFAULT = 4;
Global.TYPE_AT_DP = 0;
Global.TYPE_AT_MP = 1;
Global.TYPE_AT_AT = 2;
Global.TYPE_AT_PT = 3;
Global.TYPE_PACHINKO = 4;
Global.nameRobot = Global.TYPE_AT_DP;
Global.debugRobot = -1;
Global.viewInitCutscene = 0;
Global.game = null;
Global.level = 1;
Global.mission = 1;
Global.playerSelected = 1;
Global.playersForGame = [];
Global.totalStars = 0;
Global.totalEnemiesByLevel = 0;
Global.onHalfTime = !1;
Global.showAds = !1;
Global.comingFromTutorial = !1;

function Cheats() {}
Cheats.enabled = Application.USE_CHEATS;
Cheats.EVENT_ON_WIN = "onWin";
Cheats.EVENT_ON_LOSE = "onLose";
Cheats.EVENT_ON_ADDLIFE = "addLife";
Cheats.EVENT_ON_TOGGLE_COLLISION = "toggleCollision";
Cheats.EVENT_DISABLE_GHOSTING = "disableGhosting";
Cheats.EVENT_PICK_ALL_ITEMS = "pickAll";
Cheats.EVENT_SET_COLLECTMISSION = "setCollectMissionByDefault";
Cheats.EVENT_FLY = "toggleFreeMovement";
Cheats.UNLOCK_ALL = "unlockAllPlanets";
Cheats.ERASE_DATA = "deleteData";
Cheats.TOGGLE_AS_MOBILE_DEVICE = "toggleAsMobileDevice";
Cheats.events = [Cheats.EVENT_ON_TOGGLE_COLLISION, Cheats.EVENT_ON_WIN, Cheats.EVENT_ON_LOSE, Cheats.EVENT_ON_ADDLIFE, Cheats.EVENT_DISABLE_GHOSTING, Cheats.EVENT_PICK_ALL_ITEMS, Cheats.EVENT_SET_COLLECTMISSION, Cheats.EVENT_FLY, Cheats.UNLOCK_ALL, Cheats.ERASE_DATA, Cheats.TOGGLE_AS_MOBILE_DEVICE];
Cheats.onEvent = function(a) {
    if (Cheats.enabled) {
        switch (a) {
            case Cheats.EVENT_ON_WIN:
                if (Global.game) Global.game.world.player().onWin(!1);
                break;
            case Cheats.EVENT_ON_LOSE:
                Global.game && Global.game.world.player().lose(!1);
                break;
            case Cheats.EVENT_ON_TOGGLE_COLLISION:
                Application.instance.stage.toggleCollision();
                Global.game && Global.game.toggleDebugCollision && Global.game.toggleDebugCollision();
                break;
            case Cheats.EVENT_DISABLE_GHOSTING:
                GhostingManager.instance.isDisabled = !0;
                break;
            case Cheats.EVENT_PICK_ALL_ITEMS:
                PlayerSettings.instance.m_itemsInHand =
                    PlayerSettings.instance.m_itemsRemaining;
                PlayerSettings.instance.m_itemsRemaining = 0;
                GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_RETURN_EXTRACTION;
                HudPlatform.instance.addPopup(GuiPopupMessage, "mcGuiPopupDialogue");
                break;
            case Cheats.EVENT_SET_COLLECTMISSION:
                MissionManager.instance.m_missionType = MissionManager.MISSION_COLLECTION;
                break;
            case Cheats.EVENT_FLY:
                Global.game.world.player().toogleFreeMovement();
                break;
            case Cheats.UNLOCK_ALL:
                Global.data.data.unlockPlanets = [1, 1, 1];
                Global.data.save();
                GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_LOCATION);
                break;
            case Cheats.ERASE_DATA:
                Global.data.resetAllData();
                Global.data.save();
                break;
            case Cheats.TOGGLE_AS_MOBILE_DEVICE:
                Application.instance.isMobileDevice = !Application.instance.isMobileDevice
        }
        Application.info("[CHEAT] " + a)
    }
};
Cheats.prototype.update = function(a) {};
Cheats.onKeyUp = function(a) {
    if (Cheats.enabled && !window.USE_SANBOX_NANO) switch (a) {
        case Common.KEY_UP:
            Global.game.world.player().m_control.onUp(!1)
    }
};
Cheats.onKeyDown = function(a) {
    if (Cheats.enabled && !window.USE_SANBOX_NANO) switch (a) {
        case Common.KEY_UP:
            Global.game.world.player().m_control.onUp(!0);
            break;
        case Common.KEY_W:
            Cheats.onEvent(Cheats.EVENT_ON_WIN);
            break;
        case Common.KEY_L:
            Cheats.onEvent(Cheats.EVENT_ON_LOSE);
            break;
        case Common.KEY_S:
            PoolClips.instance.stats();
            break;
        case Common.KEY_I:
            Global.game && Global.game.world.player().collectAllItems();
            break;
        case Common.KEY_1:
            Cheats.onEvent(Cheats.EVENT_ON_TOGGLE_COLLISION);
            break;
        case Common.KEY_2:
            switch (Global.level) {
                case 1:
                    Atdp.instance &&
                        (Atdp.instance.health = 1);
                    break;
                case 2:
                    HeadAtat.instance && (HeadAtat.instance.health = 1);
                    break;
                case 3:
                    TIEFighter.instance && (TIEFighter.instance.health = 1)
            }
            break;
        case Common.KEY_3:
            Global.game && (Global.game.world.player().meeleStikeBullets = 10);
            Global.game.world.player().activatePowerUp(ItemWorld.TYPE_PU_STRIKEWAVE, 3E10);
            break;
        case Common.KEY_4:
            Application.instance.stopSound("SND_BG_LIBERATION");
            Application.instance.stopSound("SND_BG_SABOTAGE");
            Application.instance.stopSound("SND_BG_TUTORIAL");
            Application.instance.stopSound("SND_BG_BOSS");
            Application.instance.stopSound("SND_BG_GAME");
            Application.instance.stopSound("SND_BG_CONQUER_ALARM");
            break;
        case Common.KEY_5:
            Global.game.world.player().toogleFreeMovement();
            break;
        case Common.KEY_6:
            Global.data.data.starsSingle = [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1];
            Global.data.data.starsMulti = [3, 3, 3, -1, 3, 3, 3, 3, 3, 3, 3, -1];
            break;
        case Common.KEY_7:
            GuiGame.instance.addAchievPopup(3);
            GuiGame.instance.addAchievPopup(2);
            GuiGame.instance.addAchievPopup(1);
            GuiGame.instance.addAchievPopup(4);
            GuiGame.instance.addAchievPopup(5);
            GuiGame.instance.addAchievPopup(6);
            GuiGame.instance.addAchievPopup(7);
            GuiGame.instance.addAchievPopup(8);
            GuiGame.instance.addAchievPopup(9);
            break;
        case Common.KEY_8:
            Cheats.onEvent(Cheats.TOGGLE_AS_MOBILE_DEVICE);
            break;
        case Common.KEY_9:
            Cheats.onEvent(Cheats.UNLOCK_ALL);
            break;
        case Common.KEY_0:
            Cheats.onEvent(Cheats.ERASE_DATA)
    }
};

function Settings(a) {
    Settings.instance = this;
    var b = 0;
    this.m_dtMissions = {};
    a = a.missions;
    for (b = a.length - 1; 0 <= b; --b) this.m_dtMissions[a[b].idMission] = new DataMission(a[b])
}
Settings.instance = null;
Settings.prototype.getMission = function(a) {
    var b = this.m_dtMissions[a];
    "undefined" === typeof b && (Application.error("Settings.getMission ---\x3e Invalid level name " + a), b = null);
    return b
};

function DataManager() {
    this.id = "sw_491_1.0";
    this.idDataArcade = "sw_491_1.0_arcade";
    this.dataArcade = this.data = null;
    try {
        this.data = JSON.parse(window.localStorage.getItem(this.id)), this.dataArcade = JSON.parse(window.localStorage.getItem(this.idDataArcade))
    } catch (a) {
        Application.error("CAN'T [LOAD] LOCAL STORAGE")
    }
    this.data && this.data.version != DataManager.gameVersion && this.resetAllData();
    this.data || this.resetAllData();
    this.dataArcade && this.dataArcade.version != DataManager.gameVersion && this.resetAllArcadeData();
    this.dataArcade || this.resetAllArcadeData();
    this.save()
}
DataManager.prototype.save = function() {
    try {
        window.localStorage.setItem(this.id, JSON.stringify(this.data)), window.localStorage.setItem(this.idDataArcade, JSON.stringify(this.dataArcade))
    } catch (a) {
        Application.error("CAN'T [SAVE] LOCAL STORAGE")
    }
};
DataManager.prototype.resetAllData = function() {
    this.data = {};
    this.data.version = DataManager.gameVersion;
    this.data.lastName = "AAA";
    this.data.lastSavedScore = 0;
    this.data.myBestScore = 0;
    this.data.lastVSPlanet = 1;
    this.data.lastPlayedDay = Math.floor(Date.now() / ScoreAPI.ONE_DAY_MS);
    this.data.starsSingle = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    this.data.starsMulti = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    this.data.usedCharacters = [0, 0, 0, 0, 0, 0];
    this.data.usedPowerups = [0, 0, 0, 0];
    this.data.unlockPlanets = [0, 0, 0];
    this.data.tutorial =
        0;
    this.data.shouldSpawnTokens = !0;
    this.data.grabbedToken = !1
};
DataManager.prototype.resetAllArcadeData = function() {
    this.dataArcade = {};
    this.dataArcade.version = DataManager.gameVersion;
    this.dataArcade.coins = 0;
    this.dataArcade.trophies = {};
    this.dataArcade.trophies.trophy1 = {};
    this.dataArcade.trophies.trophy1.name = "Rebel Cell";
    this.dataArcade.trophies.trophy1.description = "Complete 4 missions in multiplayer.";
    this.dataArcade.trophies.trophy1.achieved = !1;
    this.dataArcade.trophies.trophy1.url = "media/images/ui_images/trophy1.png";
    this.dataArcade.trophies.trophy2 = {};
    this.dataArcade.trophies.trophy2.name =
        "Ghost Crew";
    this.dataArcade.trophies.trophy2.description = "Use all characters.";
    this.dataArcade.trophies.trophy2.achieved = !1;
    this.dataArcade.trophies.trophy2.url = "media/images/ui_images/trophy2.png";
    this.dataArcade.trophies.trophy3 = {};
    this.dataArcade.trophies.trophy3.name = "Just Scrap Metal";
    this.dataArcade.trophies.trophy3.description = "Defeat all the Bosses.";
    this.dataArcade.trophies.trophy3.achieved = !1;
    this.dataArcade.trophies.trophy3.url = "media/images/ui_images/trophy3.png";
    this.dataArcade.trophies.trophy4 = {};
    this.dataArcade.trophies.trophy4.name = "Weapons Specialist";
    this.dataArcade.trophies.trophy4.description = "Use all the special power ups.";
    this.dataArcade.trophies.trophy4.achieved = !1;
    this.dataArcade.trophies.trophy4.url = "media/images/ui_images/trophy4.png";
    this.dataArcade.trophies.trophy5 = {};
    this.dataArcade.trophies.trophy5.name = "Cool Headed";
    this.dataArcade.trophies.trophy5.description = "Obtain 3 stars in the final mission in single player or co-op.";
    this.dataArcade.trophies.trophy5.achieved = !1;
    this.dataArcade.trophies.trophy5.url = "media/images/ui_images/trophy5.png";
    this.dataArcade.trophies.trophy6 = {};
    this.dataArcade.trophies.trophy6.name = "Spark of the Rebellion";
    this.dataArcade.trophies.trophy6.description = "Finish all the missions from one planet with 3 stars in single player or co-op.";
    this.dataArcade.trophies.trophy6.achieved = !1;
    this.dataArcade.trophies.trophy6.url = "media/images/ui_images/trophy6.png";
    this.dataArcade.trophies.trophy7 = {};
    this.dataArcade.trophies.trophy7.name = "Teamwork";
    this.dataArcade.trophies.trophy7.description = "Beat all Co-op missions.";
    this.dataArcade.trophies.trophy7.achieved = !1;
    this.dataArcade.trophies.trophy7.url = "media/images/ui_images/trophy7.png";
    this.dataArcade.trophies.trophy8 = {};
    this.dataArcade.trophies.trophy8.name = "Trust Your Instincts";
    this.dataArcade.trophies.trophy8.description = "Defeat a boss without losing health.";
    this.dataArcade.trophies.trophy8.achieved = !1;
    this.dataArcade.trophies.trophy8.url = "media/images/ui_images/trophy8.png";
    this.dataArcade.trophies.trophy9 = {};
    this.dataArcade.trophies.trophy9.name = "Special Operations";
    this.dataArcade.trophies.trophy9.description = "Finish all the missions with 3 stars.";
    this.dataArcade.trophies.trophy9.achieved = !1;
    this.dataArcade.trophies.trophy9.url = "media/images/ui_images/trophy9.png"
};
DataManager.gameVersion = 18;

function ScrollHandler() {
    this.tweenScroll = null;
    this.maxIndex = this.index = 0;
    this.duration = 2E3;
    this.displaceY = this.displaceX = this.y = this.x = 0;
    this.m_onStartCaller = this.m_onStart = this.m_onCompleteCaller = this.m_onComplete = this.m_onUpdateCaller = this.m_onUpdate = null
}
ScrollHandler.prototype.goto = function(a) {
    this.tweenScroll = (new Tween(this)).to({
        x: this.displaceX * a,
        y: this.displaceY * a
    }, this.duration).easing(TweenEasing.BackOut).onUpdate(this.tweenUpdate).onComplete(this.tweenComplete);
    this.tweenScroll.start();
    this.index = a;
    this.m_onStart && this.m_onStart.call(this.m_onStartCaller, this)
};
ScrollHandler.prototype.setIndex = function(a) {
    this.index = a;
    this.x = this.index * this.displaceX;
    this.y = this.index * this.displaceY
};
ScrollHandler.prototype.addStartListener = function(a, b) {
    this.m_onStart = b;
    this.m_onStartCaller = a
};
ScrollHandler.prototype.addUpdateListener = function(a, b) {
    this.m_onUpdate = b;
    this.m_onUpdateCaller = a
};
ScrollHandler.prototype.addCompleteListener = function(a, b) {
    this.m_onComplete = b;
    this.m_onCompleteCaller = a
};
ScrollHandler.prototype.cancel = function() {
    this.tweenScroll && (TweenManager.instance.remove(this.tweenScroll), this.tweenScroll = null)
};
ScrollHandler.prototype.next = function() {
    this.tweenScroll || this.index >= this.maxIndex || this.goto(this.index + 1)
};
ScrollHandler.prototype.lastNext = function() {
    this.tweenScroll || this.goto(this.maxIndex)
};
ScrollHandler.prototype.lastBack = function() {
    this.tweenScroll || this.goto(0)
};
ScrollHandler.prototype.back = function() {
    this.tweenScroll || 0 >= this.index || this.goto(this.index - 1)
};
ScrollHandler.prototype.tweenUpdate = function(a) {
    this.m_onUpdate && this.m_onUpdate.call(this.m_onUpdateCaller, this)
};
ScrollHandler.prototype.tweenComplete = function(a) {
    this.m_onComplete && this.m_onComplete.call(this.m_onCompleteCaller, this);
    this.tweenScroll = null
};

function GuiLoader(a, b, c, d, e, f, g) {
    g && (b = b.concat(g), g = null);
    SLoaderScreen.call(this, a, b, c, d, e, f, g);
    GuiLoader.instance = this;
    this.m_logo = null;
    this.isLoaded = !1;
    this.initLocalizedSprites();
    this.preload || (Application.RENDER_MODE !== Application.RENDER_WEBGL || Application.isLowDevice || (this.hyperSpaceBkg = new SpaceBackground(this.canvas), 0 !== this.start ? (this.hyperSpaceBkg.setProgress(100), this.hyperSpaceBkg.isContinuation = !0, this.hyperSpaceBkg.lightSpeedFilter.setIntensity(1)) : this.hyperSpaceBkg.setProgress(this.start)),
        this.circleLoader = new CircleLoader(this.canvas, this), this.circleLoader.setProgress(this.start))
}
Application.subclass(GuiLoader, SLoaderScreen);
GuiLoader.instance = null;
GuiLoader.prototype.initLocalizedSprites = function() {
    this.controls.mcGuiLogo && (this.m_logo = Application.instance.getLocalizedImage("gui_localized_logo.png"), this.controls.mcGuiLogo.clip.addChild(this.m_logo), this.m_logo.pivot.x = 435, this.m_logo.pivot.y = 72, this.m_logo.position.x = 0, this.m_logo.position.y = 0)
};
GuiLoader.prototype.free = function() {
    this.mcGuiLoaderFill = this.txtLoading = null;
    this.hyperSpaceBkg && this.hyperSpaceBkg.free();
    this.circleLoader = this.hyperSpaceBkg = null;
    SLoaderScreen.prototype.free.call(this)
};
GuiLoader.prototype.load = function() {
    SLoaderScreen.prototype.load.call(this);
    var a = this.start,
        a = a + this.loadedfiles / this.totalFiles * (this.end - this.start),
        a = parseInt(a, 10);
    Application.info("onLoadProgress > " + this.loadedfiles + " of " + this.totalFiles + " percent : " + a + "%");
    this.progress = a
};
GuiLoader.prototype.update = function(a) {
    !this.preload && GuiMainMenu.doneFirstLoader && !Application.instance.isPlayingSound("SND_BG_MAINMENU") && Application.instance.isSoundOn() && Application.instance.playSound("SND_BG_MAINMENU");
    SLoaderScreen.prototype.update.call(this, a);
    var b = this.start,
        b = b + this.loadedfiles / this.totalFiles * (this.end - this.start),
        b = parseInt(b, 10);
    this.circleLoader && this.circleLoader.buttonLoader.texture.baseTexture.hasLoaded && this.circleLoader && this.circleLoader.setProgress(b);
    this.hyperSpaceBkg &&
        (this.hyperSpaceBkg.setProgress(b), this.hyperSpaceBkg.update(a))
};
GuiLoader.prototype.onLoadComplete = function() {
    this.isLoaded = !0;
    this.hyperSpaceBkg && this.hyperSpaceBkg.setProgress(this.end);
    this.circleLoader && this.circleLoader.setProgress(this.end);
    if (this.preload) Application.instance.onLoaderReady();
    else if (Application.instance.isMobileDevice && null != this.jsonFiles)
        if (GuiMainMenu.doneFirstLoader) this.hyperSpaceBkg ? 100 === this.end ? this.hyperSpaceBkg.lightSpeedFilter.leaveLightSpeed(this, this.onStop) : GuiManager.instance.gotoScreen(this.gotoScreen) : GuiManager.instance.gotoScreen(this.gotoScreen);
        else {
            if (this.btnNext && (this.circleLoader.free(), this.circleLoader = null, this.btnNext.clip.visible = !0, this.hyperSpaceBkg)) {
                var a = this.canvas.addChild(this.btnNext.clip);
                a.position.x = this.btnNext.canvas.position.x;
                a.position.y = this.btnNext.canvas.position.y
            }
        } else this.hyperSpaceBkg ? 100 === this.end ? this.hyperSpaceBkg.lightSpeedFilter.leaveLightSpeed(this, this.onStop) : GuiManager.instance.gotoScreen(this.gotoScreen) : GuiManager.instance.gotoScreen(this.gotoScreen)
};
GuiLoader.prototype.onStop = function() {
    GuiManager.instance.gotoScreen(this.gotoScreen)
};

function CircleLoader(a, b) {
    this.canvas = a;
    this.inlineCircleBlack = Application.instance.getSpriteFromUrl("media/images/ui_images/inline_circle_loader_button.png");
    this.inlineCircleBlack.position.x = .5 * Application.APP_WIDTH - 49;
    this.inlineCircleBlack.position.y = .5 * Application.APP_HEIGHT - 49;
    this.inlineCircleBlack.tint = 0;
    this.circleMask = new CircleMask(100);
    this.circleMask.scale.x *= -1;
    this.circleMask.position.x = .5 * Application.APP_WIDTH;
    this.circleMask.position.y = .5 * Application.APP_HEIGHT;
    this.inlineCircle =
        Application.instance.getSpriteFromUrl("media/images/ui_images/inline_circle_loader_button.png");
    this.inlineCircle.position.x = this.inlineCircleBlack.position.x;
    this.inlineCircle.position.y = this.inlineCircleBlack.position.y;
    this.inlineCircle.mask = this.circleMask;
    this.screenText = b.getControl("mcGuiPercent");
    this.buttonLoader = Application.instance.getSpriteFromUrl("media/images/ui_images/gui_screens_loader_poller.png");
    this.buttonLoader.position.x = .5 * Application.APP_WIDTH - 69.5;
    this.buttonLoader.position.y =
        .5 * Application.APP_HEIGHT - 69.5;
    this.loadingLocalized = Application.instance.getLocalizedImage("gui_localized_loader.png");
    this.loadingLocalized.position.x = .5 * Application.APP_WIDTH - 450;
    this.loadingLocalized.position.y = .5 * Application.APP_HEIGHT + 50;
    this.canvas.addChild(this.buttonLoader);
    this.canvas.addChild(this.loadingLocalized);
    this.canvas.addChild(this.inlineCircleBlack);
    this.canvas.addChild(this.circleMask);
    this.canvas.addChild(this.inlineCircle);
    this.screenText && (this.canvas.addChild(this.screenText.canvas),
        this.screenText.setTextEmpty())
}
CircleLoader.prototype.free = function() {
    this.canvas.removeChild(this.buttonLoader);
    this.canvas.removeChild(this.loadingLocalized);
    this.canvas.removeChild(this.inlineCircleBlack);
    this.canvas.removeChild(this.circleMask);
    this.canvas.removeChild(this.inlineCircle);
    this.screenText && this.canvas.removeChild(this.screenText.canvas);
    this.screenText = this.inlineCircle = this.circleMask = this.inlineCircleBlack = this.loadingLocalized = this.buttonLoader = null
};
CircleLoader.prototype.setProgress = function(a) {
    this.circleMask.setRatio(a / 100 + .02, !1);
    this.screenText && 0 < a && this.screenText.setText(Math.floor(a))
};

function SpaceBackground(a) {
    var b = Layout.aspectRatio / Layout.minAspectRatio * Application.APP_WIDTH,
        c = b - Application.APP_WIDTH;
    this.backGround = new window.PIXI.Sprite;
    this.backGround.width = 3 * b;
    this.backGround.height = Application.APP_HEIGHT;
    a.addChild(this.backGround);
    this.easedProgress = this.progress = 0;
    this.lightSpeedFilter = new LightSpeedFilter(0);
    this.backGround.filters = [this.lightSpeedFilter];
    this.backGround.position.x = 4 * -c;
    this.isContinuation = !1
}
SpaceBackground.prototype.free = function() {
    this.lightSpeedFilter = null;
    this.backGround.filters = null
};
SpaceBackground.prototype.setProgress = function(a) {
    this.progress = a
};
SpaceBackground.prototype.update = function(a) {
    var b = Layout.aspectRatio / Layout.minAspectRatio * Application.APP_WIDTH - Application.APP_WIDTH,
        c = .2 * (this.progress - this.easedProgress);.01 < c && (c = .01);
    this.easedProgress += 2 * c;
    c = this.easeInOutExpo(100 * this.easedProgress, 0, 1, 60);
    isNaN(c) && (c = this.easedProgress = 0);
    this.isContinuation && (c = 1);
    this.lightSpeedFilter.setIntensity(c);
    this.lightSpeedFilter.update(a);
    this.backGround.position.x = 4 * -b;
    this.backGround.width = 10 * Layout.width;
    this.backGround.height = 10 * Layout.height;
    this.backGround.position.y = .5 * -this.backGround.height
};
SpaceBackground.prototype.easeInOutExpo = function(a, b, c, d) {
    a /= d / 2;
    if (1 > a) return c / 2 * Math.pow(2, 10 * (a - 1)) + b;
    a--;
    return c / 2 * (-Math.pow(2, -10 * a) + 2) + b
};

function LightSpeedFilter(a) {
    this.uniforms = {
        intensity: {
            type: "f",
            value: 0
        },
        starPositionOffset: {
            type: "f",
            value: 0
        },
        scale: {
            type: "f",
            value: 1
        },
        offset: {
            type: "2fv",
            value: [a, 0]
        },
        dimensions: {
            type: "4fv",
            value: [100, 100, 0, 0]
        }
    };
    this.tween = null;
    this.speed = 1;
    window.PIXI.AbstractFilter.call(this, null, "precision highp float;\nvarying vec2 vTextureCoord;\n uniform sampler2D uSampler;\nuniform float intensity;\n uniform float starPositionOffset;\n uniform vec2 offset;\n uniform vec4 dimensions;\n uniform float scale;\n\n float rand(float n){\n       return fract(sin(n) * 43758.5453123);\n}\n\nvec4 mapStar(vec2 position, float intensity, float angleOffset) {\n\n      vec4 color = vec4(vec3(0.), 1.);\n\n      float angle = atan(position.y, position.x) + angleOffset;\n\n      float angleNumber = 20.;\n\n      float random = rand(floor(angle * angleNumber) * 100.);\n\n      float distance = random;\n      distance += starPositionOffset * .001;\n      distance = fract(distance);\n\n      float fragDistance = length(position);\n\n      float size = smoothstep(-.1, 2., intensity);\n\n      float bounded = step(distance, fragDistance) * step(fragDistance, distance + size);\n      bounded += step(fragDistance, fract(distance + size)) * step(fract(distance + size), distance);\n\n      color.rgb = mix(vec3(0.), vec3(1.), bounded);\n\n      color.r *= .3;\n      color.g *= .7 + random * .3;\n      color.b *= 2.;\n\n      // hard edges\n      float angleCenter = abs(fract(angle * angleNumber) * 2. - 1.);\n      color.a = step(angleCenter, smoothstep(-.2, 1., intensity));\n\n      // smooth gradient\n      color.a *= 1. - angleCenter;\n\n      color.a *= smoothstep(0., 1., fragDistance);\n      color.a *= cos(pow(random, 5.) * starPositionOffset * .001) * .5 + .5;\n\n      return color;\n}\n\nvoid main() {\n    vec2 position = (vTextureCoord * 2. - 1.) * (1. / scale);\n    position *= dimensions.y / dimensions.x;\n    position += offset * (1. / scale);\n\n    vec4 color = vec4(vec3(0.05), 1.);\n\n    for(float i = 0.; i < 2.; i++) {\n      vec4 starColor = mapStar(position, intensity, i * 20.);\n      color.rgb += starColor.rgb * starColor.a;\n    }\n\n    gl_FragColor = color;\n}", this.uniforms);
    this.isLeaving = !1;
    this.onStopCallback = this.onStopCaller = null
}
Application.subclass(LightSpeedFilter, window.PIXI.AbstractFilter);
LightSpeedFilter.prototype.setIntensity = function(a) {
    this.isLeaving || (this.uniforms.intensity.value = a)
};
LightSpeedFilter.prototype.leaveLightSpeed = function(a, b) {
    this.isLeaving = !0;
    this.onStopCaller = a;
    this.onStopCallback = b
};
LightSpeedFilter.prototype.update = function(a) {
    this.isLeaving && (this.uniforms.intensity.value += Common.lerp(this.uniforms.intensity.value, 0, 10, a), .001 > this.uniforms.intensity.value && (this.onStopCallback.call(this.onStopCaller), this.isLeaving = !1));
    this.uniforms.starPositionOffset.value += this.speed + 40 * this.uniforms.intensity.value
};

function GuiEndGame(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.localizedTitle("gui_localized_title_endgame", this.getControl("mcGuiTextCongrats").clip, 450, 44);
    PlayerSettings.instance.doFinalCutscene = !1
}
Application.subclass(GuiEndGame, SScreen);
GuiEndGame.prototype.onUIPress = function(a) {
    switch (a.id) {
        case "btn_mainmenu":
            GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU)
    }
};
GuiEndGame.prototype.onPressSpaceBar = function() {
    GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU);
    SScreen.prototype.onPressSpaceBar.call(this)
};
GuiEndGame.prototype.onEndTransition = function(a) {
    SScreen.prototype.onEndTransition.call(this, a);
    a.params && Application.instance.guiManager.gotoScreen(a.params.screen)
};

function GuiGame(a, b, c) {
    SScreen.call(this, "", a, b);
    this.name = GuiManager.SC_GAME;
    GuiGame.instance = this;
    this.game = null;
    PoolClips.instance.clear();
    MissionManager.instance.setMissionId("planet_" + Global.level + "_m" + Global.mission);
    this.canvasBackground = Application.instance.addDisplayContainer();
    this.canvasGame = Application.instance.addDisplayContainer();
    this.canvasControl = Application.instance.addDisplayContainer();
    this.canvasEffects = Application.instance.addDisplayContainer();
    this.canvas.addChild(this.canvasBackground);
    this.canvas.addChild(this.canvasGame);
    this.canvas.addChild(this.canvasControl);
    this.canvas.addChild(this.canvasEffects);
    this.achievsToShow = [];
    Application.instance.stopAllSounds();
    this.createGame()
}
Application.subclass(GuiGame, SScreen);
GuiGame.instance = null;
GuiGame.TX_INIT_GAME = 0;
GuiGame.TX_REMOVE_GAME = 1;
GuiGame.prototype.onStart = function() {
    if (this.game && this.game.onStart) this.game.onStart()
};
GuiGame.prototype.fixGameScale = function() {
    HudPlatform.instance && HudPlatform.instance.fixGameScale();
    this.game && this.game.fixGameScale()
};
GuiGame.prototype.createGame = function() {
    var a = "world_tuto";
    if (!MissionManager.instance.isMissionTutorial()) switch (Global.level) {
        case 1:
            if (PlayerSettings.instance.isMultiplayer()) switch (MissionManager.instance.getMissionType()) {
                case MissionManager.MISSION_COLLECTION:
                    a = "world_1_mult_collection";
                    break;
                case MissionManager.MISSION_LIBERATION:
                    a = "world_1_mult_liberation";
                    break;
                case MissionManager.MISSION_SABOTAGE:
                    a = "world_1_mult_sabotage";
                    break;
                case MissionManager.MISSION_BOSS_BATTLE:
                    a = "boss_1"
            } else a = MissionManager.instance.isMissionBossBattle() ?
                "boss_1" : "world_1";
            break;
        case 2:
            if (PlayerSettings.instance.isMultiplayer()) switch (MissionManager.instance.getMissionType()) {
                case MissionManager.MISSION_COLLECTION:
                    a = "world_2_mult_collection";
                    break;
                case MissionManager.MISSION_LIBERATION:
                    a = "world_2_mult_liberation";
                    break;
                case MissionManager.MISSION_SABOTAGE:
                    a = "world_2_mult_sabotage";
                    break;
                case MissionManager.MISSION_BOSS_BATTLE:
                    a = "boss_2"
            } else a = MissionManager.instance.isMissionBossBattle() ? "boss_2" : "world_2";
            break;
        case 3:
            if (PlayerSettings.instance.isMultiplayer()) switch (MissionManager.instance.getMissionType()) {
                case MissionManager.MISSION_COLLECTION:
                    a =
                        "world_3_mult_collection";
                    break;
                case MissionManager.MISSION_LIBERATION:
                    a = "world_3_mult_liberation";
                    break;
                case MissionManager.MISSION_SABOTAGE:
                    a = "world_3_mult_sabotage";
                    break;
                case MissionManager.MISSION_BOSS_BATTLE:
                    a = "boss_3"
            } else a = MissionManager.instance.isMissionBossBattle() ? "boss_3" : "world_3"
    }
    PlayerSettings.instance.setCurrentMap(a);
    if (Application.sandbox) {
        Application.log("-----------------------------------");
        Application.log("SANDBOX START SETTINGS");
        for (var b in Application.sandbox.startSettings) {
            Application.log("SANDBOX " +
                b + " : " + Application.sandbox.startSettings[b]);
            var a = Application.sandbox.startSettings.level,
                c = 0;
            switch (Application.sandbox.startSettings.player) {
                case "ezra":
                    c = PlayerSettings.TYPE_EZRA;
                    break;
                case "kanan":
                    c = PlayerSettings.TYPE_KANAN;
                    break;
                case "sabine":
                    c = PlayerSettings.TYPE_SABINE;
                    break;
                case "hera":
                    c = PlayerSettings.TYPE_HERA;
                    break;
                case "zeb":
                    c = PlayerSettings.TYPE_ZEB;
                    break;
                case "chopper":
                    c = PlayerSettings.TYPE_CHOPPER
            }
            PlayerSettings.instance.setPlayer(c);
            switch (Application.sandbox.startSettings.mission) {
                case "collection":
                    MissionManager.instance.setMissionType(MissionManager.MISSION_COLLECTION);
                    Global.mission = 1;
                    break;
                case "liberation":
                    MissionManager.instance.setMissionType(MissionManager.MISSION_LIBERATION);
                    Global.mission = 2;
                    break;
                case "sabotage":
                    MissionManager.instance.setMissionType(MissionManager.MISSION_SABOTAGE);
                    Global.mission = 3;
                    break;
                case "boss":
                    MissionManager.instance.setMissionType(MissionManager.MISSION_BOSS_BATTLE), Global.mission = 4
            }
        }
        Application.log("-----------------------------------")
    }
    this.game = new PlatformGame(this.canvasGame, this.canvasControl, a, "PlatformGeneral");
    Global.game =
        this.game;
    if (Application.sandbox) this.game.onDebugInit()
};
GuiGame.prototype.removeGame = function() {
    this.deleteGame || (this.deleteGame = !0, this.game.free(), this.game = null, Application.instance.guiManager.gotoScreen(GuiManager.SC_MAIN_MENU))
};
GuiGame.prototype.onEndTransition = function(a) {
    SScreen.prototype.onEndTransition.call(this, a);
    if (a.params) switch (a.params.action) {
        case GuiGame.TX_REMOVE_GAME:
            this.game.free(), this.game = null, Application.instance.guiManager.gotoScreen(GuiManager.SC_MAIN_MENU)
    }
};
GuiGame.prototype.onDebugDraw = function(a) {
    if (null !== this.game) this.game.onDebugDraw(a)
};
GuiGame.prototype.onPointerPress = function(a) {
    a = Layout.fixInteractionEvent(a);
    if (this.game) this.game.onPointerPress(a)
};
GuiGame.prototype.onPointerRelease = function(a) {
    a = Layout.fixInteractionEvent(a);
    if (this.game) this.game.onPointerRelease(a)
};
GuiGame.prototype.onPointerMove = function(a) {
    a = Layout.fixInteractionEvent(a);
    if (this.game) this.game.onPointerMove(a)
};
GuiGame.prototype.onKeyUp = function(a) {
    SScreen.prototype.onKeyUp.call(this, a);
    if (null !== this.game && null === this.popup) this.game.onKeyUp(a)
};
GuiGame.prototype.onKeyDown = function(a) {
    SScreen.prototype.onKeyDown.call(this, a);
    if (null !== this.game && null === this.popup) this.game.onKeyDown(a)
};
GuiGame.prototype.addPopup = function(a, b, c, d) {
    this.game && this.game.basicStick && this.game.basicStick.doReleaseJoystick();
    return SScreen.prototype.addPopup.call(this, a, b, c, d)
};
GuiGame.prototype.update = function(a) {
    SScreen.prototype.update.call(this, a);
    null !== this.game && null === this.popup && this.game.update(a);
    0 < this.achievsToShow.length && !this.achievPopup && (this.achievPopup = new GuiPopupAchiev("mcGuiPopupNewTrophy"), this.achievPopup.setAchievType(this.achievsToShow[0]), this.achievsToShow.splice(0, 1));
    this.achievPopup && this.achievPopup.update(a)
};
GuiGame.prototype.addAchievPopup = function(a) {
    this.showingAchiev = !0;
    this.achievsToShow.push(a)
};
GuiGame.prototype.free = function() {
    Application.instance.stopAllSounds();
    Application.instance.effectManager.clear();
    this.achievPopup && (this.achievPopup.free(), this.achievPopup = null);
    null !== this.game && this.game.free();
    this.game = null;
    Global.game = null;
    this.canvas.removeChild(this.canvasGame);
    this.canvasGame = null;
    this.canvas.removeChild(this.canvasControl);
    this.canvasControl = null;
    GuiGame.instance = null;
    SScreen.prototype.free.call(this)
};

function GuiGameSandbox(a, b, c) {
    SScreen.call(this, "", a, b);
    GuiGameSandbox.instance = this;
    this.game = null;
    this.canvasGame = Application.instance.addDisplayContainer();
    this.canvasControl = Application.instance.addDisplayContainer();
    this.canvas.addChild(this.canvasGame);
    this.canvas.addChild(this.canvasControl);
    this.createGame();
    this.canvasGame.addCollision("mcCollision", new Rectangle(.5 * -Application.APP_WIDTH, 0, 2 * Application.APP_WIDTH, Application.APP_HEIGHT));
    this.canvasGame.addPressListener(this, this.onPointerPress);
    this.canvasGame.addReleaseListener(this, this.onPointerRelease);
    this.canvasGame.addPointerMoveListener(this, this.onPointerMove)
}
Application.subclass(GuiGameSandbox, SScreen);
GuiGameSandbox.prototype.createGame = function() {};
GuiGameSandbox.prototype.removeGame = function() {
    this.deleteGame || (this.deleteGame = !0, this.game.free(), this.game = null, Application.instance.guiManager.gotoScreen(GuiManager.SC_MAIN_MENU))
};
GuiGameSandbox.prototype.onDebugDraw = function(a) {
    if (null !== this.game) this.game.onDebugDraw(a)
};
GuiGameSandbox.prototype.onPointerPress = function(a) {
    SScreen.prototype.onPointerPress.call(this, a);
    if (null !== this.game && null === this.popup) this.game.onPointerPress(a)
};
GuiGameSandbox.prototype.onPointerRelease = function(a) {
    SScreen.prototype.onPointerRelease.call(this, a);
    if (null !== this.game && null === this.popup) this.game.onPointerRelease(a)
};
GuiGameSandbox.prototype.onPointerMove = function(a) {
    SScreen.prototype.onPointerMove.call(this, a);
    if (null !== this.game && null === this.popup) this.game.onPointerMove(a)
};
GuiGameSandbox.prototype.onKeyUp = function(a) {
    SScreen.prototype.onKeyUp.call(this, a);
    if (null !== this.game && null === this.popup) this.game.onKeyUp(a)
};
GuiGameSandbox.prototype.onKeyDown = function(a) {
    SScreen.prototype.onKeyDown.call(this, a);
    if (null !== this.game && null === this.popup) this.game.onKeyDown(a)
};
GuiGameSandbox.prototype.update = function(a) {
    SScreen.prototype.update.call(this, a);
    null !== this.game && null === this.popup && this.game.update(a)
};
GuiGameSandbox.prototype.free = function() {
    Application.instance.stopAllSounds();
    this.game && (this.game.free(), this.game = null, Global.game = null);
    this.canvas.removeChild(this.canvasGame);
    this.canvasGame = null;
    this.canvas.removeChild(this.canvasControl);
    this.canvasControl = null;
    GuiGame.instance = null;
    SScreen.prototype.free.call(this)
};

function GuiMainMenu(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = GuiManager.SC_MAIN_MENU;
    this.m_tie03 = this.m_tie02 = this.m_tie01 = this.m_chapter06 = this.m_chapter05 = this.m_chapter04 = this.m_chapter03 = this.m_chapter02 = this.m_chapter01 = this.m_nameLogo = this.m_logo = null;
    this.percentageParallaxY = this.percentageParallaxX = this.m_initPostY_tie03 = this.m_initPostX_tie03 = this.m_initPostY_tie02 = this.m_initPostX_tie02 = this.m_initPostY_tie01 = this.m_initPostX_tie01 = this.m_initPostY_chapter06 = this.m_initPostX_chapter06 =
        this.m_initPostY_chapter05 = this.m_initPostX_chapter05 = this.m_initPostY_chapter04 = this.m_initPostX_chapter04 = this.m_initPostY_chapter03 = this.m_initPostX_chapter03 = this.m_initPostY_chapter02 = this.m_initPostX_chapter02 = this.m_initPostY_chapter01 = this.m_initPostX_chapter01 = this.resetDataCheatCounter = 0;
    GuiMainMenu.doneFirstLoader = !0;
    this.showingVideo = !1;
    a = !Application.instance.isSoundOn();
    Application.instance.soundManager.m_muted = !1;
    Application.instance.stopAllSounds();
    Application.instance.soundManager.m_muted =
        a;
    this.initLocalizedSprites();
    this.chargeImageParallax();
    this.waitTimer = 0;
    this.isLoading = !1;
    this.getControl("mcGuiBtnVideo").setVisible(!window.config.settings.HIDE_VIDEO_BUTTON);
    this.getControl("mcGuiBtnLeaderboard").setVisible(!window.config.settings.HIDE_LEADERBOARD_BUTTON);
    this.videoTexture = this.gBaseCanvasStage = null;
    GuiMainMenu.instance = this;
    this.saberSoundPlayed = !1;
    this.onHold = !0;
    this.sponsor2 = this.sponsor1 = null;
    this.getControl("mcGuiBtnMoregames").setVisible(!window.config.settings.HIDE_ARCADE_BUTTON);
    if (window.config.settings.HIDE_LEADERBOARD_BUTTON)
        for (a = 0; a < this.clip.dataLayers.length; a++)
            if (this.clip.dataLayers[a].f && this.clip.dataLayers[a].f[0] && "mcGuiBtnTrophies" === this.clip.dataLayers[a].f[0].o) {
                a = this.clip.dataLayers[a].f;
                for (b = 0; b < a.length; b++) a[b].y = 568.8;
                break
            }
}
Application.subclass(GuiMainMenu, SScreen);
GuiMainMenu.SELECT_WAIT_TIME = 500;
GuiMainMenu.instance = null;
GuiMainMenu.prototype.setupSponsorship = function() {
    var a = window.PIXI.Sprite.fromImage(window.config.settings.Sponsorship_Image_Path + window.config.settings.Sponsorship_Image1);
    if (a) {
        this.sponsor1 = a;
        if (a.texture.baseTexture.hasLoaded) a.position.x = .5 * -a.texture.baseTexture.width, a.position.y = .5 * -a.texture.baseTexture.height;
        else a.texture.baseTexture.on("loaded", function() {
            a.position.x = .5 * -a.texture.baseTexture.width;
            a.position.y = .5 * -a.texture.baseTexture.height
        });
        this.sponsor1 && this.getControl("mcGuiSponsorship");
        this.getControl("mcGuiSponsorship").canvas.addChild(this.sponsor1)
    }
    var b = window.PIXI.Sprite.fromImage(window.config.settings.Sponsorship_Image_Path + window.config.settings.Sponsorship_Image2);
    if (b) {
        this.sponsor2 = b;
        if (b.texture.baseTexture.hasLoaded) b.position.x = .5 * -a.texture.baseTexture.width, b.position.y = .5 * -a.texture.baseTexture.height;
        else b.texture.baseTexture.on("loaded", function() {
            b.position.x = .5 * -b.texture.baseTexture.width;
            b.position.y = .5 * -b.texture.baseTexture.height
        });
        this.getControl("mcGuiTXtimes").canvas.addChild(this.sponsor2)
    }
};
GuiMainMenu.prototype.chargeImageParallax = function() {
    this.m_chapter01 = this.getControl("mcGuiCharacter1").clip;
    this.m_initPostX_chapter01 = this.getControl("mcGuiCharacter1").clip.position.x;
    this.m_initPostY_chapter01 = this.getControl("mcGuiCharacter1").clip.position.y;
    this.m_chapter01.position.x = this.m_initPostX_chapter01;
    this.m_chapter01.position.y = this.m_initPostY_chapter01;
    this.m_chapter02 = this.getControl("mcGuiCharacter2").clip;
    this.m_initPostX_chapter02 = this.getControl("mcGuiCharacter2").clip.position.x;
    this.m_initPostY_chapter02 = this.getControl("mcGuiCharacter2").clip.position.y;
    this.m_chapter02.position.x = this.m_initPostX_chapter02;
    this.m_chapter02.position.y = this.m_initPostY_chapter02;
    this.m_chapter03 = this.getControl("mcGuiCharacter3").clip;
    this.m_initPostX_chapter03 = this.getControl("mcGuiCharacter3").clip.position.x;
    this.m_initPostY_chapter03 = this.getControl("mcGuiCharacter3").clip.position.y;
    this.m_chapter03.position.x = this.m_initPostX_chapter03;
    this.m_chapter03.position.y = this.m_initPostY_chapter03;
    this.m_chapter04 = this.getControl("mcGuiCharacter4").clip;
    this.m_initPostX_chapter04 = this.getControl("mcGuiCharacter4").clip.position.x;
    this.m_initPostY_chapter04 = this.getControl("mcGuiCharacter4").clip.position.y;
    this.m_chapter04.position.x = this.m_initPostX_chapter04;
    this.m_chapter04.position.y = this.m_initPostY_chapter04;
    this.m_chapter05 = this.getControl("mcGuiCharacter5").clip;
    this.m_initPostX_chapter05 = this.getControl("mcGuiCharacter5").clip.position.x;
    this.m_initPostY_chapter05 = this.getControl("mcGuiCharacter5").clip.position.y;
    this.m_chapter05.position.x = this.m_initPostX_chapter05;
    this.m_chapter05.position.y = this.m_initPostY_chapter05;
    this.m_chapter06 = this.getControl("mcGuiCharacter6").clip;
    this.m_initPostX_chapter06 = this.getControl("mcGuiCharacter6").clip.position.x;
    this.m_initPostY_chapter06 = this.getControl("mcGuiCharacter6").clip.position.y;
    this.m_chapter06.position.x = this.m_initPostX_chapter06;
    this.m_chapter06.position.y = this.m_initPostY_chapter06;
    this.m_tie01 = this.getControl("mcGuiTie1").clip;
    this.m_initPostX_tie01 =
        this.getControl("mcGuiTie1").clip.position.x;
    this.m_initPostY_tie01 = this.getControl("mcGuiTie1").clip.position.y;
    this.m_tie01.position.x = this.m_initPostX_tie01;
    this.m_tie01.position.y = this.m_initPostY_tie01;
    this.m_tie02 = this.getControl("mcGuiTie2").clip;
    this.m_initPostX_tie02 = this.getControl("mcGuiTie2").clip.position.x;
    this.m_initPostY_tie02 = this.getControl("mcGuiTie2").clip.position.y;
    this.m_tie02.position.x = this.m_initPostX_tie02;
    this.m_tie02.position.y = this.m_initPostY_tie02;
    this.m_tie03 = this.getControl("mcGuiTie3").clip;
    this.m_initPostX_tie03 = this.getControl("mcGuiTie3").clip.position.x;
    this.m_initPostY_tie03 = this.getControl("mcGuiTie3").clip.position.y;
    this.m_tie03.position.x = this.m_initPostX_tie03;
    this.m_tie03.position.y = this.m_initPostY_tie03
};
GuiMainMenu.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    Global.comingFromTutorial && (Global.comingFromTutorial = !1, this.addPopup(GuiPopupSelectMode, "mcGuiPopupSelectmode", 0, 0))
};
GuiMainMenu.prototype.update = function(a) {
    Application.instance.isPlayingSound("SND_TITLE") || !Application.instance.isSoundOn() || this.showingVideo || Application.instance.playSound("SND_TITLE");
    (this.sponsor1 && this.sponsor1.texture.baseTexture.loaded || !this.sponsor2) && (this.sponsor2 && this.sponsor2.texture.baseTexture.loaded || !this.sponsor2) && (SScreen.prototype.update.call(this, a), !this.saberSoundPlayed && 19 <= this.getControl("mcGuiCharacter1").clip.currentFrame && (Application.instance.playSound("SND_SABER_ON"),
        this.saberSoundPlayed = !0), this.controls && this.checkStateSound("mcGuiBtnSound"), 0 < this.waitTimer && (this.waitTimer += a, this.waitTimer >= GuiMainMenu.SELECT_WAIT_TIME && (MissionManager.instance.setGameMode(MissionManager.GAME_SINGLEPLAYER), PlayerSettings.instance.setNumberPlayers(1), GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_CHARACTER_SP))))
};
GuiMainMenu.prototype.onPointerMove = function(a) {
    this.popup || (this.percentageParallaxX = (a.data.global.x - Application.APP_WIDTH / 2) / Application.APP_WIDTH * .2, this.percentageParallaxY = (a.data.global.y - Application.APP_HEIGHT / 2) / Application.APP_HEIGHT * .2, 1 < this.percentageParallaxX ? this.percentageParallaxX = 1 : -1 > this.percentageParallaxX && (this.percentageParallaxX = -1), 1 < this.percentageParallaxY ? this.percentageParallaxY = 1 : -1 > this.percentageParallaxY && (this.percentageParallaxY = -1), this.m_chapter01 && (this.m_chapter01.position.x =
            this.m_initPostX_chapter01 + 100 * this.percentageParallaxX, this.m_chapter01.position.y = this.m_initPostY_chapter01 + 20 * this.percentageParallaxY), this.m_chapter02 && (this.m_chapter02.position.x = this.m_initPostX_chapter02 + 250 * this.percentageParallaxX, this.m_chapter02.position.y = this.m_initPostY_chapter02 + 50 * this.percentageParallaxY), this.m_chapter03 && (this.m_chapter03.position.x = this.m_initPostX_chapter03 + 200 * this.percentageParallaxX, this.m_chapter03.position.y = this.m_initPostY_chapter03 + 40 * this.percentageParallaxY),
        this.m_chapter04 && (this.m_chapter04.position.x = this.m_initPostX_chapter04 + 150 * this.percentageParallaxX, this.m_chapter04.position.y = this.m_initPostY_chapter04 + 60 * this.percentageParallaxY), this.m_chapter05 && (this.m_chapter05.position.x = this.m_initPostX_chapter05 + 200 * this.percentageParallaxX, this.m_chapter05.position.y = this.m_initPostY_chapter05 + 80 * this.percentageParallaxY), this.m_chapter06 && (this.m_chapter06.position.x = this.m_initPostX_chapter06 + 280 * this.percentageParallaxX, this.m_chapter06.position.y =
            this.m_initPostY_chapter06 + 80 * this.percentageParallaxY), this.m_tie01 && (this.m_tie01.position.x = this.m_initPostX_tie01 + 300 * this.percentageParallaxX, this.m_tie01.position.y = this.m_initPostY_tie01 + 100 * this.percentageParallaxY), this.m_tie02 && (this.m_tie02.position.x = this.m_initPostX_tie02 + 200 * this.percentageParallaxX, this.m_tie02.position.y = this.m_initPostY_tie02 + 110 * this.percentageParallaxY), this.m_tie03 && (this.m_tie03.position.x = this.m_initPostX_tie03 + 350 * this.percentageParallaxX, this.m_tie03.position.y =
            this.m_initPostY_tie03 + 105 * this.percentageParallaxY))
};
GuiMainMenu.doneFirstLoader = !1;
GuiMainMenu.prototype.init = function() {
    SScreen.prototype.init.call(this);
    Application.instance.onOrientationchange(null)
};
GuiMainMenu.prototype.free = function() {
    Application.instance.socialShareObject && Application.instance.socialShareObject.closeSharing();
    this.sponsor2 = this.sponsor1 = null;
    SScreen.prototype.free.call(this)
};
GuiMainMenu.prototype.initLocalizedSprites = function() {
    this.m_logo = Application.instance.getLocalizedImage("gui_localized_logo.png");
    this.getControl("mcGuiLogo").clip.addChild(this.m_logo);
    this.m_logo.pivot.x = 435;
    this.m_logo.pivot.y = 72;
    this.m_logo.position.x = 0;
    this.m_logo.position.y = 0;
    this.m_nameLogo = Application.instance.getLocalizedImage("gui_localized_gamename.png");
    this.getControl("mcGuiGameName").clip.addChild(this.m_nameLogo);
    this.m_nameLogo.pivot.x = 435;
    this.m_nameLogo.pivot.y = 104;
    this.m_nameLogo.position.x =
        0;
    this.m_nameLogo.position.y = 0
};
GuiMainMenu.prototype.onUIOut = function(a) {
    SScreen.prototype.onUIOut.call(this, a);
    this.lastInteractionControl = ""
};
GuiMainMenu.prototype.onUIPress = function(a) {
    if (!(Global.comingFromTutorial || 0 < this.waitTimer || this.popup)) switch (Application.USE_CHEATS && (this.resetDataCheatCounter++, 5 <= this.resetDataCheatCounter && (Global.data.resetAllData(), Global.data.save())), SScreen.prototype.onUIPress.call(this, a), a.name) {
        case "mcGuiBtnSoundOn":
        case "mcGuiBtnSoundOff":
            Application.instance.toggleMute()
    }
};
GuiMainMenu.prototype.onUIRelease = function(a) {
    if (!(Global.comingFromTutorial || 0 < this.waitTimer || this.popup) && (SScreen.prototype.onUIRelease.call(this, a), this.activeRelease)) {
        "mcGuiBtnPlay" !== a.name && Application.instance.playSound("SND_UI_CLICK");
        switch (a.name) {
            case "mcGuiBtnVideo":
                this.videoTexture ? this.createVideoPopup(!1) : this.isLoading || (this.isLoading = !0, this.createVideoPopup(!0), this.videoTexture = window.PIXI.Texture.fromVideoUrl(Application.config.settings.movieURL), this.videoTexture.baseTexture.on("loaded",
                    function() {
                        var a = new window.PIXI.Sprite(GuiMainMenu.instance.videoTexture);
                        GuiMainMenu.instance.isLoading = !1;
                        GuiMainMenu.instance.popup.initVideo(a, this)
                    }));
                break;
            case "mcGuiBtnPlay":
                PlayerSettings.instance.isFirstPlay() ? this.waitTimer = 1 : this.addPopup(GuiPopupSelectMode, "mcGuiPopupSelectmode", 0, 0);
                Application.instance.playSound("SND_UI_PLAY_CLICK");
                break;
            case "mcGuiBtnHelp":
                this.addPopup(GuiPopupHelp, "mcGuiPopupHelp", 0, 0);
                break;
            case "mcGuiBtnTrophies":
                this.addPopup(GuiPopupTrophies, "mcGuiPopupTrophies",
                    0, 0);
                break;
            case "mcGuiBtnReset":
                this.addPopup(GuiPopupReset, "mcGuiPopupReset", 0, 0);
                break;
            case "mcGuiBtnMoregames":
                GuiPopupQuit.typeMessage = GuiPopupQuit.ARCADE;
                this.addPopup(GuiPopupQuit, "mcGuiPopupConfirm");
                break;
            case "mcGuiBtnLeaderboard":
                ScoreAPI.instance.getScores(this.onGetScores)
        }
        this.activeRelease = !1;
        a.onResetState()
    }
};
GuiMainMenu.prototype.onGetScores = function(a) {
    if (!a.error) GuiMainMenu.instance.addPopup(GuiPopupLeaderboard, "mcGuiPopupLeaderboard", 0, 0).onGetScores(a)
};
GuiMainMenu.prototype.createVideoPopup = function(a) {
    this.showingVideo = !0;
    this.addPopup(GuiPopupVideo, "mcGuiPopupVideo");
    a || (this.isLoading = !1, a = new window.PIXI.Sprite(this.videoTexture), this.popup.initVideo(a, this))
};
GuiMainMenu.prototype.onEndTransition = function(a) {
    SScreen.prototype.onEndTransition.call(this, a);
    null !== a.params && "undefined" !== typeof a.params.screen && GuiManager.instance.gotoScreen(a.params.screen)
};

function GuiLocationPlanet(a, b, c) {
    SScreen.call(this, a, 0, 0, null);
    this.isUnlocked = c;
    this.m_idPlanet = b;
    this.m_idMission = -1;
    b === PlayerSettings.instance.unlockingWorld ? (this.hideAll(), this.setAppearClip(b)) : this.loadData()
}
Application.subclass(GuiLocationPlanet, SScreen);
GuiLocationPlanet.prototype.setAppearClip = function(a) {
    this.getControl("mcGuiPlanet").clip.resume();
    this.getControl("mcGuiPlanet").clip.onEndAnimation(this, this.unlockThisPlanet)
};
GuiLocationPlanet.prototype.unlockThisPlanet = function() {
    this.showAll();
    for (var a = 1; 4 >= a; a++) this.getControl("mcGuiBtnMission0" + a).setInteractive(!0), this.getControl("mcGuiBtnMission0" + a).setVisible(!0), this.getControl("mcGuiLine" + a).clip.gotoAndStop(1), this.getControl("mcGuiBaseMission0" + a).setVisible(!0), MissionManager.instance.isVersus() || this.getControl("mcGuiStars0" + a).setVisible(!0);
    PlayerSettings.instance.resetUnlocking()
};
GuiLocationPlanet.prototype.hideAll = function() {
    this.getControl("mcGuiPlanet").setClip("gui_screen_selectlocation_planet0" + this.m_idPlanet + "_off");
    this.getControl("mcGuiPlanet").clip.gotoAndStop(1);
    for (var a = 1; 4 >= a; a++) this.getControl("mcGuiLine" + a).clip.gotoAndStop(2), this.getControl("mcGuiBtnMission0" + a).setInteractive(!1), this.getControl("mcGuiBtnMission0" + a).setVisible(!1), this.getControl("mcGuiBaseMission0" + a).setVisible(!1), this.getControl("mcGuiStars0" + a).setVisible(!1), this.getControl("mcGuiNameMission0" +
        a).setTextEmpty()
};
GuiLocationPlanet.prototype.showAll = function() {
    this.getControl("mcGuiPlanet").setClip("gui_screen_selectlocation_planet0" + this.m_idPlanet);
    this.getControl("mcGuiPlanet").clip.gotoAndPlay(2);
    for (var a = 1; 4 >= a; a++) this.getControl("mcGuiNameMission0" + a).setTextLocalized("STR_SELECT_MISION_PANEL_NAME_" + (4 * (this.m_idPlanet - 1) + a)), MissionManager.instance.isVersus() ? this.getControl("mcGuiStars0" + a).setVisible(!1) : this.setStars(this.getControl("mcGuiStars0" + a), PlayerSettings.instance.getStars(this.m_idPlanet, a))
};
GuiLocationPlanet.prototype.loadData = function() {
    this.isUnlocked ? this.showAll() : this.hideAll()
};
GuiLocationPlanet.prototype.update = function(a) {
    SScreen.prototype.update.call(this, a)
};
GuiLocationPlanet.prototype.setStars = function(a, b) {
    a.clip.gotoAndStop(b + 1)
};
GuiLocationPlanet.prototype.onUIPress = function(a) {
    SScreen.prototype.onUIPress.call(this, a);
    MissionManager.instance.isVersus() && (Global.data.data.lastVSPlanet = this.m_idPlanet, Global.data.save());
    switch (a.name) {
        case "mcGuiBtnMission01":
            MissionManager.instance.setMissionType(MissionManager.MISSION_COLLECTION);
            Global.mission = 1;
            GuiManager.instance.gotoScreen(GuiManager.SC_GAME);
            Application.instance.playSound("SND_SELECT_MISSION");
            break;
        case "mcGuiBtnMission02":
            MissionManager.instance.setMissionType(MissionManager.MISSION_LIBERATION);
            Global.mission = 2;
            GuiManager.instance.gotoScreen(GuiManager.SC_GAME);
            Application.instance.playSound("SND_SELECT_MISSION");
            break;
        case "mcGuiBtnMission03":
            MissionManager.instance.setMissionType(MissionManager.MISSION_SABOTAGE);
            Global.mission = 3;
            GuiManager.instance.gotoScreen(GuiManager.SC_GAME);
            Application.instance.playSound("SND_SELECT_MISSION");
            break;
        case "mcGuiBtnMission04":
            MissionManager.instance.setMissionType(MissionManager.MISSION_BOSS_BATTLE), Global.mission = 4, GuiManager.instance.gotoScreen(GuiManager.SC_GAME),
                Application.instance.playSound("SND_SELECT_MISSION")
    }
};

function GuiSelectLocation(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = GuiManager.SC_SELECT_LOCATION;
    GuiSelectLocation.instance = this;
    Application.instance.isPlayingSound("SND_BG_MAINMENU") || (a = !Application.instance.isSoundOn(), Application.instance.soundManager.m_muted = !1, Application.instance.stopAllSounds(), Application.instance.soundManager.m_muted = a);
    this.m_unlockedChapters = 2;
    this.m_scroll = null;
    this.m_animationUnlock = this.m_isScrolling = this.m_onUIPress = this.m_moveScroll = !1;
    this.m_stateUnlock = -1;
    this.m_timeAnimation = 0;
    this.m_screenItems = null;
    this.m_minDistance = Application.instance.isMobileDevice ? 5 : 2;
    this.m_distanceFactor = Application.instance.isMobileDevice ? 22 : 12;
    this.m_initTouch = new Point;
    this.m_moveTouch1 = new Point;
    this.m_moveTouch2 = new Point;
    this.m_currentPage = 1;
    MissionManager.instance.isVersus() ? this.m_currentPage = Global.data.data.lastVSPlanet - 1 : this.m_currentPage = PlayerSettings.instance.getLatestUnlocked();
    0 === Global.data.data.unlockPlanets[0] && PlayerSettings.instance.setUnlockPlanet(0);
    this.m_currentTouchIdentifier = GuiSelectLocation.TOUCH_ID_NONE;
    this.m_scroll = new ScrollHandler;
    this.m_scroll.maxIndex = GuiSelectLocation.MAX_PLANET;
    this.m_scroll.displaceX = Application.RIGHT_TO_LEFT ? -1024 : 1024;
    this.m_scroll.duration = 700;
    this.m_scroll.index = this.m_currentPage;
    this.m_scroll.addUpdateListener(this, this.updatePositions);
    this.m_scroll.addCompleteListener(this, this.onCompleteScroll);
    this.m_screenItems = new GuiSelectLocationItems("mcGuiScreenSelectLocationBackground");
    this.getControl("mcGuiBtnBg").canvas.addChild(this.m_screenItems.canvas);
    this.m_screenItems.canvas.ox = 0;
    this.unlockAllCheatCounter = this.m_screenItems.canvas.oy = 0;
    PlayerSettings.instance.doUnlockNextWorld && (this.m_currentPage = PlayerSettings.instance.unlockingWorld - 1);
    this.onMoveScroll(this.m_currentPage);
    this.localizedTitle("gui_localized_title_metamap", this.getControl("mcGuiTextTitle").clip, 450, 44);
    this.checkLateralBtns();
    this.transition = PoolClips.instance.getClip("mcGuiTransition_wipein");
    this.transition.position.x = -1590;
    this.getControl("mcGuiTransition").canvas.addChild(this.transition);
    this.transition.onEndAnimation(this, this.onEndTransition)
}
Application.subclass(GuiSelectLocation, SScreen);
GuiSelectLocation.instance = null;
GuiSelectLocation.STATE_INIT = 0;
GuiSelectLocation.STATE_SCROLL = 1;
GuiSelectLocation.STATE_END = 2;
GuiSelectLocation.MAX_PLANET = 2;
GuiSelectLocation.SCROLL_TIME_PRESS = 500;
GuiSelectLocation.TOUCH_ID_NONE = -100;
GuiSelectLocation.prototype.onEndTransition = function() {
    this.getControl("mcGuiLetterbox").canvas.removeChild(this.transition)
};
GuiSelectLocation.prototype.getIdentifier = function(a) {
    return "undefined" !== typeof a.data.identifier ? a.data.identifier : a.data.originalEvent.which
};
GuiSelectLocation.prototype.checkLateralBtns = function() {
    PlayerSettings.instance.doUnlockNextWorld ? (this.getControl("mcGuiBtnScrollLeft").clip.visible = !1, this.getControl("mcGuiBtnScrollLeft").setInteractive(!1), this.getControl("mcGuiBtnScrollRight").clip.visible = !1, this.getControl("mcGuiBtnScrollRight").setInteractive(!1)) : Application.RIGHT_TO_LEFT ? 0 === this.m_currentPage || this.m_currentPage === GuiSelectLocation.MAX_PLANET ? (this.getControl("mcGuiBtnScrollRight").setVisible(0 !== this.m_currentPage), this.getControl("mcGuiBtnScrollRight").setInteractive(0 !==
            this.m_currentPage), this.getControl("mcGuiBtnScrollLeft").setVisible(this.m_currentPage !== GuiSelectLocation.MAX_PLANET), this.getControl("mcGuiBtnScrollLeft").setInteractive(this.m_currentPage !== GuiSelectLocation.MAX_PLANET)) : (this.getControl("mcGuiBtnScrollRight").setVisible(!0), this.getControl("mcGuiBtnScrollRight").setInteractive(!0), this.getControl("mcGuiBtnScrollLeft").setVisible(!0), this.getControl("mcGuiBtnScrollLeft").setInteractive(!0)) : 0 === this.m_currentPage || this.m_currentPage === GuiSelectLocation.MAX_PLANET ?
        (this.getControl("mcGuiBtnScrollLeft").setVisible(0 !== this.m_currentPage), this.getControl("mcGuiBtnScrollLeft").setInteractive(0 !== this.m_currentPage), this.getControl("mcGuiBtnScrollRight").setVisible(this.m_currentPage !== GuiSelectLocation.MAX_PLANET), this.getControl("mcGuiBtnScrollRight").setInteractive(this.m_currentPage !== GuiSelectLocation.MAX_PLANET)) : (this.getControl("mcGuiBtnScrollRight").setVisible(!0), this.getControl("mcGuiBtnScrollRight").setInteractive(!0), this.getControl("mcGuiBtnScrollLeft").setVisible(!0),
            this.getControl("mcGuiBtnScrollLeft").setInteractive(!0))
};
GuiSelectLocation.prototype.onMoveScroll = function(a) {
    PlayerSettings.instance.isPlanetUnlocked(a + 1) || PlayerSettings.instance.doUnlockNextWorld ? (this.m_screenItems.setCollagePos(a + 1), this.m_currentPage = a, this.m_scroll.goto(this.m_currentPage), Global.level = this.m_currentPage + 1, this.getControl("mcGuiBtnScrollLeft").setInteractive(0 === this.m_currentPage ? !1 : !0), this.getControl("mcGuiBtnScrollRight").setInteractive(this.m_currentPage === GuiSelectLocation.MAX_PLANET ? !1 : !0), this.getControl("mcGuiTextName").setTextLocalized("STR_SELECTLOCATION_PLANET0" +
        (this.m_currentPage + 1))) : this.m_scroll.goto(this.m_currentPage)
};
GuiSelectLocation.prototype.onPointerMove = function(a) {
    this.m_currentTouchIdentifier !== this.getIdentifier(a) || this.m_onUIPress || null === this.m_scroll || (this.m_moveTouch2.x = this.m_moveTouch1.x, this.m_moveTouch2.y = this.m_moveTouch1.y, this.m_moveTouch1.x = Math.floor(a.data.global.x), this.m_moveTouch1.y = Math.floor(a.data.global.y), this.m_screenItems.canvas.position.x = this.m_screenItems.canvas.ox + (this.m_moveTouch1.x - this.m_initTouch.x), this.m_screenItems.canvas.position.x = Math.max(-this.m_scroll.displaceX *
        (this.m_scroll.maxIndex + .5) + 1, Math.min(.5 * this.m_scroll.displaceX, this.m_screenItems.canvas.position.x)))
};
GuiSelectLocation.prototype.onPointerPress = function(a) {};
GuiSelectLocation.prototype.onPointerRelease = function(a) {};
GuiSelectLocation.prototype.updatePositions = function(a) {
    this.m_screenItems && (this.m_screenItems.canvas.position.x = -a.x)
};
GuiSelectLocation.prototype.onCompleteScroll = function(a) {
    this.m_isScrolling = !1
};
GuiSelectLocation.prototype.scrollLeft = function() {
    PlayerSettings.instance.doUnlockNextWorld || this.m_isScrolling || (Application.instance.playSound("SND_PLANET_SWIPE"), this.m_currentPage--, this.m_currentPage = 0 >= this.m_currentPage ? 0 : this.m_currentPage, this.m_scroll.duration = GuiSelectLocation.SCROLL_TIME_PRESS, this.onMoveScroll(this.m_currentPage), this.m_isScrolling = !0)
};
GuiSelectLocation.prototype.scrollRight = function() {
    PlayerSettings.instance.doUnlockNextWorld || this.m_isScrolling || this.m_currentPage < GuiSelectLocation.MAX_PLANET && !PlayerSettings.instance.isPlanetUnlocked(this.m_currentPage + 2) && !PlayerSettings.instance.doUnlockNextWorld || (Application.instance.playSound("SND_PLANET_SWIPE"), this.m_currentPage++, this.m_currentPage = this.m_currentPage >= GuiSelectLocation.MAX_PLANET ? GuiSelectLocation.MAX_PLANET : this.m_currentPage, this.m_scroll.duration = GuiSelectLocation.SCROLL_TIME_PRESS,
        this.onMoveScroll(this.m_currentPage), this.m_isScrolling = !0)
};
GuiSelectLocation.prototype.onUIPress = function(a) {
    if (!this.m_isScrolling && !this.m_animationUnlock) {
        SScreen.prototype.onUIPress.call(this, a);
        this.m_onUIPress = !0;
        "mcGuiBtnScrollLeft" !== a.name && "mcGuiBtnScrollRight" !== a.name && Application.instance.playSound("SND_UI_CLICK");
        if (Application.USE_CHEATS && (this.unlockAllCheatCounter++, 5 <= this.unlockAllCheatCounter)) Cheats.onEvent(Cheats.UNLOCK_ALL);
        switch (a.name) {
            case "mcGuiBtnScrollLeft":
                Application.RIGHT_TO_LEFT ? this.scrollRight() : this.scrollLeft();
                break;
            case "mcGuiBtnScrollRight":
                Application.RIGHT_TO_LEFT ? this.scrollLeft() : this.scrollRight();
                break;
            case "mcGuiBtnSoundOn":
            case "mcGuiBtnSoundOff":
                Application.instance.toggleMute()
        }
    }
};
GuiSelectLocation.prototype.onUIRelease = function(a) {
    SScreen.prototype.onUIRelease.call(this, a);
    if (this.activeRelease) {
        switch (a.name) {
            case "mcGuiBtnHelp":
                this.addPopup(GuiPopupHelp, "mcGuiPopupHelp", 0, 0);
                break;
            case "mcGuiBtnMoregames":
                GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU);
                break;
            case "mcGuiBtnBack":
                PlayerSettings.instance.isMultiplayer() ? GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_CHARACTER_MP) : GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_CHARACTER_SP)
        }
        this.activeRelease = !1;
        a.onResetState()
    }
};
GuiSelectLocation.prototype.update = function(a) {
    !Application.instance.isPlayingSound("SND_BG_MAINMENU") && Application.instance.isSoundOn() && Application.instance.playSound("SND_BG_MAINMENU");
    SScreen.prototype.update.call(this, a);
    this.controls && this.checkStateSound("mcGuiBtnSound");
    this.m_screenItems && this.m_screenItems.update(a);
    this.checkLateralBtns();
    a = this.m_currentPage + 1;
    this.m_currentPage < GuiSelectLocation.MAX_PLANET && !PlayerSettings.instance.isPlanetUnlocked(a + 1) && (Application.RIGHT_TO_LEFT ? this.getControl("mcGuiBtnScrollLeft").setVisible(!1) :
        this.getControl("mcGuiBtnScrollRight").setVisible(!1))
};
GuiSelectLocation.prototype.free = function() {
    this.m_scroll = null;
    GuiSelectLocation.instance = null;
    SScreen.prototype.free.call(this)
};

function GuiSelectLocationItems(a) {
    SScreen.call(this, a, 0, 0, null);
    this.m_maxLocked = 2;
    this.m_planets = [];
    for (a = 1; 3 >= a; a++) {
        var b = new GuiLocationPlanet("mcGuiScreenSelectLocationPlanets", a, PlayerSettings.instance.isPlanetUnlocked(a));
        this.getControl("mcGuiBtnPlanet0" + a).canvas.addChild(b.canvas);
        b.canvas.ox = 0;
        b.canvas.oy = 0;
        this.m_planets.push(b)
    }
    this.m_collage = null;
    this.percentageParallaxY = this.percentageParallaxX = this.m_initPostY_collage = this.m_initPostX_collage = 0;
    this.setCollagePos(1)
}
Application.subclass(GuiSelectLocationItems, SScreen);
GuiSelectLocationItems.prototype.update = function(a) {
    SScreen.prototype.update.call(this, a);
    for (var b = 0; b < this.m_planets.length; b++) this.m_planets[b] && this.m_planets[b].update(a)
};
GuiSelectLocationItems.prototype.setCollagePos = function(a) {
    this.m_collage = this.getControl("mcGuiCollage0" + a).clip;
    this.m_initPostX_collage = this.m_collage.position.x;
    this.m_initPostY_collage = this.m_collage.position.y;
    this.percentageParallaxY = this.percentageParallaxX = 0
};
GuiSelectLocationItems.prototype.onPointerMove = function(a) {
    this.percentageParallaxX = (a.data.global.x - Application.APP_WIDTH / 2) / Application.APP_WIDTH * .2;
    this.percentageParallaxY = (a.data.global.y - Application.APP_HEIGHT / 2) / Application.APP_HEIGHT * .2;
    1 < this.percentageParallaxX ? this.percentageParallaxX = 1 : -1 > this.percentageParallaxX && (this.percentageParallaxX = -1);
    1 < this.percentageParallaxY ? this.percentageParallaxY = 1 : -1 > this.percentageParallaxY && (this.percentageParallaxY = -1);
    this.m_collage && (this.m_collage.position.x =
        this.m_initPostX_collage + 75 * this.percentageParallaxX, this.m_collage.position.y = this.m_initPostY_collage + 30 * this.percentageParallaxY)
};

function GuiSelectCharacterSP(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = "selectCharacterSP";
    this.m_group = null;
    this.isActiveNextScreen = !1;
    this.m_timeScreen = 0;
    this.m_timeCompleted = !1;
    this.m_tweenText = this.m_tweenBase = null;
    Application.instance.isPlayingSound("SND_BG_MAINMENU") || (a = !Application.instance.isSoundOn(), Application.instance.soundManager.m_muted = !1, Application.instance.stopAllSounds(), Application.instance.soundManager.m_muted = a);
    this.onSelectChapter(Global.playerSelected);
    for (a = 1; 6 >= a; a++) this.getControl("mcGuiFxSelect0" +
        a).setVisible(!1), this.getControl("mcGuiFxSelect0" + a).clip.loop = !1, this.getControl("mcGuiBtnCharacter0" + a).enableLink = "mcGuiButtonCharacterSingleplayer0" + a + "_look", this.getControl("mcGuiBtnCharacter0" + a).overLink = "mcGuiButtonCharacterSingleplayer0" + a + "_on", this.getControl("mcGuiBtnCharacter0" + a).selectedLink = "mcGuiButtonCharacterSingleplayer0" + a + "_select", this.getControl("mcGuiBtnCharacter0" + a).gotoState(GuiControl.ST_ENABLE), this.getControl("mcGuiTextCharacterS0" + a).setTextLocalized("STR_SELECTCHARACTER_0" +
        a), this.getControl("mcGuiTextCharacter0" + a).setTextEmpty();
    this.getControl("mcGuiTextSubTitle").setTextEmpty();
    this.localizedTitle("gui_localized_title_selectcharacter", this.getControl("mcGuiTextTitle").clip, 450, 44);
    this.getControl("mcGuiTutorialText").setTextEmpty();
    this.getControl("mcGuiTutorialBase").setVisible(!1);
    this.canSelect = !1;
    this.getControl("mcGuiBtnMoregames").setVisible(!window.config.settings.HIDE_ARCADE_BUTTON)
}
Application.subclass(GuiSelectCharacterSP, SScreen);
GuiSelectCharacterSP.WAITING_TIME_NEXT_SCREEN = 0;
GuiSelectCharacterSP.prototype.onValidateOver = function(a) {
    this.isActiveNextScreen || (this.getControl("mcGuiTextCharacterS0" + a).setTextLocalized("STR_SELECTCHARACTER_0" + a), this.getControl("mcGuiTextCharacter0" + a).setTextEmpty())
};
GuiSelectCharacterSP.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    this.canSelect = !0
};
GuiSelectCharacterSP.prototype.showTap = function(a) {
    1 === a || 2 === a ? (this.getControl("mcGuiTutorialText").setTextLocalized("STR_TUTORIAL_SELECT" + a), this.getControl("mcGuiTutorialBase").setVisible(!0), null !== this.m_tweenBase && (this.m_tweenBase.stop(), this.m_tweenBase.free(), this.m_tweenBase = null), this.m_tweenBase = Common.tween({
        parent: this,
        clip: this.getControl("mcGuiTutorialBase").clip,
        sy: 0
    }, {
        sy: 1
    }, 350, !0, 700, TweenEasing.LinearNone), null !== this.m_tweenText && (this.m_tweenText.stop(), this.m_tweenText.free(),
        this.m_tweenText = null), this.m_tweenText = Common.tween({
        parent: this,
        clip: this.getControl("mcGuiTutorialText").canvas,
        alpha: 0,
        onComplete: this.onCompleteAppear
    }, {
        alpha: 1
    }, 350, !0, 800, TweenEasing.LinearNone)) : (null !== this.m_tweenBase && (this.m_tweenBase.stop(), this.m_tweenBase.free(), this.m_tweenBase = null), Common.tween({
        parent: this,
        clip: this.getControl("mcGuiTutorialBase").clip,
        sy: 1
    }, {
        sy: 0
    }, 350, !0, 0, TweenEasing.LinearNone), null !== this.m_tweenText && (this.m_tweenText.stop(), this.m_tweenText.free(), this.m_tweenText =
        null), Common.tween({
        parent: this,
        clip: this.getControl("mcGuiTutorialText").canvas,
        alpha: 1
    }, {
        alpha: 0
    }, 350, !0, 0, TweenEasing.LinearNone))
};
GuiSelectCharacterSP.prototype.onCompleteAppear = function(a) {
    null !== this.m_tweenText && Common.tween({
        parent: this,
        clip: this.getControl("mcGuiTutorialText").canvas,
        scale: .8
    }, {
        scale: 1.1
    }, 550, !0, 0, TweenEasing.BounceOut)
};
GuiSelectCharacterSP.prototype.onValidateOut = function(a) {
    this.isActiveNextScreen || (this.getControl("mcGuiTextCharacterS0" + a).setTextEmpty(), this.getControl("mcGuiTextCharacter0" + a).setTextLocalized("STR_SELECTCHARACTER_0" + a))
};
GuiSelectCharacterSP.prototype.onUIPress = function(a) {
    if (!this.isActiveNextScreen && this.clip.m_stopped) switch ("mcGuiBtnCharacter01" !== a.name && "mcGuiBtnCharacter02" !== a.name && "mcGuiBtnCharacter03" !== a.name && "mcGuiBtnCharacter04" !== a.name && "mcGuiBtnCharacter05" !== a.name && "mcGuiBtnCharacter06" !== a.name ? Application.instance.playSound("SND_UI_CLICK") : Application.instance.playSound("SND_SELECT_CHAR"), a.name) {
        case "mcGuiBtnNext":
            GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_LOCATION);
            break;
        case "mcGuiBtnHelp":
            this.addPopup(GuiPopupHelp,
                "mcGuiPopupHelp", 0, 0);
            break;
        case "mcGuiBtnSoundOn":
        case "mcGuiBtnSoundOff":
            Application.instance.toggleMute();
            break;
        case "mcGuiBtnMainmenu":
            GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU);
            break;
        case "mcGuiBtnMoregames":
            GuiPopupQuit.typeMessage = GuiPopupQuit.ARCADE;
            this.addPopup(GuiPopupQuit, "mcGuiPopupConfirm");
            break;
        case "mcGuiBtnCharacter01":
        case "mcGuiBtnCharacter02":
        case "mcGuiBtnCharacter03":
        case "mcGuiBtnCharacter04":
        case "mcGuiBtnCharacter05":
        case "mcGuiBtnCharacter06":
            a.gotoState(GuiControl.ST_SELECTED),
                Global.playerSelected = parseInt(a.name.substr(18), 10), PlayerSettings.instance.setPlayer(Global.playerSelected), this.onSelectChapter(Global.playerSelected), a.selectedLink = "mcGuiButtonCharacterSingleplayer0" + Global.playerSelected + "_select", this.isActiveNextScreen = !0, this.getControl("mcGuiFxSelect0" + Global.playerSelected).setVisible(!0), this.getControl("mcGuiFxSelect0" + Global.playerSelected).clip.gotoAndPlay(1)
    }
};
GuiSelectCharacterSP.prototype.onFinishScreen = function() {
    SScreen.prototype.onFinishScreen.call(this);
    this.startTransition();
    this.clip.stop()
};
GuiSelectCharacterSP.prototype.update = function(a) {
    !Application.instance.isPlayingSound("SND_BG_MAINMENU") && Application.instance.isSoundOn() && Application.instance.playSound("SND_BG_MAINMENU");
    this.isActiveNextScreen && !this.m_timeCompleted && (this.m_timeScreen += a, this.m_timeScreen >= GuiSelectCharacterSP.WAITING_TIME_NEXT_SCREEN && (this.m_timeScreen = 0, this.m_timeCompleted = !0, this.clip.resume()));
    SScreen.prototype.update.call(this, a);
    this.controls && this.checkStateSound("mcGuiBtnSound")
};
GuiSelectCharacterSP.prototype.startTransition = function() {
    var a = PoolClips.instance.getClip("mcGuiTransition_wipeout");
    this.getControl("mcGuiTransition").canvas.addChild(a);
    a.onEndAnimation(this, this.onEndTransition)
};
GuiSelectCharacterSP.prototype.onEndTransition = function() {
    PlayerSettings.instance.isFirstPlay() ? (MissionManager.instance.setMissionType(MissionManager.MISSION_TUTORIAL), Global.mission = 1, Global.level = 1, GuiManager.instance.gotoScreen(GuiManager.SC_TUTORIAL)) : GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_LOCATION)
};
GuiSelectCharacterSP.prototype.free = function() {
    this.m_group && (this.m_group.free(), this.m_group = null);
    SScreen.prototype.free.call(this)
};
GuiSelectCharacterSP.prototype.onSelectChapter = function(a) {};
GuiSelectCharacterSP.prototype.onOverIn = function(a) {
    this.canSelect && !this.isActiveNextScreen && (Application.instance.canvasEvents && (Application.instance.canvasEvents.style.cursor = "pointer"), SScreen.prototype.onOverIn.call(this, a), this.selectChar(a))
};
GuiSelectCharacterSP.prototype.onOverOut = function(a) {
    this.canSelect && (Application.instance.canvasEvents && (Application.instance.canvasEvents.style.cursor = "default"), SScreen.prototype.onOverOut.call(this, a))
};
GuiSelectCharacterSP.prototype.selectChar = function(a) {
    for (var b = 1; 6 >= b; b++) this.getControl("mcGuiBtnCharacter0" + b).state !== GuiControl.ST_SELECTED && (this.getControl("mcGuiBtnCharacter0" + b) !== a ? (this.getControl("mcGuiBtnCharacter0" + b).gotoState(GuiControl.ST_ENABLE), this.getControl("mcGuiTextCharacterS0" + b).setTextLocalized("STR_SELECTCHARACTER_0" + b), this.getControl("mcGuiTextCharacter0" + b).setTextEmpty()) : a.state !== GuiControl.ST_OVER && (a.gotoState(GuiControl.ST_OVER), Application.instance.playSound("SND_UI_CLICK")))
};

function GuiSelectCharacterMP(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = GuiManager.SC_SELECT_CHARACTER_MP;
    this.m_idSelected = 0;
    this.m_players = [0, 0];
    this.m_unLocked = [1, 2, 3, 4, 5, 6];
    this.isActiveNextScreen = !1;
    this.m_timeScreen = 0;
    this.m_timeCompleted = !1;
    this.selectedBtn = this.m_tweenText = this.m_tweenBase = null;
    Application.instance.isPlayingSound("SND_BG_MAINMENU") || (a = !Application.instance.isSoundOn(), Application.instance.soundManager.m_muted = !1, Application.instance.stopAllSounds(), Application.instance.soundManager.m_muted =
        a);
    this.disableControls();
    this.getControl("mcGuiTextSubTitle").setTextEmpty();
    this.setSubText(1);
    this.localizedTitle("gui_localized_title_selectcharacter", this.getControl("mcGuiTextTitle").clip, 450, 44);
    this.getControl("mcGuiTutorialText").setTextEmpty();
    this.getControl("mcGuiTutorialBase").setVisible(!1);
    for (a = 1; 6 >= a; a++) this.getControl("mcGuiFxSelect0" + a).setVisible(!1), this.getControl("mcGuiFxSelect0" + a).clip.loop = !1, this.getControl("mcGuiTextCharacterS0" + a).setTextLocalized("STR_SELECTCHARACTER_0" +
        a), this.getControl("mcGuiTextCharacter0" + a).setTextEmpty();
    this.setButtonsForPlayer(1);
    this.canSelect = !1;
    this.getControl("mcGuiBtnMoregames").setVisible(!window.config.settings.HIDE_ARCADE_BUTTON)
}
Application.subclass(GuiSelectCharacterMP, SScreen);
GuiSelectCharacterMP.MAX_SELECTED_PLAYERS = 2;
GuiSelectCharacterMP.MAX_PLAYERS = 6;
GuiSelectCharacterMP.WAITING_TIME_NEXT_SCREEN = 0;
GuiSelectCharacterMP.prototype.onUIPress = function(a) {
    if (!this.m_timeCompleted && this.clip.m_stopped) switch (SScreen.prototype.onUIPress.call(this, a), "mcGuiBtnCharacter01" !== a.name && "mcGuiBtnCharacter02" !== a.name && "mcGuiBtnCharacter03" !== a.name && "mcGuiBtnCharacter04" !== a.name && "mcGuiBtnCharacter05" !== a.name && "mcGuiBtnCharacter06" !== a.name ? Application.instance.playSound("SND_UI_CLICK") : Application.instance.playSound("SND_SELECT_CHAR"), a.name) {
        case "mcGuiBtnHelp":
            this.isActiveNextScreen || this.addPopup(GuiPopupHelp,
                "mcGuiPopupHelp", 0, 0);
            break;
        case "mcGuiBtnSoundOn":
        case "mcGuiBtnSoundOff":
            Application.instance.toggleMute();
            break;
        case "mcGuiBtnMainmenu":
            this.isActiveNextScreen || GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU);
            break;
        case "mcGuiBtnMoregames":
            GuiPopupQuit.typeMessage = GuiPopupQuit.ARCADE;
            this.addPopup(GuiPopupQuit, "mcGuiPopupConfirm");
            break;
        case "mcGuiBtnUndo01":
        case "mcGuiBtnUndo02":
        case "mcGuiBtnUndo03":
        case "mcGuiBtnUndo04":
        case "mcGuiBtnUndo05":
        case "mcGuiBtnUndo06":
            this.applyUndo();
            break;
        case "mcGuiBtnCharacter01":
        case "mcGuiBtnCharacter02":
        case "mcGuiBtnCharacter03":
        case "mcGuiBtnCharacter04":
        case "mcGuiBtnCharacter05":
        case "mcGuiBtnCharacter06":
            if (this.m_idSelected < GuiSelectCharacterMP.MAX_SELECTED_PLAYERS && !this.isActiveNextScreen) {
                var b = parseInt(a.name.substr(18), 10);
                this.onSelectChapter(a, b)
            }
    }
};
GuiSelectCharacterMP.prototype.setSubText = function(a) {
    0 === a ? this.getControl("mcGuiTextSubTitle").setTextEmpty() : this.getControl("mcGuiTextSubTitle").setTextLocalized("STR_MESSAGE_PLAYER_" + a)
};
GuiSelectCharacterMP.prototype.showTap = function(a) {
    1 === a || 2 === a ? (this.getControl("mcGuiTutorialText").setTextLocalized("STR_TUTORIAL_SELECT" + a), this.getControl("mcGuiTutorialBase").setVisible(!0), null !== this.m_tweenBase && (this.m_tweenBase.stop(), this.m_tweenBase.free(), this.m_tweenBase = null), this.m_tweenBase = Common.tween({
        parent: this,
        clip: this.getControl("mcGuiTutorialBase").clip,
        sy: 0
    }, {
        sy: 1
    }, 350, !0, 700, TweenEasing.LinearNone), null !== this.m_tweenText && (this.m_tweenText.stop(), this.m_tweenText.free(),
        this.m_tweenText = null), this.m_tweenText = Common.tween({
        parent: this,
        clip: this.getControl("mcGuiTutorialText").canvas,
        alpha: 0,
        onComplete: this.onCompleteAppear
    }, {
        alpha: 1
    }, 350, !0, 800, TweenEasing.LinearNone)) : (null !== this.m_tweenBase && (this.m_tweenBase.stop(), this.m_tweenBase.free(), this.m_tweenBase = null), Common.tween({
        parent: this,
        clip: this.getControl("mcGuiTutorialBase").clip,
        sy: 1
    }, {
        sy: 0
    }, 350, !0, 0, TweenEasing.LinearNone), null !== this.m_tweenText && (this.m_tweenText.stop(), this.m_tweenText.free(), this.m_tweenText =
        null), Common.tween({
        parent: this,
        clip: this.getControl("mcGuiTutorialText").canvas,
        alpha: 1
    }, {
        alpha: 0
    }, 350, !0, 0, TweenEasing.LinearNone))
};
GuiSelectCharacterMP.prototype.onCompleteAppear = function(a) {
    null !== this.m_tweenText && Common.tween({
        parent: this,
        clip: this.getControl("mcGuiTutorialText").canvas,
        scale: .8
    }, {
        scale: 1.1
    }, 550, !0, 0, TweenEasing.BounceOut)
};
GuiSelectCharacterMP.prototype.onValidateOver = function(a) {
    this.getControl("mcGuiTextCharacterS0" + a).setTextLocalized("STR_SELECTCHARACTER_0" + a);
    this.getControl("mcGuiTextCharacter0" + a).setTextEmpty()
};
GuiSelectCharacterMP.prototype.onValidateOut = function(a) {
    this.getControl("mcGuiTextCharacterS0" + a).setTextEmpty();
    this.getControl("mcGuiTextCharacter0" + a).setTextLocalized("STR_SELECTCHARACTER_0" + a)
};
GuiSelectCharacterMP.prototype.disableControls = function() {
    for (var a = 0; a < GuiSelectCharacterMP.MAX_PLAYERS; a++) this.getControl("mcGuiTextTag0" + (a + 1)).setTextEmpty(), this.getControl("mcGuiBtnUndo0" + (a + 1)).setVisible(!1), this.getControl("mcGuiCharacter0" + (a + 1) + "_Player").setVisible(!1), this.getControl("mcGuiFxSelect0" + (a + 1)).setVisible(!1), this.getControl("mcGuiFxSelect0" + (a + 1)).clip.loop = !1
};
GuiSelectCharacterMP.prototype.activeUndo = function(a) {
    for (var b = 0; b < GuiSelectCharacterMP.MAX_PLAYERS; b++) this.getControl("mcGuiBtnUndo0" + (b + 1)).setVisible(!1);
    this.getControl("mcGuiBtnUndo0" + a).setVisible(!0)
};
GuiSelectCharacterMP.prototype.applyUndo = function() {
    0 !== this.m_idSelected && (this.isActiveNextScreen = !1, this.m_timeScreen = 0, this.m_timeCompleted = !1, 2 === this.m_idSelected ? (this.m_idSelected = 1, this.activeUndo(this.m_players[0]), this.getControl("mcGuiTextTag0" + this.m_players[this.m_idSelected]).setTextEmpty(), this.getControl("mcGuiBtnUndo0" + this.m_players[this.m_idSelected]).setVisible(!1), this.getControl("mcGuiCharacter0" + this.m_players[this.m_idSelected] + "_Player").setVisible(!1), this.setSubText(2),
        this.m_players[this.m_idSelected] = 0, this.m_fxSelect02 && (this.m_fxSelect02.isAwaitingDelete = !0, this.m_fxSelect02 = null), this.setButtonsForPlayer(2, this.getControl("mcGuiBtnCharacter0" + this.m_players[0]))) : (this.m_idSelected = 0, this.setSubText(1), this.m_players[this.m_idSelected] = 0, this.disableControls(), this.m_fxSelect01 && (this.m_fxSelect01.isAwaitingDelete = !0, this.m_fxSelect01 = null), this.setButtonsForPlayer(1)))
};
GuiSelectCharacterMP.prototype.setButtonsForPlayer = function(a, b) {
    for (var c = 1; 6 >= c; c++) this.getControl("mcGuiBtnCharacter0" + c) !== b && (this.getControl("mcGuiBtnCharacter0" + c).enableLink = "mcGuiButtonCharacterSingleplayer0" + c + (2 === a ? "_look_p2" : "_look"), this.getControl("mcGuiBtnCharacter0" + c).overLink = "mcGuiButtonCharacterSingleplayer0" + c + (2 === a ? "_on_p2" : "_on"), this.getControl("mcGuiBtnCharacter0" + c).selectedLink = "mcGuiButtonCharacterSingleplayer0" + c + (2 === a ? "_select_p2" : "_select"), this.getControl("mcGuiBtnCharacter0" +
        c).gotoState(GuiControl.ST_ENABLE), this.getControl("mcGuiCharacter0" + c + "_Player").clip.gotoAndStop(a))
};
GuiSelectCharacterMP.prototype.onSelectChapter = function(a, b) {
    for (var c = 0; c < this.m_unLocked.length; c++) {
        for (var d = !1, e = 0; e < this.m_players.length; e++)
            if (0 !== this.m_players[e] && this.m_players[e] === this.m_unLocked[c]) {
                d = !0;
                break
            }
        d || (a.enableLink = 0 === this.m_idSelected ? "mcGuiButtonCharacterSingleplayer0" + b + "_look" : "mcGuiButtonCharacterSingleplayer0" + b + "_look_p2", this.getControl("mcGuiBtnCharacter0" + this.m_unLocked[c]).state === GuiControl.ST_SELECTED && this.m_unLocked[c] !== b && (this.getControl("mcGuiBtnCharacter0" +
            this.m_unLocked[c]).enabled = !0, this.getControl("mcGuiBtnCharacter0" + this.m_unLocked[c]).gotoState(GuiControl.ST_ENABLE)))
    }
    this.m_players[this.m_idSelected] = b;
    this.getControl("mcGuiBtnCharacter0" + b).gotoState(GuiControl.ST_SELECTED);
    this.activeUndo(b);
    this.getControl("mcGuiCharacter0" + this.m_players[this.m_idSelected] + "_Player").setVisible(!0);
    this.getControl("mcGuiTextTag0" + b).setTextLocalized("STR_SELECTCHARACTER_P" + (this.m_idSelected + 1));
    this.getControl("mcGuiFxSelect0" + b).setVisible(!0);
    this.getControl("mcGuiFxSelect0" +
        b).clip.gotoAndPlay(1);
    a.gotoState(GuiControl.ST_SELECTED);
    0 === this.m_idSelected ? (this.setSubText(2), this.m_idSelected = 1, this.setButtonsForPlayer(2, a)) : 1 === this.m_idSelected && (this.setSubText(0), this.m_idSelected = 2, this.isActiveNextScreen = !0)
};
GuiSelectCharacterMP.prototype.update = function(a) {
    !Application.instance.isPlayingSound("SND_BG_MAINMENU") && Application.instance.isSoundOn() && Application.instance.playSound("SND_BG_MAINMENU");
    this.isActiveNextScreen && !this.m_timeCompleted && this.clip.m_stopped && (this.m_timeScreen += a, this.m_timeScreen >= GuiSelectCharacterMP.WAITING_TIME_NEXT_SCREEN && (this.m_timeScreen = 0, this.m_timeCompleted = !0, Global.playersForGame = [this.m_players[0], this.m_players[1]], Global.playerSelected = this.m_players[0], this.clip.resume()));
    SScreen.prototype.update.call(this, a);
    this.controls && this.checkStateSound("mcGuiBtnSound")
};
GuiSelectCharacterMP.prototype.onEndTransition = function() {
    GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_LOCATION)
};
GuiSelectCharacterMP.prototype.selectChar = function(a) {
    for (var b = 1; 6 >= b; b++) this.getControl("mcGuiBtnCharacter0" + b).state !== GuiControl.ST_SELECTED && (this.getControl("mcGuiBtnCharacter0" + b) !== a ? (this.getControl("mcGuiBtnCharacter0" + b).gotoState(GuiControl.ST_ENABLE), this.getControl("mcGuiTextCharacterS0" + b).setTextLocalized("STR_SELECTCHARACTER_0" + b), this.getControl("mcGuiTextCharacter0" + b).setTextEmpty()) : a.state !== GuiControl.ST_OVER && (a.gotoState(GuiControl.ST_OVER), Application.instance.playSound("SND_UI_CLICK")))
};
GuiSelectCharacterMP.prototype.onOverIn = function(a) {
    this.canSelect && !this.isActiveNextScreen && (Application.instance.canvasEvents && (Application.instance.canvasEvents.style.cursor = "pointer"), SScreen.prototype.onOverIn.call(this, a), this.selectChar(a))
};
GuiSelectCharacterMP.prototype.onOverOut = function(a) {
    this.canSelect && (Application.instance.canvasEvents && (Application.instance.canvasEvents.style.cursor = "default"), SScreen.prototype.onOverOut.call(this, a))
};
GuiSelectCharacterMP.prototype.startTransition = function() {
    var a = PoolClips.instance.getClip("mcGuiTransition_wipeout");
    this.getControl("mcGuiTransition").canvas.addChild(a);
    a.onEndAnimation(this, this.onEndTransition)
};
GuiSelectCharacterMP.prototype.onFinishScreen = function() {
    SScreen.prototype.onFinishScreen.call(this);
    this.startTransition();
    this.clip.stop()
};
GuiSelectCharacterMP.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    this.canSelect = !0
};

function GuiCutscene(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.m_currentScene = this.cantScenes = 1;
    this.initInfo()
}
Application.subclass(GuiCutscene, SScreen);
GuiCutscene.CS_INIT_SINGLE_PLAYER = 1;
GuiCutscene.CS_INIT_MULTI_PLAYER = 2;
GuiCutscene.CS_INIT_VS = 3;
GuiCutscene.CS_ENDGAME = 4;
GuiCutscene.typeCutscene = GuiCutscene.CS_INIT_SINGLE_PLAYER;
GuiCutscene.prototype.initInfo = function() {
    switch (GuiCutscene.typeCutscene) {
        case GuiCutscene.CS_INIT_SINGLE_PLAYER:
            this.cantScenes = 1;
            this.getControl("mcGuiTextInfo").setTextLocalized("STR_CUTSCENE_INFO_INIT_SINGLE_PLAYER");
            break;
        case GuiCutscene.CS_INIT_MULTI_PLAYER:
            this.cantScenes = 1;
            this.getControl("mcGuiTextInfo").setTextLocalized("STR_CUTSCENE_INFO_INIT_MULTI_PLAYER");
            break;
        case GuiCutscene.CS_INIT_VS:
            this.cantScenes = 1;
            this.getControl("mcGuiTextInfo").setTextLocalized("STR_CUTSCENE_INFO_INIT_VS");
            break;
        case GuiCutscene.CS_ENDGAME:
            this.localizedTitle("gui_localized_title_endgame", this.getControl("mcGuiTextCongrats").clip, 450, 44);
            return
    }
    this.getControl("mcGuiImage").setClip("gui_screens_cutscene_image01");
    if (GuiCutscene.typeCutscene === GuiCutscene.CS_INIT_SINGLE_PLAYER || GuiCutscene.typeCutscene === GuiCutscene.CS_INIT_MULTI_PLAYER) this.getControl("mcGuiBtnSkip").setVisible(!1), this.getControl("mcGuiBtnMainmenu02").setVisible(!1)
};
GuiCutscene.prototype.onUIPress = function(a) {
    switch (a.name) {
        case "mcGuiBtnMainmenu":
            GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU);
            break;
        case "mcGuiBtnSkip":
        case "mcGuiBtnMainmenu02":
        case "mcGuiBtnPlay":
            this.nextScreen();
            break;
        case "mcGuiBtnNext":
            GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU)
    }
};
GuiCutscene.prototype.nextScreen = function() {
    Global.viewInitCutscene = 1;
    GuiCutscene.typeCutscene === GuiCutscene.CS_INIT_SINGLE_PLAYER ? GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_CHARACTER_SP) : GuiCutscene.typeCutscene === GuiCutscene.CS_INIT_MULTI_PLAYER && GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_CHARACTER_MP)
};

function GuiManager() {
    Global.data = new DataManager;
    new Settings(Application.config);
    new PlayerSettings;
    new MissionManager;
    GhostingManager.instance = new GhostingManager;
    ScreenManager.call(this);
    GuiManager.instance = this;
    PoolClips.initialize();
    window.USE_SANBOX || ScoreAPI.initialize()
}
Application.subclass(GuiManager, ScreenManager);
GuiManager.prototype.onGetScores = function(a) {
    if (!a.error)
        for (var b = null, c = 0; c < a.results.length; c++) b = a.results[c], Application.info("[TEST REQUEST SCORE] " + c + " >> " + b.score_int + " by " + b.name_str)
};
GuiManager.prototype.onSendScores = function(a) {};
GuiManager.instance = null;
GuiManager.sandboxGuiView = "";
GuiManager.SC_SANDBOX = "gui_sandbox";
GuiManager.SC_SANBOX_GUI_VIEW = "gui_sandbox_gui_view";
GuiManager.SC_SANBOX_NANO_VIEW = "gui_sandbox_nano_view";
GuiManager.SC_SOUND_LOADER = "gui_soundloader";
GuiManager.SC_PRELOAD = "gui_preload";
GuiManager.SC_LOADER = "gui_loader";
GuiManager.SC_MAIN_MENU = "gui_main_menu";
GuiManager.SC_GAME = "gui_game";
GuiManager.SC_CUTSCENE = "gui_cutscene";
GuiManager.SC_ENDGAME = "gui_endgame";
GuiManager.SC_SELECT_LOCATION = "gui_select_location";
GuiManager.SC_SELECT_CHARACTER_SP = "gui_select_character_single";
GuiManager.SC_SELECT_CHARACTER_MP = "gui_select_character_multi";
GuiManager.SC_END_GAME = "gui_end_game";
GuiManager.SC_TUTORIAL = "gui_tutorial";
GuiManager.POPUP_HELP = "popup_help";
GuiManager.POPUP_QUIT = "popup_quit";
GuiManager.POPUP_INTRO = "popup_intro";
GuiManager.POPUP_PAUSE = "popup_pause";
GuiManager.POPUP_RESET = "popup_reset";
GuiManager.POPUP_INTRO_VS = "popup_intro_vs";
GuiManager.POPUP_TROPHIES = "popup_trophies";
GuiManager.POPUP_TRYAGAIN = "popup_tryagain";
GuiManager.POPUP_SELECT_MODE = "popup_select_mode";
GuiManager.POPUP_ENDLEVEL_SP = "popup_endLevel_sp";
GuiManager.POPUP_ENDLEVEL_VS = "popup_endLevel_vs";
GuiManager.POPUP_ENDLEVEL_COOP = "popup_endLevel_coop";
GuiManager.POPUP_ENDLEVEL_DRAW = "popup_endLevel_draw";
GuiManager.POPUP_SELECT_MISSION = "popup_select_mission";
GuiManager.POPUP_INTRO_MISSIONS = "popup_intro_missions";
GuiManager.POPUP_LIBERATION_ALERT = "popup_liberation_alert";
GuiManager.prototype.gotoScreen = function(a) {
    ScreenManager.prototype.gotoScreen.call(this, a);
    switch (a) {
        case GuiManager.SC_SANBOX_GUI_VIEW:
            a = Application.RIGHT_TO_LEFT ? "sandbox_gui_test_rtl" : "sandbox_gui_test";
            window.Assets[a] ? (this.currentScreen = new GuiLoader("mcGuiScreenLoader", window.Assets[a], GuiManager.SC_SANBOX_GUI_VIEW), window.Assets[a] = null) : this.currentScreen = new DebugScreen(GuiManager.sandboxGuiView);
            break;
        case GuiManager.SC_SANBOX_NANO_VIEW:
            a = "sandbox_nano";
            window.Assets[a] ? (this.currentScreen =
                new GuiLoader("mcGuiScreenLoader", window.Assets[a], GuiManager.SC_SANBOX_NANO_VIEW), window.Assets[a] = null) : this.currentScreen = new DebugScreenNano;
            break;
        case GuiManager.SC_PRELOAD:
            window.Assets.preload && (this.currentScreen = window.Assets.localizedImages ? new GuiLoader("", window.Assets.preload, "", 0, 100, !0, window.Assets.localizedImages) : new GuiLoader("", window.Assets.preload, "", 0, 100, !0), window.Assets.preload = null);
            break;
        case GuiManager.SC_SOUND_LOADER:
            this.currentScreen = new GuiLoader("mcGuiScreenLoader",
                null, GuiManager.SC_MAIN_MENU, 0, Application.SOUND_PERCENT);
            break;
        case GuiManager.SC_MAIN_MENU:
            Global.level = 1;
            a = Application.RIGHT_TO_LEFT ? "media1_rtl" : "media1_ltr";
            SLoader.checkTexturesLoaded(window.Assets[a]) ? this.currentScreen = new GuiMainMenu("mcGuiScreenMainMenu") : this.currentScreen = new GuiLoader("mcGuiScreenLoader", window.Assets[a], GuiManager.SC_MAIN_MENU, Application.SOUND_PERCENT, 100);
            break;
        case GuiManager.SC_GAME:
            var b = "gamePlatform",
                c = "world" + Global.level;
            window.Assets[b] ? (a = window.Assets[b].concat(window.Assets[c]),
                this.currentScreen = new GuiLoader("mcGuiScreenLoader", a, GuiManager.SC_GAME), window.Assets[b] = null, window.Assets[c] = null) : window.Assets[c] ? (this.currentScreen = new GuiLoader("mcGuiScreenLoader", window.Assets[c], GuiManager.SC_GAME), window.Assets[c] = null) : this.currentScreen = new GuiGame;
            break;
        case GuiManager.SC_CUTSCENE:
            this.currentScreen = new GuiCutscene("mcGuiScreenCutscene");
            break;
        case GuiManager.SC_ENDGAME:
            GuiCutscene.typeCutscene = GuiCutscene.CS_ENDGAME;
            this.currentScreen = new GuiCutscene("mcGuiScreenEndgame");
            a = !Application.instance.isSoundOn();
            Application.instance.soundManager.m_muted = !1;
            Application.instance.stopAllSounds();
            Application.instance.playSound("SND_BG_ENDGAME");
            Application.instance.soundManager.m_muted = a;
            break;
        case GuiManager.SC_SELECT_LOCATION:
            window.Assets.media2 ? (this.currentScreen = new GuiLoader("mcGuiScreenLoader", window.Assets.media2, GuiManager.SC_SELECT_LOCATION), window.Assets.media2 = null) : this.currentScreen = new GuiSelectLocation("mcGuiScreenSelectLocation");
            break;
        case GuiManager.SC_TUTORIAL:
            b =
                "gamePlatform";
            window.Assets[b] ? (a = window.Assets[b].concat(window.Assets.world1), a = a.concat(window.Assets.media2), this.currentScreen = new GuiLoader("mcGuiScreenLoader", a, GuiManager.SC_TUTORIAL), window.Assets[b] = null, window.Assets.world1 = null, window.Assets.media2 = null) : this.currentScreen = new GuiGame;
            break;
        case GuiManager.SC_SELECT_CHARACTER_SP:
            this.currentScreen = new GuiSelectCharacterSP("mcGuiScreenSelectCharacterSingleplayer");
            break;
        case GuiManager.SC_SELECT_CHARACTER_MP:
            this.currentScreen = new GuiSelectCharacterMP("mcGuiScreenSelectCharacterMultiplayer");
            break;
        case GuiManager.SC_SANDBOX:
            window.Assets.sandbox ? (this.currentScreen = new GuiLoader("mcGuiScreenLoader", window.Assets.sandbox, GuiManager.SC_SANDBOX), window.Assets.sandbox = null) : this.currentScreen = new GuiGame
    }
};
GuiManager.prototype.sendToMainMenu = function() {
    Global.comingFromTutorial = !0;
    GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU)
};
GuiManager.prototype.reloadMainMenu = function() {
    GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU)
};
GuiManager.prototype.onKeyDown = function(a) {
    ScreenManager.prototype.onKeyDown.call(this, a);
    Cheats.onKeyDown(a)
};
GuiManager.prototype.onKeyUp = function(a) {
    ScreenManager.prototype.onKeyUp.call(this, a);
    Cheats.onKeyUp(a)
};
GuiManager.prototype.free = function() {
    GuiManager.instance = null;
    ScreenManager.prototype.free.call(this)
};

function GuiPopupHelp(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.maxPage = window.config.settings.HIDE_ARCADE_BUTTON ? GuiPopupHelp.MAX_PAGE - 1 : GuiPopupHelp.MAX_PAGE;
    this.name = GuiManager.POPUP_HELP;
    this.m_currentPage = 0;
    this.mask = (new window.PIXI.Graphics).beginFill(16711680).drawRect(275, 240, 465, 270);
    this.getControl("mcGuiContent2").canvas.addChild(this.mask);
    this.m_scroll = null;
    this.m_moveScroll = !1;
    this.m_introPage = !0;
    this.m_isScrolling = !1;
    this.m_screenItems = null;
    this.m_currentTouchIdentifier = GuiPopupHelp.TOUCH_ID_NONE;
    this.m_onUIPress = !1;
    this.m_group = null;
    this.m_screenItems = new GuiPopupHelpItems("mcGuiPopupHelpItems");
    this.m_screenItems.canvas.ox = 0;
    this.m_screenItems.canvas.oy = 0;
    this.getControl("mcGuiContent").canvas.addChild(this.m_screenItems.canvas);
    this.initScreenItems();
    this.m_screenItems.clip.mask = this.mask;
    this.m_initTouch = new Point;
    this.m_moveTouch1 = new Point;
    this.m_moveTouch2 = new Point;
    this.m_scroll = new ScrollHandler;
    this.m_scroll.maxIndex = this.maxPage;
    this.m_scroll.displaceX = 550;
    this.m_scroll.duration =
        GuiPopupHelp.SCROLL_TIME_PRESS;
    this.m_scroll.index = this.m_currentPage;
    this.m_scroll.addUpdateListener(this, this.updatePositions);
    this.m_scroll.addCompleteListener(this, this.onCompleteScroll);
    this.m_minDistance = Application.instance.isMobileDevice ? 5 : 2;
    this.m_distanceFactor = Application.instance.isMobileDevice ? 22 : 12;
    this.m_group = new ControlGroup;
    window.config.settings.HIDE_ARCADE_BUTTON && (this.getControl("mcGuiBtnSlice_7").setVisible(!1), this.m_screenItems.getControl("mcGuiPanel_7").setVisible(!1));
    for (a =
        1; a <= this.maxPage + 1; a++) this.m_group.addControl(this.getControl("mcGuiBtnSlice_" + a));
    this.localizedTitle("gui_localized_title_help", this.getControl("mcGuiTextTitle").clip, 450, 44);
    this.onMoveScroll(this.m_currentPage);
    this.screenParent && (this.screenParent.name === GuiManager.POPUP_PAUSE ? this.getControl("mcGuiBg").setVisible(!1) : this.applyBlur());
    Application.instance.playSound("SND_UI_POPUP_GENERAL")
}
Application.subclass(GuiPopupHelp, SScreen);
GuiPopupHelp.MAX_PAGE = 6;
GuiPopupHelp.SCROLL_TIME_PRESS = 250;
GuiPopupHelp.TOUCH_ID_NONE = -100;
GuiPopupHelp.prototype.initScreenItems = function() {
    var a = "";
    switch (PlayerSettings.instance.m_currentPlayer) {
        case PlayerSettings.TYPE_KANAN:
            a = "_kanan";
            break;
        case PlayerSettings.TYPE_SABINE:
            a = "_sabine";
            break;
        case PlayerSettings.TYPE_HERA:
            a = "_hera";
            break;
        case PlayerSettings.TYPE_ZEB:
            a = "_zeb";
            break;
        case PlayerSettings.TYPE_CHOPPER:
            a = "_chopper"
    }
    for (var b = 1; b <= this.maxPage + 1; b++) this.m_screenItems.getControl("mcGuiPanel_" + b).setClip("gui_popups_help_image0" + b + a)
};
GuiPopupHelp.prototype.getIdentifier = function(a) {
    return "undefined" !== typeof a.data.identifier ? a.data.identifier : a.data.originalEvent.which
};
GuiPopupHelp.prototype.onCompleteScroll = function(a) {
    this.m_screenItems.canvas.position.x = Application.RIGHT_TO_LEFT ? a.x : -a.x;
    this.m_isScrolling = !1
};
GuiPopupHelp.prototype.onPointerMove = function(a) {
    this.m_currentTouchIdentifier !== this.getIdentifier(a) || this.m_onUIPress || (this.m_moveTouch2.x = this.m_moveTouch1.x, this.m_moveTouch2.y = this.m_moveTouch1.y, this.m_moveTouch1.x = Math.floor(a.data.global.x), this.m_moveTouch1.y = Math.floor(a.data.global.y), Application.RIGHT_TO_LEFT ? (this.m_screenItems.canvas.position.x = -(this.m_screenItems.canvas.ox + (this.m_moveTouch1.x - this.m_initTouch.x)), this.m_screenItems.canvas.position.x = -Math.max(-this.m_scroll.displaceX *
        (this.m_scroll.maxIndex + .5) + 1, Math.min(.5 * this.m_scroll.displaceX, this.m_screenItems.canvas.position.x))) : (this.m_screenItems.canvas.position.x = this.m_screenItems.canvas.ox + (this.m_moveTouch1.x - this.m_initTouch.x), this.m_screenItems.canvas.position.x = Math.max(-this.m_scroll.displaceX * (this.m_scroll.maxIndex + .5) + 1, Math.min(.5 * this.m_scroll.displaceX, this.m_screenItems.canvas.position.x))))
};
GuiPopupHelp.prototype.onPointerPress = function(a) {
    this.m_currentTouchIdentifier !== GuiPopupHelp.TOUCH_ID_NONE || this.m_onUIPress || (this.m_currentTouchIdentifier = this.getIdentifier(a), this.m_initTouch.x = this.m_moveTouch1.x = this.m_moveTouch2.x = Math.floor(a.data.global.x), this.m_initTouch.y = this.m_moveTouch1.y = this.m_moveTouch2.y = Math.floor(a.data.global.y), this.m_scroll.cancel(), this.m_scroll.index = Math.floor((-this.m_screenItems.canvas.position.x + .5 * this.m_scroll.displaceX) / this.m_scroll.displaceX),
        this.m_screenItems.canvas.ox = this.m_screenItems.canvas.position.x)
};
GuiPopupHelp.prototype.onPointerRelease = function(a) {
    if (this.m_currentTouchIdentifier !== this.getIdentifier(a) || this.m_onUIPress) this.m_onUIPress = !1;
    else {
        this.m_scroll.x = Application.RIGHT_TO_LEFT ? this.m_screenItems.canvas.position.x : -this.m_screenItems.canvas.position.x;
        var b = 0;
        a = Math.floor(a.data.global.x) - this.m_moveTouch2.x;
        Math.abs(a) <= this.m_minDistance ? (this.m_scroll.duration = 200, b = Application.RIGHT_TO_LEFT ? Math.floor((this.m_screenItems.canvas.position.x + .5 * this.m_scroll.displaceX) / this.m_scroll.displaceX) :
            Math.floor((-this.m_screenItems.canvas.position.x + .5 * this.m_scroll.displaceX) / this.m_scroll.displaceX)) : (b = 0 > a ? Application.RIGHT_TO_LEFT ? SMath.setRange(-this.m_scroll.index - 1 - Math.floor(-a / this.m_distanceFactor), this.m_scroll.maxIndex, 0) : SMath.setRange(this.m_scroll.index + 1 + Math.floor(-a / this.m_distanceFactor), this.m_scroll.maxIndex, 0) : Application.RIGHT_TO_LEFT ? SMath.setRange(-this.m_scroll.index + 1 + Math.floor(a / this.m_distanceFactor), this.m_scroll.maxIndex, 0) : SMath.setRange(this.m_scroll.index - 1 -
            Math.floor(a / this.m_distanceFactor), this.m_scroll.maxIndex, 0), this.m_scroll.duration = GuiPopupHelp.SCROLL_TIME_PRESS + 80 * Math.abs(this.m_scroll.index - b));
        this.onMoveScroll(b);
        this.m_isScrolling = !0;
        this.m_currentTouchIdentifier = GuiPopupHelp.TOUCH_ID_NONE
    }
};
GuiPopupHelp.prototype.updatePositions = function(a) {
    this.m_screenItems.canvas.position.x = Application.RIGHT_TO_LEFT ? a.x : -a.x
};
GuiPopupHelp.prototype.onUIOut = function(a) {
    SScreen.prototype.onUIOut.call(this, a);
    this.lastInteractionControl = ""
};
GuiPopupHelp.prototype.onUIPress = function(a) {
    if (!this.m_isScrolling && !this.onPress) switch (SScreen.prototype.onUIPress.call(this, a), Application.instance.playSound("SND_UI_CLICK"), this.m_onUIPress = !0, a.name) {
        case "mcGuiBtnScrollRight":
            this.scrollImageRight();
            break;
        case "mcGuiBtnScrollLeft":
            this.scrollImageLeft();
            break;
        case "mcGuiBtnSlice_1":
        case "mcGuiBtnSlice_2":
        case "mcGuiBtnSlice_3":
        case "mcGuiBtnSlice_4":
        case "mcGuiBtnSlice_5":
        case "mcGuiBtnSlice_6":
        case "mcGuiBtnSlice_7":
            this.m_currentPage = parseInt(a.name.substr(14),
                10) - 1, this.m_scroll.duration = GuiPopupHelp.SCROLL_TIME_PRESS, this.onMoveScroll(this.m_currentPage)
    }
};
GuiPopupHelp.prototype.onUIRelease = function(a) {
    SScreen.prototype.onUIRelease.call(this, a);
    if (this.activeRelease && !this.onPress) {
        switch (a.name) {
            case "mcGuiBtnClose":
                if (this.onPress = !0, GuiGame.instance) this.screenParent.onActionScreen();
                else this.screenParent.dropPopup()
        }
        this.activeRelease = !1;
        a.onResetState()
    }
};
GuiPopupHelp.prototype.onMoveScroll = function(a) {
    this.m_currentPage = SMath.setRange(a, this.maxPage, 0);
    this.m_scroll.goto(this.m_currentPage);
    a = "";
    4 < this.m_currentPage + 1 && 7 !== this.m_currentPage + 1 && (a = PlayerSettings.instance.isPlayerMelee() || PlayerSettings.instance.m_currentPlayer === PlayerSettings.TYPE_NONE ? "_M" : "_R");
    this.getControl("mcGuiTextInfo").setTextLocalized("STR_HELP_PAGE_" + (this.m_currentPage + 1) + a + (Application.instance.isMobileDevice ? "_MOBILE" : ""));
    Application.RIGHT_TO_LEFT ? (this.getControl("mcGuiBtnScrollRight").onFade(0 !==
        this.m_currentPage, 10), this.getControl("mcGuiBtnScrollLeft").onFade(this.m_currentPage !== this.maxPage, 10)) : (this.getControl("mcGuiBtnScrollLeft").onFade(0 !== this.m_currentPage, 10), this.getControl("mcGuiBtnScrollRight").onFade(this.m_currentPage !== this.maxPage, 10));
    this.m_group.onSelectControl("mcGuiBtnSlice_" + (this.m_currentPage + 1));
    this.m_introPage = !1
};
GuiPopupHelp.prototype.scrollImageLeft = function() {
    Application.RIGHT_TO_LEFT ? (this.m_currentPage++, this.m_currentPage = this.m_currentPage >= this.maxPage ? this.maxPage : this.m_currentPage) : (this.m_currentPage--, this.m_currentPage = 0 >= this.m_currentPage ? 0 : this.m_currentPage);
    this.m_scroll.duration = GuiPopupHelp.SCROLL_TIME_PRESS;
    this.onMoveScroll(this.m_currentPage)
};
GuiPopupHelp.prototype.scrollImageRight = function() {
    Application.RIGHT_TO_LEFT ? (this.m_currentPage--, this.m_currentPage = 0 >= this.m_currentPage ? 0 : this.m_currentPage) : (this.m_currentPage++, this.m_currentPage = this.m_currentPage >= this.maxPage ? this.maxPage : this.m_currentPage);
    this.m_scroll.duration = GuiPopupHelp.SCROLL_TIME_PRESS;
    this.onMoveScroll(this.m_currentPage)
};

function GuiPopupHelpItems(a, b, c, d) {
    SScreen.call(this, a, b, c, d)
}
Application.subclass(GuiPopupHelpItems, SScreen);
GuiPopupHelpItems.prototype.onUIRelease = function(a) {
    SScreen.prototype.onUIRelease.call(this, a)
};
GuiPopupHelpItems.prototype.onUIPress = function(a) {
    SScreen.prototype.onUIPress.call(this, a)
};

function GuiPopupQuit(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.initData();
    Application.instance.playSound("SND_UI_POPUP_GENERAL");
    this.onPress = !0
}
Application.subclass(GuiPopupQuit, SScreen);
GuiPopupQuit.typeMessage = GuiPopupQuit.CONFIRM_QUIT;
GuiPopupQuit.CONFIRM_QUIT = 100;
GuiPopupQuit.CONFIRM_MULTI = 101;
GuiPopupQuit.TUTORIAL = 102;
GuiPopupQuit.SWAP_PLAYER = 103;
GuiPopupQuit.ARCADE = 104;
GuiPopupQuit.prototype.initData = function() {
    switch (GuiPopupQuit.typeMessage) {
        case GuiPopupQuit.TUTORIAL:
            this.applyBlur();
            this.localizedTitle("gui_localized_title_reset", this.getControl("mcGuiTextTitle").clip, 450, 44);
            this.getControl("mcGuiTextInfo").setTextLocalized("STR_SKIPTUTORIAL_INFO");
            break;
        case GuiPopupQuit.CONFIRM_MULTI:
            this.getControl("mcGuiBg").setVisible(!1);
            this.localizedTitle("gui_localized_title_reset", this.getControl("mcGuiTextTitle").clip, 450, 44);
            break;
        case GuiPopupQuit.CONFIRM_QUIT:
        case GuiPopupQuit.SWAP_PLAYER:
            this.getControl("mcGuiBg").setVisible(!1);
            this.localizedTitle("gui_localized_title_quit", this.getControl("mcGuiTextTitle").clip, 450, 44);
            break;
        case GuiPopupQuit.ARCADE:
            this.applyBlur(), this.getControl("mcGuiBg").setVisible(!0), this.localizedTitle("gui_localized_title_quit", this.getControl("mcGuiTextTitle").clip, 450, 44), this.getControl("mcGuiTextInfo").setTextLocalized("STR_QUIT_ARCADE")
    }
};
GuiPopupQuit.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    this.onPress = !1
};
GuiPopupQuit.prototype.onUIPress = function(a) {
    this.onPress || (SScreen.prototype.onUIPress.call(this, a), Application.instance.playSound("SND_UI_CLICK"))
};
GuiPopupQuit.prototype.onUIRelease = function(a) {
    if (!this.onPress) switch (SScreen.prototype.onUIRelease.call(this, a), a.name) {
        case "mcGuiBtnYes":
            GhostingManager.instance.clear();
            this.screenParent.dropPopup();
            switch (GuiPopupQuit.typeMessage) {
                case GuiPopupQuit.ARCADE:
                    window.location.href = window.config.settings.arcadeURL;
                    break;
                case GuiPopupQuit.CONFIRM_MULTI:
                    PlayerSettings.instance.resetMultiplayer();
                    GuiManager.instance.gotoScreen(GuiManager.SC_GAME);
                    break;
                case GuiPopupQuit.CONFIRM_QUIT:
                    PlayerSettings.instance.resetMultiplayer();
                    GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU);
                    break;
                case GuiPopupQuit.SWAP_PLAYER:
                    PlayerSettings.instance.resetMultiplayer();
                    PlayerSettings.instance.isMultiplayer() ? GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_CHARACTER_MP) : GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_CHARACTER_SP);
                    break;
                case GuiPopupQuit.TUTORIAL:
                    Global.data.data.tutorial = 1, Global.data.save(), HudPlatform.instance.onEndTrans(GuiManager.instance, GuiManager.instance.sendToMainMenu), HudPlatform.instance.doTransition(!1)
            }
            break;
        case "mcGuiBtnNo":
            switch (GuiPopupQuit.typeMessage) {
                case GuiPopupQuit.TUTORIAL:
                    GuiGame.instance.dropPopup();
                    break;
                case GuiPopupQuit.ARCADE:
                    this.screenParent.dropPopup();
                    break;
                default:
                    this.screenParent.onActionScreen()
            }
    }
};
GuiPopupQuit.prototype.onFinishScreen = function() {
    switch (this.lastInteractionControl) {
        case "mcGuiBtnYes":
            GhostingManager.instance.clear();
            this.screenParent.dropPopup();
            switch (GuiPopupQuit.typeMessage) {
                case GuiPopupQuit.CONFIRM_MULTI:
                    PlayerSettings.instance.resetMultiplayer();
                    GuiManager.instance.gotoScreen(GuiManager.SC_GAME);
                    break;
                case GuiPopupQuit.CONFIRM_QUIT:
                    PlayerSettings.instance.isMultiplayer() ? GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_CHARACTER_MP) : GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_CHARACTER_SP);
                    break;
                case GuiPopupQuit.TUTORIAL:
                    Global.data.data.tutorial = 1, Global.data.save(), HudPlatform.instance.onEndTrans(GuiManager.instance, GuiManager.instance.sendToMainMenu), HudPlatform.instance.doTransition(!1)
            }
            break;
        case "mcGuiBtnNo":
            this.screenParent.onActionScreen()
    }
};

function GuiPopupReset(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = "popup_reset";
    Application.instance.playSound("SND_UI_POPUP_GENERAL");
    this.applyBlur()
}
Application.subclass(GuiPopupReset, SScreen);
GuiPopupReset.prototype.onUIPress = function(a) {
    Application.instance.playSound("SND_UI_CLICK");
    switch (a.name) {
        case "mcGuiBtnYes":
            Global.viewInitCutscene = 0;
            this.screenParent.dropPopup();
            break;
        case "mcGuiBtnNo":
            this.screenParent.dropPopup()
    }
};
GuiPopupReset.prototype.free = function() {
    SScreen.prototype.free.call(this)
};
GuiPopupReset.prototype.update = function(a) {
    SScreen.prototype.update.call(this, a)
};

function GuiPopupPause(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = GuiManager.POPUP_PAUSE;
    GuiPopupPause.instance = this;
    Application.instance.pauseAllSounds();
    Application.instance.playSound("SND_UI_POPUP_GENERAL");
    this.localizedTitle("gui_localized_title_pause", this.getControl("mcGuiTextTitle").clip, 450, 44)
}
Application.subclass(GuiPopupPause, SScreen);
GuiPopupPause.instance = null;
GuiPopupPause.ROWS = 6;
GuiPopupPause.COLUMNS = 10;
GuiPopupPause.X_SPEED = -.05;
GuiPopupPause.Y_SPEED = .05;
GuiPopupPause.prototype.onUIPress = function(a) {
    Application.instance.playSound("SND_UI_CLICK");
    switch (a.name) {
        case "mcGuiBtnResume":
            Application.instance.resumeAllSounds();
            GuiGame.instance.popup === this && (GuiGame.instance.popup = null);
            this.free();
            break;
        case "mcGuiBtnReplay":
            PlayerSettings.instance.isMultiplayer() ? (this.enablePopup(!1), GuiPopupQuit.typeMessage = GuiPopupQuit.CONFIRM_MULTI, this.addPopup(GuiPopupQuit, "mcGuiPopupConfirm")) : (GuiGame.instance.dropPopup(), Application.instance.resumeAllSounds(),
                GuiManager.instance.gotoScreen(GuiManager.SC_GAME));
            break;
        case "mcGuiBtnSoundOn":
        case "mcGuiBtnSoundOff":
            Application.instance.toggleMute();
            break;
        case "mcGuiBtnChangeplayer":
            this.enablePopup(!1);
            GuiPopupQuit.typeMessage = GuiPopupQuit.SWAP_PLAYER;
            this.addPopup(GuiPopupQuit, "mcGuiPopupQuit");
            break;
        case "mcGuiBtnMainmenu":
            this.enablePopup(!1);
            GuiPopupQuit.typeMessage = GuiPopupQuit.CONFIRM_QUIT;
            this.addPopup(GuiPopupQuit, "mcGuiPopupQuit");
            break;
        case "mcGuiBtnHelp":
            this.enablePopup(!1), this.addPopup(GuiPopupHelp,
                "mcGuiPopupHelp")
    }
};
GuiPopupPause.prototype.onActionScreen = function() {
    this.clip.gotoAndPlay(2);
    this.enablePopup(!0);
    this.dropPopup()
};
GuiPopupPause.prototype.enablePopup = function(a) {
    this.getControl("mcGuiTextTitle").setVisible(a);
    this.getControl("mcGuiBtnReplay").setVisible(a);
    this.getControl("mcGuiBtnResume").setVisible(a);
    this.getControl("mcGuiBtnSoundOn").setVisible(a);
    this.getControl("mcGuiBtnSoundOff").setVisible(a);
    this.getControl("mcGuiBtnHelp").setVisible(a);
    this.getControl("mcGuiBtnMainmenu").setVisible(a);
    this.getControl("mcGuiBase").setVisible(a);
    this.getControl("mcGuiBtnChangeplayer").setVisible(a)
};
GuiPopupPause.prototype.free = function() {
    GuiPopupPause.instance = null;
    SScreen.prototype.free.call(this)
};
GuiPopupPause.prototype.update = function(a) {
    SScreen.prototype.update.call(this, a);
    this.controls && this.checkStateSound("mcGuiBtnSound")
};

function GuiPopupTurn(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.canvas.hitArea = null;
    this.name = "popup_turn";
    this.m_updateTime = 0;
    this.m_isCompleted = !0;
    Global.game.world.player().setHold(!1);
    Global.game.world.player().createIntro();
    this.init()
}
Application.subclass(GuiPopupTurn, SScreen);
GuiPopupTurn.MAX_TIME = 1500;
GuiPopupTurn.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    this.m_isCompleted = !1
};
GuiPopupTurn.prototype.onFinishScreen = function() {
    this.screenParent.dropPopup()
};
GuiPopupTurn.prototype.free = function() {
    SScreen.prototype.free.call(this)
};
GuiPopupTurn.prototype.init = function() {
    var a = Global.playersForGame[PlayerSettings.instance.getCurrentTurn() - 1];
    this.localizedTitle("gui_localized_turn" + PlayerSettings.instance.getCurrentTurn(), this.getControl("mcGuiTxtPlayerName").clip, 450, 44);
    this.getControl("mcGuiTxtPlayer").setTextLocalized("STR_SELECTCHARACTER_0" + a)
};
GuiPopupTurn.prototype.update = function(a) {
    this.m_isCompleted || (this.m_updateTime += a, this.m_updateTime >= GuiPopupTurn.MAX_TIME && (this.m_updateTime = 0, this.m_isCompleted = !0, this.onResumeScreen()));
    SScreen.prototype.update.call(this, a)
};

function GuiPopupIntro(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = "popup_intro";
    this.init()
}
Application.subclass(GuiPopupIntro, SScreen);
GuiPopupIntro.prototype.onUIPress = function(a) {
    switch (a.name) {
        case "mcGuiBtnNext":
            this.screenParent.dropPopup()
    }
};
GuiPopupIntro.prototype.free = function() {
    SScreen.prototype.free.call(this)
};
GuiPopupIntro.prototype.init = function() {};
GuiPopupIntro.prototype.update = function(a) {
    SScreen.prototype.update.call(this, a)
};

function GuiPopupIntroVS(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.canvas.hitArea = null;
    this.name = GuiManager.POPUP_INTRO_VS;
    this.m_updateTime = 0;
    this.m_isCompleted = !0;
    HudPlatform.instance.enableHud(!1);
    PlatformGame.instance.world.player().setHold(!0);
    this.init()
}
Application.subclass(GuiPopupIntroVS, SScreen);
GuiPopupIntroVS.ST_INTRO_STEP_APPEAR = 100;
GuiPopupIntroVS.ST_INTRO_STEP_APPEAR = 100;
GuiPopupIntroVS.MAX_TIME = 1500;
GuiPopupIntroVS.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    this.m_isCompleted = !1
};
GuiPopupIntroVS.prototype.onFinishScreen = function() {
    this.screenParent.dropPopup();
    HudPlatform.instance.setHudAnimation();
    HudPlatform.instance.addPopup(GuiPopupTurn, "mcGuiMessageVsTurn")
};
GuiPopupIntroVS.prototype.free = function() {
    SScreen.prototype.free.call(this)
};
GuiPopupIntroVS.prototype.init = function() {
    this.getControl("mcGuiImageP1").clip.gotoAndStop(Global.playersForGame[0]);
    this.getControl("mcGuiImageP2").clip.gotoAndStop(Global.playersForGame[1]);
    this.getControl("mcGuiTxtP1Name").setTextLocalized("STR_SELECTCHARACTER_0" + Global.playersForGame[0]);
    this.getControl("mcGuiTxtP2Name").setTextLocalized("STR_SELECTCHARACTER_0" + Global.playersForGame[1]);
    this.localizedTitle(MissionManager.instance.getGameMode() === MissionManager.GAME_COOPERATIVE ? "gui_localized_mission_coop" :
        "gui_localized_mission_vs", this.getControl("mcGuiTxtVS").clip, 513, 46)
};
GuiPopupIntroVS.prototype.update = function(a) {
    this.m_isCompleted || (this.m_updateTime += a, this.m_updateTime >= GuiPopupIntroVS.MAX_TIME && (this.m_updateTime = 0, this.m_isCompleted = !0, this.onResumeScreen()));
    SScreen.prototype.update.call(this, a)
};

function GuiPopupEndTurn(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = "popup_endturn";
    this.m_updateTime = 0;
    this.m_isCompleted = !0;
    this.canvas.addPressListener(this, this.onUIPress);
    HudPlatform.instance.enableHud(!1);
    HudPlatform.instance.dropPopup()
}
Application.subclass(GuiPopupEndTurn, SScreen);
GuiPopupEndTurn.MAX_TIME = 8E3;
GuiPopupEndTurn.MAX_SPTIME = 3E3;
GuiPopupEndTurn.typeMessage = GuiPopupEndTurn.CAPTURED;
GuiPopupEndTurn.TIMEOUT = "timeout";
GuiPopupEndTurn.CAPTURED = "captured";
GuiPopupEndTurn.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    PlayerSettings.instance.isLastMultiplayerPlayer() || Application.isLowDevice || (Global.screenCapture = new window.PIXI.Sprite.fromImage(Application.instance.captureScreen()));
    this.m_isCompleted = !1
};
GuiPopupEndTurn.prototype.onFinishScreen = function() {
    this.screenParent.dropPopup();
    if (PlayerSettings.instance.isMultiplayer())
        if (PlayerSettings.instance.isLastMultiplayerPlayer()) {
            if (MissionManager.instance.isCooperative()) PlatformGame.instance.world.player().hasLost() && GuiGame.instance.addPopup(GuiPopupTryAgainCop, "mcGuiPopupTryagainCoop", 0, 0);
            else if (PlayerSettings.instance.player1Won || PlayerSettings.instance.player2Won) {
                var a = PlayerSettings.instance.calculateScore();
                (a.isDraw ? GuiGame.instance.addPopup(GuiPopupEndLevelDraw,
                    "mcGuiPopupEndlevelDraw", 0, 0) : GuiGame.instance.addPopup(GuiPopupEndLevelVS, "mcGuiPopupEndlevelVs", 0, 0)).onLoadData(a)
            } else GuiGame.instance.addPopup(GuiPopupTryAgainVS, "mcGuiPopupTryagainVs", 0, 0);
            PlayerSettings.instance.resetMultiplayer()
        } else HudPlatform.instance.onEndTrans(PlatformGame.instance, PlatformGame.instance.onReset), HudPlatform.instance.doScreenshotTransition(), PlatformGame.instance.reset = !1;
    else GuiGame.instance.addPopup(GuiPopupTryAgain, "mcGuiPopupTryagain", 0, 0)
};
GuiPopupEndTurn.prototype.init = function() {
    switch (GuiPopupEndTurn.typeMessage) {
        case GuiPopupEndTurn.TIMEOUT:
            this.localizedTitle("gui_localized_timesup", this.getControl("mcGuiTxtTurn").clip, 450, 44);
            break;
        case GuiPopupEndTurn.CAPTURED:
            this.localizedTitle("gui_localized_captured", this.getControl("mcGuiTxtTurn").clip, 450, 44)
    }
};
GuiPopupEndTurn.prototype.free = function() {
    SScreen.prototype.free.call(this)
};
GuiPopupEndTurn.prototype.onUIPress = function(a) {
    this.m_updateTime = MissionManager.instance.isSinglePlayer() ? GuiPopupEndTurn.MAX_SPTIME : GuiPopupEndTurn.MAX_TIME
};
GuiPopupEndTurn.prototype.update = function(a) {
    if (!this.m_isCompleted && (this.m_updateTime += a, MissionManager.instance.isSinglePlayer() && this.m_updateTime >= GuiPopupEndTurn.MAX_SPTIME || PlayerSettings.instance.isMultiplayer() && this.m_updateTime >= GuiPopupEndTurn.MAX_TIME || MissionManager.instance.getGameMode() === MissionManager.GAME_NONE && this.m_updateTime >= GuiPopupEndTurn.MAX_SPTIME))
        if (Application.isLowDevice) this.m_updateTime = 0, this.m_isCompleted = !0, this.onResumeScreen();
        else if (!PlayerSettings.instance.isLastMultiplayerPlayer() &&
        Global.screenCapture.texture.baseTexture.hasLoaded || PlayerSettings.instance.isLastMultiplayerPlayer()) this.m_updateTime = 0, this.m_isCompleted = !0, this.onFinishScreen();
    SScreen.prototype.update.call(this, a)
};

function GuiPopupIntroMission(a, b, c, d) {
    a = MissionManager.instance.isMissionTutorial() ? "mcGuiMessageTutorialIntro" : a;
    SScreen.call(this, a, b, c, d);
    this.canvas.hitArea = null;
    this.name = GuiManager.POPUP_INTRO_MISSIONS;
    this.m_updateTime = 0;
    this.m_isCompleted = !0;
    this.isDoingBlend = this.doTimer = !1
}
Application.subclass(GuiPopupIntroMission, SScreen);
GuiPopupIntroMission.MAX_TIME = 3E3;
GuiPopupIntroMission.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    this.m_isCompleted = !1;
    (this.isDoingBlend = !MissionManager.instance.isMissionBossBattle() && !PlayerSettings.instance.isInLiberation) ? PlatformGame.instance.doIntroBlend(): (this.doTimer = !0, Global.game.world.player().setHold(!1), HudPlatform.instance.enableMobileControls(!0))
};
GuiPopupIntroMission.prototype.onFinishScreen = function() {
    this.screenParent.dropPopup();
    Application.instance.stopSound("SND_UI_POPUP_MISSIONTYPE");
    if (this.isDoingBlend) PlatformGame.instance.onEndReturnBlend()
};
GuiPopupIntroMission.prototype.free = function() {
    SScreen.prototype.free.call(this)
};
GuiPopupIntroMission.prototype.getMissionFrame = function() {
    switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            var a = 0;
            switch (PlayerSettings.instance.m_collectSkin) {
                case 1:
                    a = 4;
                    break;
                case 2:
                    a = 2;
                    break;
                case 3:
                    a = 6;
                    break;
                case 4:
                    a = 3;
                    break;
                case 5:
                    a = 5;
                    break;
                case 6:
                    a = 1
            }
            return a;
        case MissionManager.MISSION_LIBERATION:
            return 8;
        case MissionManager.MISSION_SABOTAGE:
            return 7;
        case MissionManager.MISSION_BOSS_BATTLE:
            switch (PlayerSettings.instance.getCurrentMap()) {
                case "boss_1":
                    return 11;
                case "boss_2":
                    return 9;
                case "boss_3":
                    return 10
            }
    }
    return 1
};
GuiPopupIntroMission.prototype.init = function() {
    MissionManager.instance.isMissionTutorial() ? (this.localizedTitle("gui_localized_tutorial_intro", this.getControl("mcGuiTxtTutorialTitle").clip, 450, 44), this.getControl("mcGuiTxtTutorialDesc").setTextLocalized("STR_MESSAGE_TUTORIAL_INFO")) : (this.localizedTitle("gui_localized_mission_type_" + Global.mission, this.getControl("mcGuiTxtMissionTitle").clip, 450, 44), this.getControl("mcGuiItem").clip.gotoAndStop(this.getMissionFrame()), this.getControl("mcGuiTxtMissionDesc").setTextLocalized("STR_MISSION_INFO_" +
        Global.mission), MissionManager.instance.isMissionBossBattle() ? this.getControl("mcGuiItem2").setVisible(!1) : this.getControl("mcGuiItem2").clip.gotoAndStop(this.getMissionFrame()));
    Application.instance.playSound("SND_UI_POPUP_MISSIONTYPE")
};
GuiPopupIntroMission.prototype.update = function(a) {
    !this.m_isCompleted && this.doTimer && (this.m_updateTime += a, this.m_updateTime >= GuiPopupIntroMission.MAX_TIME && (this.m_isCompleted = !0, this.onResumeScreen()));
    SScreen.prototype.update.call(this, a)
};

function GuiPopupMissionCompleted(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = "popup_missioncompleted";
    this.m_updateTime = 0;
    this.m_isCompleted = !0;
    this.canvas.addPressListener(this, this.onUIPress);
    HudPlatform.instance.enableHud(!1)
}
Application.subclass(GuiPopupMissionCompleted, SScreen);
GuiPopupMissionCompleted.typeMessage = GuiPopupMissionCompleted.END_TURN;
GuiPopupMissionCompleted.END_TURN = 0;
GuiPopupMissionCompleted.MISSION_COMPLETE = 1;
GuiPopupMissionCompleted.TUTORIAL_COMPLETE = 2;
GuiPopupMissionCompleted.MAX_TIME = 5E3;
GuiPopupMissionCompleted.MAX_SPTIME = 3E3;
GuiPopupMissionCompleted.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    this.m_isCompleted = !1;
    PlayerSettings.instance.isLastMultiplayerPlayer() || Application.isLowDevice || (Global.screenCapture = new window.PIXI.Sprite.fromImage(Application.instance.captureScreen()))
};
GuiPopupMissionCompleted.prototype.onFinishScreen = function() {
    Global.data.data.shouldSpawnTokens = !0;
    Global.data.save();
    this.screenParent.dropPopup();
    switch (GuiPopupMissionCompleted.typeMessage) {
        case GuiPopupMissionCompleted.TUTORIAL_COMPLETE:
            HudPlatform.instance.onEndTrans(GuiManager.instance, GuiManager.instance.sendToMainMenu);
            HudPlatform.instance.doTransition(!1);
            break;
        case GuiPopupMissionCompleted.MISSION_COMPLETE:
            if (PlayerSettings.instance.isMultiplayer())
                if (PlayerSettings.instance.isLastMultiplayerPlayer()) {
                    var a =
                        PlayerSettings.instance.calculateScore();
                    (MissionManager.instance.isCooperative() ? GuiGame.instance.addPopup(GuiPopupEndLevelCop, "mcGuiPopupEndlevelCoop", 0, 0) : a.isDraw ? GuiGame.instance.addPopup(GuiPopupEndLevelDraw, "mcGuiPopupEndlevelDraw", 0, 0) : GuiGame.instance.addPopup(GuiPopupEndLevelVS, "mcGuiPopupEndlevelVs", 0, 0)).onLoadData(a);
                    PlayerSettings.instance.resetMultiplayer()
                } else HudPlatform.instance.onEndTrans(PlatformGame.instance, PlatformGame.instance.onReset), HudPlatform.instance.doScreenshotTransition(),
                    PlatformGame.instance.reset = !1;
            else GuiGame.instance.addPopup(GuiPopupEndLevelSP, "mcGuiPopupEndlevelSingle", 0, 0);
            break;
        case GuiPopupMissionCompleted.END_TURN:
            HudPlatform.instance.onEndTrans(PlatformGame.instance, PlatformGame.instance.onReset), HudPlatform.instance.doScreenshotTransition(), PlatformGame.instance.reset = !1
    }
};
GuiPopupMissionCompleted.prototype.init = function() {
    switch (GuiPopupMissionCompleted.typeMessage) {
        case GuiPopupMissionCompleted.END_TURN:
            this.localizedTitle("gui_localized_message_turnend", this.getControl("mcGuiTxtComplete").clip, 450, 44);
            break;
        case GuiPopupMissionCompleted.MISSION_COMPLETE:
            this.localizedTitle("gui_localized_message_complete", this.getControl("mcGuiTxtComplete").clip, 450, 44);
            break;
        case GuiPopupMissionCompleted.TUTORIAL_COMPLETE:
            this.localizedTitle("gui_localized_message_tutorial", this.getControl("mcGuiTxtComplete").clip,
                450, 44)
    }
};
GuiPopupMissionCompleted.prototype.free = function() {
    SScreen.prototype.free.call(this)
};
GuiPopupMissionCompleted.prototype.onUIPress = function(a) {
    this.m_updateTime = MissionManager.instance.isSinglePlayer() ? GuiPopupMissionCompleted.MAX_SPTIME : GuiPopupMissionCompleted.MAX_TIME
};
GuiPopupMissionCompleted.prototype.update = function(a) {
    if (!this.m_isCompleted && (this.m_updateTime += a, MissionManager.instance.isSinglePlayer() && this.m_updateTime >= GuiPopupMissionCompleted.MAX_SPTIME || PlayerSettings.instance.isMultiplayer() && this.m_updateTime >= GuiPopupMissionCompleted.MAX_TIME || MissionManager.instance.getGameMode() === MissionManager.GAME_NONE && this.m_updateTime >= GuiPopupMissionCompleted.MAX_SPTIME))
        if (Application.isLowDevice) this.m_updateTime = 0, this.m_isCompleted = !0, this.onResumeScreen();
        else if (!PlayerSettings.instance.isLastMultiplayerPlayer() && Global.screenCapture.texture.baseTexture.hasLoaded || PlayerSettings.instance.isLastMultiplayerPlayer()) this.m_updateTime = 0, this.m_isCompleted = !0, this.onFinishScreen();
    SScreen.prototype.update.call(this, a)
};

function GuiPopupTryAgain(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = GuiManager.POPUP_TRYAGAIN;
    this.localizedTitle("gui_localized_title_tryagain", this.getControl("mcGuiTextTitle").clip, 450, 44);
    this.getControl("mcGuiCharacter").setClip("gui_popups_tryagain_character0" + Global.playerSelected);
    this.getControl("mcGuiBtnLeaderboard").setVisible(!window.config.settings.HIDE_LEADERBOARD_BUTTON);
    this.getControl("mcGuiBtnMoregames").setVisible(!window.config.settings.HIDE_ARCADE_BUTTON)
}
Application.subclass(GuiPopupTryAgain, SScreen);
GuiPopupTryAgain.prototype.onActionScreen = function() {
    this.dropPopup();
    this.showVisiblePopup(!0)
};
GuiPopupTryAgain.prototype.showVisiblePopup = function(a) {
    for (var b in this.controls) "mcGuiBg" !== this.controls[b].name && this.controls[b].clip && this.controls[b].setVisible(a)
};
GuiPopupTryAgain.prototype.onUIPress = function(a) {
    SScreen.prototype.onUIPress.call(this, a);
    Application.instance.playSound("SND_UI_CLICK")
};
GuiPopupTryAgain.prototype.onUIRelease = function(a) {
    SScreen.prototype.onUIRelease.call(this, a);
    if (this.activeRelease) {
        switch (a.name) {
            case "mcGuiBtnMainmenu":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU));
                break;
            case "mcGuiBtnTrophies":
                this.showVisiblePopup(!1);
                this.addPopup(GuiPopupTrophies, "mcGuiPopupTrophies");
                break;
            case "mcGuiBtnRetry":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_GAME));
                break;
            case "mcGuiBtnChangeplayer":
                this.enablePopup(!1), GuiPopupQuit.typeMessage = GuiPopupQuit.SWAP_PLAYER, this.addPopup(GuiPopupQuit, "mcGuiPopupQuit")
        }
        this.activeRelease = !1;
        a.onResetState()
    }
};
GuiPopupTryAgain.prototype.enablePopup = function(a) {
    for (var b in this.controls) "mcGuiBg" !== b && this.controls[b].setVisible(a)
};

function GuiPopupTryAgainVS(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = GuiManager.POPUP_TRYAGAIN;
    this.localizedTitle("gui_localized_title_tryagain", this.getControl("mcGuiTextTitle").clip, 450, 44);
    this.getControl("mcGuiCharacter").setClip("gui_popups_tryagain_character0" + Global.playersForGame[0]);
    this.getControl("mcGuiCharacter2").setClip("gui_popups_tryagain_character0" + Global.playersForGame[1]);
    this.getControl("mcGuiBtnLeaderboard").setVisible(!window.config.settings.HIDE_LEADERBOARD_BUTTON);
    this.getControl("mcGuiBtnMoregames").setVisible(!window.config.settings.HIDE_ARCADE_BUTTON)
}
Application.subclass(GuiPopupTryAgainVS, SScreen);
GuiPopupTryAgainVS.prototype.onActionScreen = function() {
    this.dropPopup();
    this.showVisiblePopup(!0)
};
GuiPopupTryAgainVS.prototype.showVisiblePopup = function(a) {
    for (var b in this.controls) "mcGuiBg" !== this.controls[b].name && this.controls[b].clip && this.controls[b].setVisible(a)
};
GuiPopupTryAgainVS.prototype.onUIPress = function(a) {
    Application.instance.playSound("SND_UI_CLICK");
    switch (a.name) {
        case "mcGuiBtnMainmenu":
            this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU));
            break;
        case "mcGuiBtnTrophies":
            this.showVisiblePopup(!1);
            this.addPopup(GuiPopupTrophies, "mcGuiPopupTrophies");
            break;
        case "mcGuiBtnRetry":
            this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_GAME));
            break;
        case "mcGuiBtnChangeplayer":
            this.enablePopup(!1),
                GuiPopupQuit.typeMessage = GuiPopupQuit.SWAP_PLAYER, this.addPopup(GuiPopupQuit, "mcGuiPopupQuit")
    }
};
GuiPopupTryAgainVS.prototype.enablePopup = function(a) {
    for (var b in this.controls) "mcGuiBg" !== b && this.controls[b].setVisible(a)
};

function GuiPopupTryAgainCop(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = GuiManager.POPUP_TRYAGAIN;
    this.localizedTitle("gui_localized_title_tryagain", this.getControl("mcGuiTextTitle").clip, 450, 44);
    this.getControl("mcGuiCharacter").setClip("gui_popups_tryagain_character0" + Global.playersForGame[0]);
    this.getControl("mcGuiCharacter2").setClip("gui_popups_tryagain_character0" + Global.playersForGame[1]);
    this.getControl("mcGuiBtnLeaderboard").setVisible(!window.config.settings.HIDE_LEADERBOARD_BUTTON);
    this.getControl("mcGuiBtnMoregames").setVisible(!window.config.settings.HIDE_ARCADE_BUTTON)
}
Application.subclass(GuiPopupTryAgainCop, SScreen);
GuiPopupTryAgainCop.prototype.onActionScreen = function() {
    this.dropPopup();
    this.showVisiblePopup(!0)
};
GuiPopupTryAgainCop.prototype.showVisiblePopup = function(a) {
    for (var b in this.controls) "mcGuiBg" !== this.controls[b].name && this.controls[b].clip && this.controls[b].setVisible(a)
};
GuiPopupTryAgainCop.prototype.onUIPress = function(a) {
    SScreen.prototype.onUIPress.call(this, a);
    Application.instance.playSound("SND_UI_CLICK")
};
GuiPopupTryAgainCop.prototype.onUIRelease = function(a) {
    SScreen.prototype.onUIRelease.call(this, a);
    if (this.activeRelease) {
        switch (a.name) {
            case "mcGuiBtnMainmenu":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU));
                break;
            case "mcGuiBtnTrophies":
                this.showVisiblePopup(!1);
                this.addPopup(GuiPopupTrophies, "mcGuiPopupTrophies");
                break;
            case "mcGuiBtnRetry":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_GAME));
                break;
            case "mcGuiBtnChangeplayer":
                this.enablePopup(!1), GuiPopupQuit.typeMessage = GuiPopupQuit.SWAP_PLAYER, this.addPopup(GuiPopupQuit, "mcGuiPopupQuit")
        }
        this.activeRelease = !1;
        a.onResetState()
    }
};
GuiPopupTryAgainCop.prototype.enablePopup = function(a) {
    for (var b in this.controls) "mcGuiBg" !== b && this.controls[b].setVisible(a)
};

function GuiPopupEndLevelSP(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = GuiManager.POPUP_ENDLEVEL_SP;
    this.m_countStar = 0;
    this.m_totalStar = 2;
    this.m_interval = null;
    this.state = GuiPopupEndLevelSP.ST_FIRST_SCREEN;
    this.onLoadData();
    this.currentStar = null;
    GuiPopupEndLevelSP.instance = this;
    this.nextPressed = !1;
    this.achievFx = null;
    this.getControl("mcGuiBtnMoregames") && this.getControl("mcGuiBtnMoregames").setVisible(!window.config.settings.HIDE_ARCADE_BUTTON);
    this.getControl("mcGuiBtnFxTrophies") && GuiGame.instance.showingAchiev &&
        (this.achievFx = Application.instance.effectManager.createEffect("guiFxButtonAlertLoop", 0, 0, this.getControl("mcGuiBtnFxTrophies").clip))
}
Application.subclass(GuiPopupEndLevelSP, SScreen);
GuiPopupEndLevelSP.instance = null;
GuiPopupEndLevelSP.ST_FIRST_SCREEN = 0;
GuiPopupEndLevelSP.ST_SECOND_SCREEN = 1;
GuiPopupEndLevelSP.prototype.onActionScreen = function() {
    this.dropPopup();
    this.showVisiblePopup(!0)
};
GuiPopupEndLevelSP.prototype.showVisiblePopup = function(a) {
    for (var b in this.controls) "mcGuiBg" !== this.controls[b].name && (this.controls[b].clip ? this.controls[b].setVisible(a) : this.controls[b].setAlpha(a ? 1 : 0));
    this.getControl("mcGuiDefeatedbossBar").setVisible(MissionManager.instance.isMissionBossBattle() && a)
};
GuiPopupEndLevelSP.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    this.m_interval = new SInterval(this, "onEndInterval", 100)
};
GuiPopupEndLevelSP.prototype.onEndInterval = function() {
    this.m_interval && this.m_interval.free();
    this.m_interval = null;
    this.m_countStar >= this.m_totalStar || (this.m_countStar++, this.m_interval = new SInterval(this, "onEndInterval", 500), this.getControl("mcGuiStarOn0" + this.m_countStar).clip.gotoAndPlay(2), this.currentStar = this.getControl("mcGuiStarOn0" + this.m_countStar).clip)
};
GuiPopupEndLevelSP.prototype.onLoadData = function() {
    var a = MissionManager.instance.getMissionId(),
        a = Settings.instance.getMission(a);
    this.localizedTitle("gui_localized_title_endlevel", this.getControl("mcGuiTextTitle").clip, 450, 44);
    var b = PlayerSettings.instance.timerPlayer1,
        c = 0,
        d = 0,
        d = 0;
    this.getControl("mcGuiDefeatedbossBar").setVisible(!1);
    switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            this.getControl("mcGuiPanelTitle1").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_1");
            this.getControl("mcGuiPanelInfo1").setText(PlayerSettings.instance.getCollectedItems() + "/" + PlayerSettings.instance.getTotalItems());
            c = a.pointsObtainedPerObject * PlayerSettings.instance.collectedItemsPlayer1;
            break;
        case MissionManager.MISSION_LIBERATION:
            this.getControl("mcGuiPanelTitle1").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_2");
            this.getControl("mcGuiPanelInfo1").setText(PlayerSettings.instance.getBasesLiberated() + "/" + PlayerSettings.instance.getTotalBases());
            c = a.pointsObtainedPerObject * PlayerSettings.instance.basesLiberatedPlayer1;
            break;
        case MissionManager.MISSION_SABOTAGE:
            this.getControl("mcGuiPanelTitle1").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_3");
            this.getControl("mcGuiPanelInfo1").setText(PlayerSettings.instance.getSabotagesDone() + 1 + "/" + (PlayerSettings.instance.getTotalSabotages() + 1));
            c = a.pointsObtainedPerObject * (PlayerSettings.instance.sabotagesPlayer1 + 1);
            break;
        case MissionManager.MISSION_BOSS_BATTLE:
            this.getControl("mcGuiPanelTitle1").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_4");
            var e = d = c = 0,
                d = "";
            switch (Global.level) {
                case 1:
                    d =
                        "atdp";
                    break;
                case 2:
                    d = "atat";
                    break;
                case 3:
                    d = "tie_fighter"
            }
            switch (MissionManager.instance.getGameMode()) {
                case MissionManager.GAME_SINGLEPLAYER:
                    c = Application.config[d].initHealth;
                    break;
                case MissionManager.GAME_COOPERATIVE:
                    c = Application.config[d].initHealthCoop;
                    break;
                case MissionManager.GAME_VERSUS:
                    c = Application.config[d].initHealthVS
            }
            d = Math.min(Math.round(100 * PlayerSettings.instance.damageToBossP1 / c), 100);
            e = Math.ceil(99 * PlayerSettings.instance.damageToBossP1 / c) + 1;
            this.getControl("mcGuiDefeatedbossBar").setVisible(!0);
            this.getControl("mcGuiDefeatedbossBar").clip.gotoAndStop(e);
            this.getControl("mcGuiPanelInfo1").setText(d + Application.strings.STR_ENDLEVEL_PERCENT);
            c = a.pointsObtainedPerObject;
            PlayerSettings.instance.player1GotDamage || Global.data.dataArcade.trophies.trophy8.achieved || (Global.data.dataArcade.trophies.trophy8.achieved = !0, GuiGame.instance.addAchievPopup(8), Global.data.save())
    }
    d = a.timeForPointsSP - a.timeForMaxPointsSP;
    b <= a.timeForMaxPointsSP ? d = a.maxPointsTimer : b > a.timeForPointsSP ? d = 0 : (d = (a.timeForPointsSP -
        b) / d * a.maxPointsTimer, d = Math.floor(d));
    Application.info("_scoreObjects: " + c);
    Application.info("_timeTotal: " + b);
    Application.info("_scoreTimer: " + d);
    d = c + d;
    this.m_totalStar = d < a.minPointsStar1 ? 0 : d < a.minPointsStar2 ? 1 : d < a.minPointsStar3 ? 2 : 3;
    this.getControl("mcGuiTextTotalNumber").setText("" + d);
    this.getControl("mcGuiPanelCharacter").clip.gotoAndStop(Global.playerSelected);
    this.getControl("mcGuiPanelInfo2").setText(this.setTimer(b));
    this.getControl("mcGuiCharacter").setClip("gui_popups_endlevel_character0" +
        Global.playerSelected);
    PlayerSettings.instance.setStars(this.m_totalStar, Global.level, MissionManager.instance.getMissionType());
    PlayerSettings.instance.setUsedCharacter(PlayerSettings.instance.m_currentPlayer - 1);
    PlayerSettings.instance.checkAchievement();
    a = Math.floor(Date.now() / ScoreAPI.ONE_DAY_MS);
    a !== Global.data.data.lastPlayedDay && (Global.data.data.lastPlayedDay = a, Global.data.data.myBestScore = 0);
    Global.data.data.myBestScore += d;
    Global.data.save();
    ScoreAPI.instance.api && !window.config.settings.HIDE_LEADERBOARD_BUTTON &&
        PlatformGame.instance.checkMaxScores(Global.data.data.myBestScore)
};
GuiPopupEndLevelSP.prototype.setTimer = function(a) {
    if (1E6 < a) return "00:00";
    var b = Math.floor(a / 1E3);
    a = Math.floor(b / 60);
    b %= 60;
    return (10 > a ? "0" + a : a) + ":" + (10 > b ? "0" + b : b)
};
GuiPopupEndLevelSP.prototype.update = function(a) {
    this.popup ? this.popup.update(a) : (this.m_interval && this.m_interval.update(a), this.currentStar && 6 < this.currentStar.currentFrame && (Application.instance.effectManager.createEffect("guiFxPopupEndlevelStarBurst", 0, 0, this.currentStar), Application.instance.playSound("SND_UI_STARS"), this.currentStar = null), SScreen.prototype.update.call(this, a));
    Application.instance.isPlayingSound("SND_BG_WIN") || Application.instance.isPlayingSound("SND_BG_LOSE") || Application.instance.isPlayingSound("SND_BG_SCORECARD") ||
        Application.instance.playSound("SND_BG_SCORECARD")
};
GuiPopupEndLevelSP.prototype.onUIPress = function(a) {
    SScreen.prototype.onUIPress.call(this, a);
    Application.instance.playSound("SND_UI_CLICK")
};
GuiPopupEndLevelSP.prototype.enableHud = function(a) {
    for (var b in this.controls) this.getControl(b).clip ? this.getControl(b).setVisible(a) : this.getControl(b).setAlpha(a)
};
GuiPopupEndLevelSP.prototype.onUIRelease = function(a) {
    SScreen.prototype.onUIRelease.call(this, a);
    if (this.activeRelease) {
        switch (this.lastInteractionControl) {
            case "mcGuiBtnNext":
                PlatformGame.instance.isHighScore ? GuiGame.instance.addPopup(GuiPopupName, "mcGuiPopupEnterName", 0, 0) : this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(PlayerSettings.instance.doFinalCutscene ? GuiManager.SC_ENDGAME : GuiManager.SC_SELECT_LOCATION));
                break;
            case "mcGuiBtnReplay":
                this.screenParent && (this.screenParent.dropPopup(),
                    GuiManager.instance.gotoScreen(GuiManager.SC_GAME));
                break;
            case "mcGuiBtnTrophies":
                this.getControl("mcGuiBtnTrophies").gotoState(GuiControl.ST_ENABLE);
                this.showVisiblePopup(!1);
                this.addPopup(GuiPopupTrophies, "mcGuiPopupTrophies");
                this.achievFx && (this.achievFx.isAwaitingDelete = !0);
                break;
            case "mcGuiBtnMainmenu":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU))
        }
        this.activeRelease = !1;
        a.onResetState()
    }
};
GuiPopupEndLevelSP.prototype.onKeyDown = function(a) {
    switch (a) {
        case PlayerPlatform.KEY_ATTACK:
            this.lastInteractionControl = "mcGuiBtnNext", this.onUIRelease(this.getControl("mcGuiBtnNext"))
    }
};

function GuiPopupEndLevelCop(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = GuiManager.POPUP_ENDLEVEL_COOP;
    this.m_countStar = 0;
    this.m_totalStar = 2;
    this.achievFx = this.currentStar = this.m_interval = null;
    this.state = GuiPopupEndLevelCop.ST_FIRST_SCREEN;
    this.getControl("mcGuiCharacter1").setClip("gui_popups_endlevel_character0" + Global.playersForGame[0]);
    this.getControl("mcGuiCharacter2").setClip("gui_popups_endlevel_character0" + Global.playersForGame[1]);
    this.getControl("mcGuiBtnMoregames") && this.getControl("mcGuiBtnMoregames").setVisible(!window.config.settings.HIDE_ARCADE_BUTTON);
    this.getControl("mcGuiBtnFxTrophies") && GuiGame.instance.showingAchiev && (this.achievFx = Application.instance.effectManager.createEffect("guiFxButtonAlertLoop", 0, 0, this.getControl("mcGuiBtnFxTrophies").clip))
}
Application.subclass(GuiPopupEndLevelCop, SScreen);
GuiPopupEndLevelCop.ST_FIRST_SCREEN = 0;
GuiPopupEndLevelCop.ST_SECOND_SCREEN = 1;
GuiPopupEndLevelCop.prototype.onActionScreen = function() {
    this.dropPopup();
    this.showVisiblePopup(!0)
};
GuiPopupEndLevelCop.prototype.showVisiblePopup = function(a) {
    for (var b in this.controls) "mcGuiBg" !== this.controls[b].name && (this.controls[b].clip ? this.controls[b].setVisible(a) : this.controls[b].setAlpha(a ? 1 : 0));
    this.getControl("mcGuiDefeatedbossBar").setVisible(MissionManager.instance.isMissionBossBattle() && a);
    this.getControl("mcGuiDefeatedbossBar2").setVisible(MissionManager.instance.isMissionBossBattle() && a)
};
GuiPopupEndLevelCop.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    this.m_interval = new SInterval(this, "onEndInterval", 100)
};
GuiPopupEndLevelCop.prototype.onEndInterval = function() {
    this.m_interval && this.m_interval.free();
    this.m_interval = null;
    Application.log("STAR " + this.m_countStar + "  :::: TOTAL " + this.m_totalStar);
    this.m_countStar >= this.m_totalStar || (this.m_countStar++, this.m_interval = new SInterval(this, "onEndInterval", 500), this.getControl("mcGuiStarOn0" + this.m_countStar).clip.gotoAndPlay(2), this.currentStar = this.getControl("mcGuiStarOn0" + this.m_countStar).clip)
};
GuiPopupEndLevelCop.prototype.update = function(a) {
    this.popup ? this.popup.update(a) : (this.m_interval && this.m_interval.update(a), this.currentStar && 6 < this.currentStar.currentFrame && (Application.instance.effectManager.createEffect("guiFxPopupEndlevelStarBurst", 0, 0, this.currentStar), Application.instance.playSound("SND_UI_STARS"), this.currentStar = null), SScreen.prototype.update.call(this, a));
    Application.instance.isPlayingSound("SND_BG_WIN") || Application.instance.isPlayingSound("SND_BG_LOSE") || Application.instance.isPlayingSound("SND_BG_SCORECARD") ||
        Application.instance.playSound("SND_BG_SCORECARD")
};
GuiPopupEndLevelCop.prototype.onLoadData = function(a) {
    this.getControl("mcGuiDefeatedbossBar").setVisible(!1);
    this.getControl("mcGuiDefeatedbossBar2").setVisible(!1);
    this.localizedTitle("gui_localized_title_endlevel", this.getControl("mcGuiTextTitle").clip, 450, 44);
    switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            this.getControl("mcGuiPanelTitle1").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_1");
            this.getControl("mcGuiPanelTitle3").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_1");
            this.getControl("mcGuiPanelInfo1").setText(a.itemsPlayer01 +
                "/" + PlayerSettings.instance.getBothPlayersTotalItems());
            this.getControl("mcGuiPanelInfo2").setText(a.itemsPlayer02 + "/" + PlayerSettings.instance.getBothPlayersTotalItems());
            break;
        case MissionManager.MISSION_LIBERATION:
            this.getControl("mcGuiPanelTitle1").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_2");
            this.getControl("mcGuiPanelTitle3").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_2");
            this.getControl("mcGuiPanelInfo1").setText(a.itemsPlayer01 + "/" + PlayerSettings.instance.getTotalBases());
            this.getControl("mcGuiPanelInfo2").setText(a.itemsPlayer02 +
                "/" + PlayerSettings.instance.getTotalBases());
            break;
        case MissionManager.MISSION_SABOTAGE:
            this.getControl("mcGuiPanelTitle1").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_3");
            this.getControl("mcGuiPanelTitle3").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_3");
            this.getControl("mcGuiPanelInfo1").setText(a.itemsPlayer01 + (PlayerSettings.instance.player1GotAntenna ? 1 : 0) + "/" + (PlayerSettings.instance.getBothPlayersTotalSabotages() + 1));
            this.getControl("mcGuiPanelInfo2").setText(a.itemsPlayer02 + (PlayerSettings.instance.player2GotAntenna ?
                1 : 0) + "/" + (PlayerSettings.instance.getBothPlayersTotalSabotages() + 1));
            break;
        case MissionManager.MISSION_BOSS_BATTLE:
            this.getControl("mcGuiPanelTitle1").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_4"), this.getControl("mcGuiPanelTitle3").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_4"), this.getControl("mcGuiPanelInfo1").setText(a.percent1 + Application.strings.STR_ENDLEVEL_PERCENT), this.getControl("mcGuiPanelInfo2").setText(a.percent2 + Application.strings.STR_ENDLEVEL_PERCENT), this.getControl("mcGuiDefeatedbossBar").setVisible(!0),
                this.getControl("mcGuiDefeatedbossBar2").setVisible(!0), this.getControl("mcGuiDefeatedbossBar").clip.gotoAndStop(a.frame1), this.getControl("mcGuiDefeatedbossBar2").clip.gotoAndStop(a.frame2), PlayerSettings.instance.player1GotDamage && PlayerSettings.instance.player2GotDamage || Global.data.dataArcade.trophies.trophy8.achieved || (Global.data.dataArcade.trophies.trophy8.achieved = !0, GuiGame.instance.addAchievPopup(8), Global.data.save())
    }
    var b = a.scoreTotal1 + a.scoreTotal2;
    this.m_totalStar = b < a.m_currentMission.minPointsStar1Coop ?
        0 : b < a.m_currentMission.minPointsStar2Coop ? 1 : b < a.m_currentMission.minPointsStar3Coop ? 2 : 3;
    this.getControl("mcGuiPlayer01").clip.gotoAndStop(Global.playersForGame[a.firstPlaceId - 1]);
    this.getControl("mcGuiCharacter1").setClip("gui_popups_endlevel_character0" + Global.playersForGame[a.firstPlaceId - 1]);
    this.getControl("mcGuiPlayer02").clip.gotoAndStop(Global.playersForGame[a.secondPlaceId - 1]);
    this.getControl("mcGuiCharacter2").setClip("gui_popups_endlevel_character0" + Global.playersForGame[a.secondPlaceId -
        1]);
    this.getControl("mcGuiPanelInfo4").setText(this.setTimer(a.timeFirstPlace));
    this.getControl("mcGuiPanelInfo3").setText(this.setTimer(a.timeSecondPlace));
    this.getControl("mcGuiTextPlayer01").setTextLocalized("STR_ENDLEVEL_TOTAL");
    this.getControl("mcGuiTextCharacter01").setTextLocalized("STR_SELECTCHARACTER_0" + Global.playersForGame[a.firstPlaceId - 1]);
    this.getControl("mcGuiTextNumber01").setText(a.scoreFirstPlace);
    this.getControl("mcGuiTextPlayer02").setTextLocalized("STR_ENDLEVEL_TOTAL");
    this.getControl("mcGuiTextCharacter02").setTextLocalized("STR_SELECTCHARACTER_0" +
        Global.playersForGame[a.secondPlaceId - 1]);
    this.getControl("mcGuiTextNumber02").setText(a.scoreSecondPlace);
    this.getControl("mcGuiTextTotalNumber").setText(b);
    if (1 === a.secondPlaceId && PlayerSettings.instance.player1LoseByHealth || 2 === a.secondPlaceId && PlayerSettings.instance.player2LoseByHealth) this.getControl("mcGuiTextCharacter02").textfield.setText({
            string: Application.strings["STR_SELECTCHARACTER_0" + Global.playersForGame[a.secondPlaceId - 1] + "_CAPTURED"],
            color: "#c59292",
            size: 0,
            font: ""
        }), this.getControl("mcGuiTextCharacter02").textfield.updateText(),
        this.getControl("mcGuiPanelTitle3").style.fill = "#d4d4d4", this.getControl("mcGuiPanelTitle3").textfield.updateText(), this.getControl("mcGuiPanelTitle4").style.fill = "#d4d4d4", this.getControl("mcGuiPanelTitle4").textfield.updateText(), this.getControl("mcGuiTextPlayer02").style.fill = "#d4d4d4", this.getControl("mcGuiTextPlayer02").textfield.updateText(), this.getControl("mcGuiPanelInfo2").style.fill = "#d4d4d4", this.getControl("mcGuiPanelInfo2").textfield.updateText(), this.getControl("mcGuiPanelInfo3").style.fill =
        "#d4d4d4", this.getControl("mcGuiPanelInfo3").textfield.updateText(), this.getControl("mcGuiTextNumber02").style.fill = "#d4d4d4", this.getControl("mcGuiTextNumber02").textfield.updateText(), this.getControl("mcGuiTextBase02").setClip("gui_popups_endlevel_textbase02");
    PlayerSettings.instance.setStars(this.m_totalStar, Global.level, MissionManager.instance.getMissionType());
    PlayerSettings.instance.setUsedCharacter(Global.playersForGame[0] - 1);
    PlayerSettings.instance.setUsedCharacter(Global.playersForGame[1] -
        1);
    PlayerSettings.instance.checkAchievement()
};
GuiPopupEndLevelCop.prototype.setTimer = function(a) {
    var b = Math.floor(a / 1E3);
    a = Math.floor(b / 60);
    b %= 60;
    return (10 > a ? "0" + a : a) + ":" + (10 > b ? "0" + b : b)
};
GuiPopupEndLevelCop.prototype.onUIPress = function(a) {
    SScreen.prototype.onUIPress.call(this, a);
    Application.instance.playSound("SND_UI_CLICK")
};
GuiPopupEndLevelCop.prototype.onUIRelease = function(a) {
    SScreen.prototype.onUIRelease.call(this, a);
    if (this.activeRelease) {
        switch (this.lastInteractionControl) {
            case "mcGuiBtnNext":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_LOCATION));
                break;
            case "mcGuiBtnReplay":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_GAME));
                break;
            case "mcGuiBtnTrophies":
                this.getControl("mcGuiBtnTrophies").gotoState(GuiControl.ST_ENABLE);
                this.showVisiblePopup(!1);
                this.addPopup(GuiPopupTrophies, "mcGuiPopupTrophies");
                this.achievFx && (this.achievFx.isAwaitingDelete = !0);
                break;
            case "mcGuiBtnMainmenu":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU))
        }
        this.activeRelease = !1;
        a.onResetState()
    }
};
GuiPopupEndLevelCop.prototype.onKeyDown = function(a) {
    switch (a) {
        case PlayerPlatform.KEY_ATTACK:
            this.lastInteractionControl = "mcGuiBtnNext", this.onUIRelease(this.getControl("mcGuiBtnNext"))
    }
};

function GuiPopupEndLevelVS(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = GuiManager.POPUP_ENDLEVEL_VS;
    this.state = GuiPopupEndLevelVS.ST_FIRST_SCREEN;
    this.achievFx = null;
    this.getControl("mcGuiBtnMoregames") && this.getControl("mcGuiBtnMoregames").setVisible(!window.config.settings.HIDE_ARCADE_BUTTON);
    this.getControl("mcGuiBtnFxTrophies") && GuiGame.instance.showingAchiev && (this.achievFx = Application.instance.effectManager.createEffect("guiFxButtonAlertLoop", 0, 0, this.getControl("mcGuiBtnFxTrophies").clip))
}
Application.subclass(GuiPopupEndLevelVS, SScreen);
GuiPopupEndLevelVS.ST_FIRST_SCREEN = 0;
GuiPopupEndLevelVS.ST_SECOND_SCREEN = 1;
GuiPopupEndLevelVS.prototype.onActionScreen = function() {
    this.dropPopup();
    this.showVisiblePopup(!0)
};
GuiPopupEndLevelVS.prototype.showVisiblePopup = function(a) {
    for (var b in this.controls) "mcGuiBg" !== this.controls[b].name && (this.controls[b].clip ? this.controls[b].setVisible(a) : this.controls[b].setAlpha(a ? 1 : 0));
    this.getControl("mcGuiDefeatedbossBar").setVisible(MissionManager.instance.isMissionBossBattle() && a);
    this.getControl("mcGuiDefeatedbossBar2").setVisible(MissionManager.instance.isMissionBossBattle() && a)
};
GuiPopupEndLevelVS.prototype.onLoadData = function(a) {
    this.getControl("mcGuiDefeatedbossBar").setVisible(!1);
    this.getControl("mcGuiDefeatedbossBar2").setVisible(!1);
    switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            this.getControl("mcGuiTextPlayer01").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_1");
            this.getControl("mcGuiTextPlayer02").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_1");
            this.getControl("mcGuiTextNumber01").setText(a.itemsPlayer01 + "/" + PlayerSettings.instance.getTotalItems());
            this.getControl("mcGuiTextNumber02").setText(a.itemsPlayer02 + "/" + PlayerSettings.instance.getTotalItems());
            break;
        case MissionManager.MISSION_LIBERATION:
            this.getControl("mcGuiTextPlayer01").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_2");
            this.getControl("mcGuiTextPlayer02").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_2");
            this.getControl("mcGuiTextNumber01").setText(a.itemsPlayer01 + "/" + PlayerSettings.instance.getTotalBases());
            this.getControl("mcGuiTextNumber02").setText(a.itemsPlayer02 + "/" + PlayerSettings.instance.getTotalBases());
            break;
        case MissionManager.MISSION_SABOTAGE:
            this.getControl("mcGuiTextPlayer01").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_3");
            this.getControl("mcGuiTextPlayer02").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_3");
            this.getControl("mcGuiTextNumber01").setText(a.itemsPlayer01 + (PlayerSettings.instance.player1GotAntenna ? 1 : 0) + "/" + (PlayerSettings.instance.getTotalSabotages() + 1));
            this.getControl("mcGuiTextNumber02").setText(a.itemsPlayer02 + (PlayerSettings.instance.player2GotAntenna ? 1 : 0) + "/" + (PlayerSettings.instance.getTotalSabotages() +
                1));
            break;
        case MissionManager.MISSION_BOSS_BATTLE:
            this.getControl("mcGuiTextPlayer01").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_4"), this.getControl("mcGuiTextPlayer02").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_4"), this.getControl("mcGuiTextNumber01").setText(a.percent1 + Application.strings.STR_ENDLEVEL_PERCENT), this.getControl("mcGuiTextNumber02").setText(a.percent2 + Application.strings.STR_ENDLEVEL_PERCENT), this.getControl("mcGuiDefeatedbossBar").setVisible(!0), this.getControl("mcGuiDefeatedbossBar2").setVisible(!0),
                this.getControl("mcGuiDefeatedbossBar").clip.gotoAndStop(a.frame1), this.getControl("mcGuiDefeatedbossBar2").clip.gotoAndStop(a.frame2)
    }
    this.localizedTitle("gui_localized_title_endlevelvs_" + Global.playersForGame[a.firstPlaceId - 1], this.getControl("mcGuiTextTitle").clip, 450, 44);
    this.getControl("mcGuiWinnerCharacter").clip.gotoAndStop(Global.playersForGame[a.firstPlaceId - 1]);
    this.getControl("mcGuiLoserCharacter").clip.gotoAndStop(Global.playersForGame[a.secondPlaceId - 1]);
    this.getControl("mcGuiTextNumber04").setText(this.setTimer(a.timeFirstPlace));
    this.getControl("mcGuiTextNumber03").setText(this.setTimer(a.timeSecondPlace));
    this.getControl("mcGuiTxtWinnerName").setTextLocalized("STR_SELECTCHARACTER_0" + Global.playersForGame[a.firstPlaceId - 1]);
    this.getControl("mcGuiTxtWinnerNmb").setText(a.scoreFirstPlace);
    this.getControl("mcGuiTxtLoserName").setTextLocalized("STR_SELECTCHARACTER_0" + Global.playersForGame[a.secondPlaceId - 1]);
    this.getControl("mcGuiTxtLoserNmb").setText(a.scoreSecondPlace);
    this.getControl("mcGuiCharacter").setClip("gui_popups_endlevel_character0" +
        Global.playersForGame[a.firstPlaceId - 1]);
    if (1 === a.secondPlaceId && !PlayerSettings.instance.player1Won || 2 === a.secondPlaceId && !PlayerSettings.instance.player2Won) this.getControl("mcGuiTxtLoserName").textfield.setText({
            string: Application.strings["STR_SELECTCHARACTER_0" + Global.playersForGame[a.secondPlaceId - 1] + "_CAPTURED"],
            color: "#c59292",
            size: 0,
            font: ""
        }), this.getControl("mcGuiTxtLoserName").textfield.updateText(), this.getControl("mcGuiTextPlayer02").style.fill = "#d4d4d4", this.getControl("mcGuiTextPlayer02").textfield.updateText(),
        this.getControl("mcGuiTextCharacter02").style.fill = "#d4d4d4", this.getControl("mcGuiTextCharacter02").textfield.updateText(), this.getControl("mcGuiTxtLoserTotal").style.fill = "#d4d4d4", this.getControl("mcGuiTxtLoserTotal").textfield.updateText(), this.getControl("mcGuiTextNumber02").style.fill = "#d4d4d4", this.getControl("mcGuiTextNumber02").textfield.updateText(), this.getControl("mcGuiTextNumber03").style.fill = "#d4d4d4", this.getControl("mcGuiTextNumber03").textfield.updateText(), this.getControl("mcGuiTxtLoserNmb").style.fill =
        "#d4d4d4", this.getControl("mcGuiTxtLoserNmb").textfield.updateText(), this.getControl("mcGuiTextBase04").setClip("gui_popups_endlevel_textbase02");
    PlayerSettings.instance.setStars(0, Global.level, MissionManager.instance.getMissionType());
    PlayerSettings.instance.setUsedCharacter(Global.playersForGame[0] - 1);
    PlayerSettings.instance.setUsedCharacter(Global.playersForGame[1] - 1);
    PlayerSettings.instance.checkAchievement()
};
GuiPopupEndLevelVS.prototype.setTimer = function(a) {
    if (1E6 < a) return "00:00";
    var b = Math.floor(a / 1E3);
    a = Math.floor(b / 60);
    b %= 60;
    return (10 > a ? "0" + a : a) + ":" + (10 > b ? "0" + b : b)
};
GuiPopupEndLevelVS.prototype.onUIPress = function(a) {
    SScreen.prototype.onUIPress.call(this, a);
    Application.instance.playSound("SND_UI_CLICK")
};
GuiPopupEndLevelVS.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this)
};
GuiPopupEndLevelVS.prototype.onUIRelease = function(a) {
    SScreen.prototype.onUIRelease.call(this, a);
    if (this.activeRelease) {
        switch (this.lastInteractionControl) {
            case "mcGuiBtnNext":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_LOCATION));
                break;
            case "mcGuiBtnReplay":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_GAME));
                break;
            case "mcGuiBtnTrophies":
                this.getControl("mcGuiBtnTrophies").gotoState(GuiControl.ST_ENABLE);
                this.showVisiblePopup(!1);
                this.addPopup(GuiPopupTrophies, "mcGuiPopupTrophies");
                this.achievFx && (this.achievFx.isAwaitingDelete = !0);
                break;
            case "mcGuiBtnMainmenu":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU))
        }
        this.activeRelease = !1;
        a.onResetState()
    }
};
GuiPopupEndLevelVS.prototype.update = function(a) {
    this.popup ? this.popup.update(a) : (SScreen.prototype.update.call(this, a), Application.instance.isPlayingSound("SND_BG_WIN") || Application.instance.isPlayingSound("SND_BG_LOSE") || Application.instance.isPlayingSound("SND_BG_SCORECARD") || Application.instance.playSound("SND_BG_SCORECARD"))
};
GuiPopupEndLevelVS.prototype.onKeyDown = function(a) {
    switch (a) {
        case PlayerPlatform.KEY_ATTACK:
            this.lastInteractionControl = "mcGuiBtnNext", this.onUIRelease(this.getControl("mcGuiBtnNext"))
    }
};

function GuiPopupEndLevelDraw(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = GuiManager.POPUP_ENDLEVEL_DRAW;
    this.state = GuiPopupEndLevelDraw.ST_FIRST_SCREEN;
    this.achievFx = null;
    this.getControl("mcGuiBtnMoregames") && this.getControl("mcGuiBtnMoregames").setVisible(!window.config.settings.HIDE_ARCADE_BUTTON);
    this.getControl("mcGuiBtnFxTrophies") && GuiGame.instance.showingAchiev && (this.achievFx = Application.instance.effectManager.createEffect("guiFxButtonAlertLoop", 0, 0, this.getControl("mcGuiBtnFxTrophies").clip))
}
Application.subclass(GuiPopupEndLevelDraw, SScreen);
GuiPopupEndLevelDraw.ST_FIRST_SCREEN = 0;
GuiPopupEndLevelDraw.ST_SECOND_SCREEN = 1;
GuiPopupEndLevelDraw.prototype.onActionScreen = function() {
    this.dropPopup();
    this.showVisiblePopup(!0)
};
GuiPopupEndLevelDraw.prototype.showVisiblePopup = function(a) {
    for (var b in this.controls) "mcGuiBg" !== this.controls[b].name && (this.controls[b].clip ? this.controls[b].setVisible(a) : this.controls[b].setAlpha(a ? 1 : 0));
    this.getControl("mcGuiDefeatedbossBar").setVisible(MissionManager.instance.isMissionBossBattle() && a);
    this.getControl("mcGuiDefeatedbossBar2").setVisible(MissionManager.instance.isMissionBossBattle() && a)
};
GuiPopupEndLevelDraw.prototype.onLoadData = function(a) {
    this.getControl("mcGuiDefeatedbossBar").setVisible(!1);
    this.getControl("mcGuiDefeatedbossBar2").setVisible(!1);
    switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            this.getControl("mcGuiPanelTitle1").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_1");
            this.getControl("mcGuiPanelTitle3").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_1");
            this.getControl("mcGuiPanelInfo1").setText(a.itemsPlayer01 + "/" + PlayerSettings.instance.getTotalItems());
            this.getControl("mcGuiPanelInfo2").setText(a.itemsPlayer02 + "/" + PlayerSettings.instance.getTotalItems());
            break;
        case MissionManager.MISSION_LIBERATION:
            this.getControl("mcGuiPanelTitle1").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_2");
            this.getControl("mcGuiPanelTitle3").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_2");
            this.getControl("mcGuiPanelInfo1").setText(a.itemsPlayer01 + "/" + PlayerSettings.instance.getTotalBases());
            this.getControl("mcGuiPanelInfo2").setText(a.itemsPlayer02 + "/" + PlayerSettings.instance.getTotalBases());
            break;
        case MissionManager.MISSION_SABOTAGE:
            this.getControl("mcGuiPanelTitle1").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_3");
            this.getControl("mcGuiPanelTitle3").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_3");
            this.getControl("mcGuiPanelInfo1").setText(a.itemsPlayer01 + (PlayerSettings.instance.player1GotAntenna ? 1 : 0) + "/" + (PlayerSettings.instance.getTotalSabotages() + 1));
            this.getControl("mcGuiPanelInfo2").setText(a.itemsPlayer02 + (PlayerSettings.instance.player2GotAntenna ? 1 : 0) + "/" + (PlayerSettings.instance.getTotalSabotages() +
                1));
            break;
        case MissionManager.MISSION_BOSS_BATTLE:
            this.getControl("mcGuiPanelTitle1").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_4"), this.getControl("mcGuiPanelTitle3").setTextLocalized("STR_ENDLEVEL_PANEL_TITLE_4"), this.getControl("mcGuiPanelInfo1").setText(a.percent1 + Application.strings.STR_ENDLEVEL_PERCENT), this.getControl("mcGuiPanelInfo2").setText(a.percent2 + Application.strings.STR_ENDLEVEL_PERCENT), this.getControl("mcGuiDefeatedbossBar").setVisible(!0), this.getControl("mcGuiDefeatedbossBar2").setVisible(!0),
                this.getControl("mcGuiDefeatedbossBar").clip.gotoAndStop(a.frame1), this.getControl("mcGuiDefeatedbossBar2").clip.gotoAndStop(a.frame2)
    }
    this.localizedTitle("gui_localized_title_endlevel_draw", this.getControl("mcGuiTextTitle").clip, 450, 44);
    this.getControl("mcGuiPlayer01").clip.gotoAndStop(Global.playersForGame[a.firstPlaceId - 1]);
    this.getControl("mcGuiCharacter1").setClip("gui_popups_endlevel_character0" + Global.playersForGame[a.firstPlaceId - 1]);
    this.getControl("mcGuiPlayer02").clip.gotoAndStop(Global.playersForGame[a.secondPlaceId -
        1]);
    this.getControl("mcGuiCharacter2").setClip("gui_popups_endlevel_character0" + Global.playersForGame[a.secondPlaceId - 1]);
    this.getControl("mcGuiPanelInfo4").setText(this.setTimer(a.timeFirstPlace));
    this.getControl("mcGuiPanelInfo3").setText(this.setTimer(a.timeSecondPlace));
    this.getControl("mcGuiTextPlayer01").setTextLocalized("STR_ENDLEVEL_TOTAL");
    this.getControl("mcGuiTextCharacter01").setTextLocalized("STR_SELECTCHARACTER_0" + Global.playersForGame[a.firstPlaceId - 1]);
    this.getControl("mcGuiTextNumber01").setText(a.scoreFirstPlace);
    this.getControl("mcGuiTextPlayer02").setTextLocalized("STR_ENDLEVEL_TOTAL");
    this.getControl("mcGuiTextCharacter02").setTextLocalized("STR_SELECTCHARACTER_0" + Global.playersForGame[a.secondPlaceId - 1]);
    this.getControl("mcGuiTextNumber02").setText(a.scoreSecondPlace);
    PlayerSettings.instance.setStars(0, Global.level, MissionManager.instance.getMissionType());
    PlayerSettings.instance.setUsedCharacter(Global.playersForGame[0] - 1);
    PlayerSettings.instance.setUsedCharacter(Global.playersForGame[1] - 1);
    PlayerSettings.instance.checkAchievement()
};
GuiPopupEndLevelDraw.prototype.setTimer = function(a) {
    if (1E6 < a) return "00:00";
    var b = Math.floor(a / 1E3);
    a = Math.floor(b / 60);
    b %= 60;
    return (10 > a ? "0" + a : a) + ":" + (10 > b ? "0" + b : b)
};
GuiPopupEndLevelDraw.prototype.onUIPress = function(a) {
    SScreen.prototype.onUIPress.call(this, a);
    Application.instance.playSound("SND_UI_CLICK")
};
GuiPopupEndLevelDraw.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this)
};
GuiPopupEndLevelDraw.prototype.onUIRelease = function(a) {
    SScreen.prototype.onUIRelease.call(this, a);
    if (this.activeRelease) {
        switch (this.lastInteractionControl) {
            case "mcGuiBtnNext":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_LOCATION));
                break;
            case "mcGuiBtnReplay":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_GAME));
                break;
            case "mcGuiBtnTrophies":
                this.getControl("mcGuiBtnTrophies").gotoState(GuiControl.ST_ENABLE);
                this.showVisiblePopup(!1);
                this.addPopup(GuiPopupTrophies, "mcGuiPopupTrophies");
                this.achievFx && (this.achievFx.isAwaitingDelete = !0);
                break;
            case "mcGuiBtnMainmenu":
                this.screenParent && (this.screenParent.dropPopup(), GuiManager.instance.gotoScreen(GuiManager.SC_MAIN_MENU))
        }
        this.activeRelease = !1;
        a.onResetState()
    }
};
GuiPopupEndLevelDraw.prototype.update = function(a) {
    this.popup ? this.popup.update(a) : (SScreen.prototype.update.call(this, a), Application.instance.isPlayingSound("SND_BG_SCORECARD") || Application.instance.playSound("SND_BG_SCORECARD"))
};
GuiPopupEndLevelDraw.prototype.onKeyDown = function(a) {
    switch (a) {
        case PlayerPlatform.KEY_ATTACK:
            this.lastInteractionControl = "mcGuiBtnNext", this.onUIRelease(this.getControl("mcGuiBtnNext"))
    }
};

function GuiPopupTrophies(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = "popup_trophies";
    this.m_trophies = [!1, !1, !1, !1, !1, !1, !1, !1, !1];
    for (a = 0; 9 > a; a++) this.m_trophies[a] = Global.data.dataArcade.trophies["trophy" + (a + 1)].achieved;
    this.m_stateUnlock = 1;
    this.m_timeAnimation = 0;
    this.m_screenItems = null;
    this.m_idTrophie = 0;
    this.m_stateDisplace = GuiPopupTrophies.ST_NONE;
    this.mask = (new window.PIXI.Graphics).beginFill(16711680).drawRect(240, -180, 330, 360);
    this.getControl("mcContentMask").canvas.addChild(this.mask);
    this.m_screenItems = new GuiPopupTrophiesItems("mcGuiPopupTrophiesSide", this);
    this.m_screenItems.canvas.ox = 0;
    this.m_screenItems.canvas.oy = 0;
    this.getControl("mcContentBase02").canvas.addChild(this.m_screenItems.canvas);
    this.m_screenItems.clip.mask = this.mask;
    this.localizedTitle("gui_localized_title_trophies", this.getControl("mcGuiTextTitle").clip, 450, 44);
    this.m_idTrophie = 1;
    this.stateOn(this.m_idTrophie, !0);
    this.screenParent && (this.screenParent.name === GuiManager.SC_MAIN_MENU ? this.applyBlur() : this.getControl("mcGuiBg").setVisible(!1));
    Application.instance.playSound("SND_UI_POPUP_GENERAL")
}
Application.subclass(GuiPopupTrophies, SScreen);
GuiPopupTrophies.ST_NONE = "stNone";
GuiPopupTrophies.ST_APPEAR = "stAppear";
GuiPopupTrophies.ST_DISAPPEAR = "stDisappear";
GuiPopupTrophies.prototype.onUIPress = function(a) {
    if (!this.onPress) switch (SScreen.prototype.onUIPress.call(this, a), Application.instance.playSound("SND_UI_CLICK"), a.name) {
        case "mcGuiBtnClose":
            this.screenParent.onActionBack();
            break;
        case "mcGuiBtnTrophy01":
        case "mcGuiBtnTrophy02":
        case "mcGuiBtnTrophy03":
        case "mcGuiBtnTrophy04":
        case "mcGuiBtnTrophy05":
        case "mcGuiBtnTrophy06":
        case "mcGuiBtnTrophy07":
        case "mcGuiBtnTrophy08":
        case "mcGuiBtnTrophy09":
            this.m_idTrophie = parseInt(a.name.substr(15), 10), this.stateOn(this.m_idTrophie, !0)
    }
};
GuiPopupTrophies.prototype.onUIRelease = function(a) {
    SScreen.prototype.onUIRelease.call(this, a);
    if (this.activeRelease && !this.onPress) {
        switch (a.name) {
            case "mcGuiBtnClose":
                this.onPress = !0, this.onResumeScreen()
        }
        this.activeRelease = !1;
        a.onResetState()
    }
};
GuiPopupTrophies.prototype.onFinishScreen = function() {
    if ("mcGuiBtnClose" === this.lastInteractionControl && this.screenParent)
        if (this.screenParent.name === GuiManager.SC_MAIN_MENU) this.screenParent.dropPopup();
        else this.screenParent.onActionScreen()
};
GuiPopupTrophies.prototype.stateOn = function(a, b) {
    b = "undefined" !== typeof b ? b : !1;
    for (var c = 0; c < this.m_trophies.length; c++) {
        var d = c + 1;
        this.getControl("mcGuiBtnTrophy0" + d).setClip(this.m_trophies[c] ? "mcGuiTrophy0" + d : "mcGuiTrophy0" + d + "_off")
    }
    b && (c = this.m_trophies[a - 1], this.getControl("mcGuiBtnTrophy0" + a).setClip(c ? "mcGuiTrophy0" + a + "_select" : "mcGuiTrophy0" + a + "_off_select"), this.onMove())
};
GuiPopupTrophies.prototype.onMove = function() {
    this.m_stateDisplace === GuiPopupTrophies.ST_APPEAR ? this.itemsDisappear() : (this.m_screenItems.loadData(this.m_idTrophie, this.m_trophies[this.m_idTrophie - 1]), this.itemsAppear())
};
GuiPopupTrophies.prototype.itemsAppear = function() {
    Common.tween({
        parent: this,
        clip: this.m_screenItems.clip,
        x: 0,
        onComplete: this.onCompleteAppear
    }, {
        x: 400
    }, 250, !0, 0, TweenEasing.LinearNone)
};
GuiPopupTrophies.prototype.onCompleteAppear = function(a) {
    this.m_stateDisplace = GuiPopupTrophies.ST_APPEAR
};
GuiPopupTrophies.prototype.itemsDisappear = function() {
    Common.tween({
        parent: this,
        clip: this.m_screenItems.clip,
        x: 400,
        onComplete: this.onCompleteDisappear
    }, {
        x: 0
    }, 250, !0, 0, TweenEasing.LinearNone)
};
GuiPopupTrophies.prototype.onCompleteDisappear = function(a) {
    this.m_stateDisplace = GuiPopupTrophies.ST_DISAPPEAR;
    this.m_screenItems.loadData(this.m_idTrophie, this.m_trophies[this.m_idTrophie - 1]);
    this.itemsAppear()
};
GuiPopupTrophies.prototype.free = function() {
    SScreen.prototype.free.call(this)
};
GuiPopupTrophies.prototype.onEndTransition = function(a) {
    SScreen.prototype.onEndTransition.call(this, a);
    a.params && Application.instance.guiManager.gotoScreen(a.params.screen)
};
GuiPopupTrophies.prototype.update = function(a) {
    SScreen.prototype.update.call(this, a)
};

function GuiPopupTrophiesItems(a, b) {
    SScreen.call(this, a, 0, 0, null);
    this.name = "popup_trophies_items";
    this.m_trophie = b;
    this.loadData(1, Global.data.dataArcade.trophies.trophy1.achieved)
}
Application.subclass(GuiPopupTrophiesItems, SScreen);
GuiPopupTrophiesItems.prototype.loadData = function(a, b) {
    this.getControl("mcGuiTrophy").setClip(b ? "mcGuiTrophyUnlocked" : "mcGuiTrophyLocked");
    b && this.getControl("mcGuiTrophy").clip.gotoAndStop(a);
    this.getControl("mcGuiTrophy").clip.gotoAndStop(a);
    this.getControl("mcGuiTextName").setTextLocalized("STR_TROPHIES_TROPHY_NAME0" + a);
    this.getControl("mcGuiTextInfo").setTextLocalized("STR_TROPHIES_TROPHY_INFO0" + a)
};

function GuiPopupSelectMode(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = GuiManager.POPUP_SELECT_MODE;
    this.localizedTitle("gui_localized_title_selectmode", this.getControl("mcGuiTextTitle").clip, 450, 44);
    this.applyBlur();
    Application.instance.playSound("SND_UI_POPUP_GENERAL")
}
Application.subclass(GuiPopupSelectMode, SScreen);
GuiPopupSelectMode.prototype.onUIPress = function(a) {
    Application.instance.playSound("SND_UI_CLICK");
    switch (a.name) {
        case "mcGuiBtnClose":
            this.screenParent.dropPopup();
            break;
        case "mcGuiBtnSingle":
            MissionManager.instance.setGameMode(MissionManager.GAME_SINGLEPLAYER);
            PlayerSettings.instance.setNumberPlayers(1);
            GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_CHARACTER_SP);
            break;
        case "mcGuiBtnCoop":
            MissionManager.instance.setGameMode(MissionManager.GAME_COOPERATIVE);
            PlayerSettings.instance.setNumberPlayers(2);
            PlayerSettings.instance.resetMultiplayer();
            GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_CHARACTER_MP);
            break;
        case "mcGuiBtnVs":
            MissionManager.instance.setGameMode(MissionManager.GAME_VERSUS), PlayerSettings.instance.setNumberPlayers(2), PlayerSettings.instance.resetMultiplayer(), GuiManager.instance.gotoScreen(GuiManager.SC_SELECT_CHARACTER_MP)
    }
};
GuiPopupSelectMode.prototype.free = function() {
    SScreen.prototype.free.call(this)
};
GuiPopupSelectMode.prototype.onEndTransition = function(a) {
    SScreen.prototype.onEndTransition.call(this, a);
    a.params && Application.instance.guiManager.gotoScreen(a.params.screen)
};
GuiPopupSelectMode.prototype.onUIOver = function(a) {
    SScreen.prototype.onUIOver.call(this, a);
    Application.instance.playSound("SND_UI_CLICK")
};
GuiPopupSelectMode.prototype.update = function(a) {
    SScreen.prototype.update.call(this, a);
    if (a = this.getControl("mcGuiBtnSingle").clip.m_interpolations[0]) this.getControl("mcGuiTextSingle").canvas.scale.x = a.m_scaleX / Application.DPI, this.getControl("mcGuiTextSingle").canvas.scale.y = a.m_scaleY / Application.DPI;
    if (a = this.getControl("mcGuiBtnCoop").clip.m_interpolations[0]) this.getControl("mcGuiTextCoop").canvas.scale.x = a.m_scaleX / Application.DPI, this.getControl("mcGuiTextCoop").canvas.scale.y = a.m_scaleY / Application.DPI;
    if (a = this.getControl("mcGuiBtnVs").clip.m_interpolations[0]) this.getControl("mcGuiTextVs").canvas.scale.x = a.m_scaleX / Application.DPI, this.getControl("mcGuiTextVs").canvas.scale.y = a.m_scaleY / Application.DPI
};

function GuiPopupSelectMission(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.name = "popup_mission";
    this.applyBlur();
    Application.instance.playSound("SND_UI_POPUP_GENERAL")
}
Application.subclass(GuiPopupSelectMission, SScreen);
GuiPopupSelectMission.prototype.onUIPress = function(a) {
    switch (a.name) {
        case "mcGuiBtnBack":
            this.screenParent.onActionBack();
            break;
        case "mcGuiBtnHelp":
            this.addPopup(GuiPopupHelp, "mcGuiPopupHelp", 0, 0);
            break;
        case "mcGuiBtnSound":
            Application.instance.toggleMute();
            break;
        case "mcGuiBtnMission01":
            MissionManager.instance.setMissionType(MissionManager.MISSION_COLLECTION);
            Global.mission = 1;
            GuiManager.instance.gotoScreen(GuiManager.SC_GAME);
            Application.instance.playSound("SND_SELECT_MISSION");
            break;
        case "mcGuiBtnMission02":
            MissionManager.instance.setMissionType(MissionManager.MISSION_LIBERATION);
            Global.mission = 2;
            GuiManager.instance.gotoScreen(GuiManager.SC_GAME);
            Application.instance.playSound("SND_SELECT_MISSION");
            break;
        case "mcGuiBtnMission03":
            MissionManager.instance.setMissionType(MissionManager.MISSION_SABOTAGE);
            Global.mission = 3;
            GuiManager.instance.gotoScreen(GuiManager.SC_GAME);
            Application.instance.playSound("SND_SELECT_MISSION");
            break;
        case "mcGuiBtnMission04":
            MissionManager.instance.setMissionType(MissionManager.MISSION_BOSS_BATTLE), Global.mission = 4, GuiManager.instance.gotoScreen(GuiManager.SC_GAME),
                Application.instance.playSound("SND_SELECT_MISSION")
    }
};
GuiPopupSelectMission.prototype.free = function() {
    SScreen.prototype.free.call(this)
};
GuiPopupSelectMission.prototype.onEndTransition = function(a) {
    SScreen.prototype.onEndTransition.call(this, a);
    a.params && Application.instance.guiManager.gotoScreen(a.params.screen)
};
GuiPopupSelectMission.prototype.update = function(a) {
    SScreen.prototype.update.call(this, a);
    this.controls && this.checkStateSound("mcGuiBtnSound")
};

function GuiPopupMessage(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.className = "GuiPopupMessage";
    this.canvas.hitArea = null;
    this.m_visibleTime = 0;
    this.isDoingBlend = this.m_isCompleted = !1;
    this.doTimer = GuiPopupMessage.typeMessage === GuiPopupMessage.MESSAGE_TOKEN || GuiPopupMessage.typeMessage === GuiPopupMessage.MESSAGE_RETURN_EXTRACTION || GuiPopupMessage.typeMessage === GuiPopupMessage.MESSAGE_DESTROY_IMPERIALMACHINES || GuiPopupMessage.typeMessage === GuiPopupMessage.MESSAGE_RETURN_IMPERIALANTENNA || GuiPopupMessage.typeMessage ===
        GuiPopupMessage.MESSAGE_COLLECT_OBJECTIVE || GuiPopupMessage.typeMessage === GuiPopupMessage.MESSAGE_SABOTAGE_OBJECTIVE || GuiPopupMessage.typeMessage === GuiPopupMessage.MESSAGE_LIBERATION_OBJECTIVE;
    this.tutorialTimer = 0;
    this.initData()
}
Application.subclass(GuiPopupMessage, SScreen);
GuiPopupMessage.MAX_TIME = 3E3;
GuiPopupMessage.TUTORIAL_SHOW_TIME = 500;
GuiPopupMessage.typeMessage = 0;
GuiPopupMessage.isActive = !1;
GuiPopupMessage.MESSAGE_RETURN_EXTRACTION = 101;
GuiPopupMessage.MESSAGE_DESTROY_IMPERIALMACHINES = 103;
GuiPopupMessage.MESSAGE_RETURN_IMPERIALANTENNA = 104;
GuiPopupMessage.MESSAGE_COLLECT_OBJECTIVE = 105;
GuiPopupMessage.MESSAGE_SABOTAGE_OBJECTIVE = 106;
GuiPopupMessage.MESSAGE_LIBERATION_OBJECTIVE = 107;
GuiPopupMessage.MESSAGE_TOKEN = 108;
GuiPopupMessage.TUTORIAL_MOVE = 200;
GuiPopupMessage.TUTORIAL_JUMP = 201;
GuiPopupMessage.TUTORIAL_DOUBLE_JUMP = 202;
GuiPopupMessage.TUTORIAL_ATTACK = 203;
GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK = 204;
GuiPopupMessage.prototype.initData = function() {
    switch (GuiPopupMessage.typeMessage) {
        case GuiPopupMessage.MESSAGE_RETURN_EXTRACTION:
            Application.instance.playSound("SND_UI_POPUP_EXTRACTION");
            this.localizedTitle("gui_localized_missionupdate", this.getControl("mcGuiTxtMissionTitle").clip, 450, 44);
            break;
        case GuiPopupMessage.TUTORIAL_JUMP:
            Application.instance.playSound("SND_UI_POPUP_GENERAL");
            this.getControl("mcGuiTextInfo").setTextLocalized("STR_HELP_PAGE_1" + (Application.instance.isMobileDevice ? "_MOBILE" :
                ""));
            this.initScreenItem(1);
            break;
        case GuiPopupMessage.TUTORIAL_DOUBLE_JUMP:
            Application.instance.playSound("SND_UI_POPUP_GENERAL");
            this.getControl("mcGuiTextInfo").setTextLocalized("STR_HELP_PAGE_2" + (Application.instance.isMobileDevice ? "_MOBILE" : ""));
            this.initScreenItem(2);
            break;
        case GuiPopupMessage.TUTORIAL_ATTACK:
            Application.instance.playSound("SND_UI_POPUP_GENERAL");
            this.getControl("mcGuiTextInfo").setTextLocalized("STR_HELP_PAGE_3" + (Application.instance.isMobileDevice ? "_MOBILE" : ""));
            this.initScreenItem(3);
            break;
        case GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK:
            Application.instance.playSound("SND_UI_POPUP_GENERAL");
            this.getControl("mcGuiTextInfo").setTextLocalized("STR_HELP_PAGE_4" + (Application.instance.isMobileDevice ? "_MOBILE" : ""));
            this.initScreenItem(4);
            break;
        case GuiPopupMessage.MESSAGE_DESTROY_IMPERIALMACHINES:
            Application.instance.playSound("SND_UI_POPUP_EXTRACTION");
            this.getControl("mcGuiTextTitle").setTextLocalized("STR_DIALOGUE_NAME02");
            this.getControl("mcGuiTextDesc").setTextLocalized("STR_DIALOGUE_INFO03");
            break;
        case GuiPopupMessage.MESSAGE_RETURN_IMPERIALANTENNA:
            Application.instance.playSound("SND_UI_POPUP_EXTRACTION");
            this.localizedTitle("gui_localized_missionupdate", this.getControl("mcGuiTxtMissionTitle").clip, 450, 44);
            HudPlatform.instance.disableCollectibles();
            Global.game.world.oocManager.setActiveOfType(OOCManager.IMPERIAL_ANTENNA, !0);
            break;
        case GuiPopupMessage.MESSAGE_TOKEN:
            Application.instance.playSound("SND_UI_POPUP_GENERAL"), this.localizedTitle("gui_localized_tokenwon", this.getControl("mcGuiTxtPlayerName").clip,
                450, 44)
    }
};
GuiPopupMessage.prototype.initScreenItem = function(a) {
    var b = "";
    switch (PlayerSettings.instance.m_currentPlayer) {
        case PlayerSettings.TYPE_KANAN:
            b = "_kanan";
            break;
        case PlayerSettings.TYPE_SABINE:
            b = "_sabine";
            break;
        case PlayerSettings.TYPE_HERA:
            b = "_hera";
            break;
        case PlayerSettings.TYPE_ZEB:
            b = "_zeb";
            break;
        case PlayerSettings.TYPE_CHOPPER:
            b = "_chopper"
    }
    a = PoolClips.instance.getClip("gui_popups_help_image0" + a + b);
    this.getControl("mcGuiPanel_1").canvas.addChild(a)
};
GuiPopupMessage.prototype.onUIPress = function(a) {
    switch (a.name) {
        case "mcGuiButtonClose":
        case "mcGuiButtonResume":
            this.m_visibleTime = 0, this.m_isCompleted = !0, this.onResumeScreen()
    }
};
GuiPopupMessage.prototype.isTutorial = function() {
    switch (GuiPopupMessage.typeMessage) {
        case GuiPopupMessage.TUTORIAL_MOVE:
        case GuiPopupMessage.TUTORIAL_JUMP:
        case GuiPopupMessage.TUTORIAL_DOUBLE_JUMP:
        case GuiPopupMessage.TUTORIAL_ATTACK:
        case GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK:
            return !0;
        default:
            return !1
    }
};
GuiPopupMessage.prototype.onFinishScreen = function() {
    GuiPopupMessage.typeMessage = -1;
    HudPlatform.instance.enableHud(!0);
    HudPlatform.instance.setActiveAlertBackground(PlayerSettings.instance.isInLiberation);
    this.screenParent && (this.screenParent.popup === this && (this.screenParent.popup = null), this.screenParent.reminderPopup === this && (this.screenParent.reminderPopup = null));
    this.free();
    if (this.isDoingBlend) PlatformGame.instance.onEndReturnBlend();
    switch (GuiPopupMessage.typeMessage) {
        case GuiPopupMessage.TUTORIAL_DOUBLE_JUMP:
            Global.game.world.player().m_control.doDoubleJump()
    }
};
GuiPopupMessage.prototype.update = function(a) {
    !this.m_isCompleted && this.doTimer && (this.m_visibleTime += a, this.m_visibleTime >= GuiPopupMessage.MAX_TIME && (this.m_visibleTime = 0, this.m_isCompleted = !0, this.onResumeScreen()));
    this.isTutorial() && (this.tutorialTimer += a, GuiPopupMessage.typeMessage !== GuiPopupMessage.TUTORIAL_DOUBLE_JUMP && Global.game.world.player().tutorialComponent && (Global.game.world.player().update(a), Global.game.world.m_camera.update(a)));
    SScreen.prototype.update.call(this, a)
};
GuiPopupMessage.prototype.isTutorial = function() {
    return GuiPopupMessage.typeMessage === GuiPopupMessage.TUTORIAL_JUMP || GuiPopupMessage.typeMessage === GuiPopupMessage.TUTORIAL_DOUBLE_JUMP || GuiPopupMessage.typeMessage === GuiPopupMessage.TUTORIAL_ATTACK || GuiPopupMessage.typeMessage === GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK
};
GuiPopupMessage.prototype.recieveAttack = function() {};
GuiPopupMessage.prototype.onKeyDown = function(a) {
    SScreen.prototype.onKeyDown.call(this, a);
    if (!(this.tutorialTimer <= GuiPopupMessage.TUTORIAL_SHOW_TIME)) switch (GuiPopupMessage.typeMessage) {
        case GuiPopupMessage.TUTORIAL_JUMP:
        case GuiPopupMessage.TUTORIAL_DOUBLE_JUMP:
            if (a === PlayerControl.CMD_UP_A || a === PlayerControl.CMD_UP_B) Global.game.world.player().disablePlayer = !1, Global.game.world.player().onKeyDown(a), this.onResumeScreen();
            break;
        case GuiPopupMessage.TUTORIAL_ATTACK:
            if (a === PlayerPlatform.KEY_ATTACK)
                if (Global.game.world.player().disablePlayer = !1, this.onResumeScreen(), PlayerSettings.instance.isPlayerMelee()) Global.game.world.player().m_character.addState(PlayerPlatform.ST_PLAYER_PUNCH, Global.game.world.player().m_skinBase + "_attack" + PlayerPlatform.aniAttackId), Global.game.world.player().gotoState(PlayerPlatform.ST_PLAYER_PUNCH);
                else Global.game.world.player().onKeyDown(a);
            break;
        case GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK:
            a === PlayerPlatform.KEY_BOMB && (Global.game.world.player().disablePlayer = !1, Global.game.world.player().onKeyDown(a), this.onResumeScreen())
    }
};

function GuiPopupAchiev(a) {
    SScreen.call(this, a);
    this.canvas.position.y = -25;
    this.canvas.hitArea = null;
    this.m_visibleTime = 0;
    this.doTimer = this.m_isCompleted = !1
}
Application.subclass(GuiPopupAchiev, SScreen);
GuiPopupAchiev.MAX_TIME = 1E4;
GuiPopupAchiev.prototype.setAchievType = function(a) {
    this.getControl("mcGuiTextDesc").setTextLocalized("STR_TROPHIES_TROPHY_INFO0" + a);
    this.getControl("mcGuiTrophy").clip.gotoAndStop(a)
};
GuiPopupAchiev.prototype.onFinishScreen = function() {
    GuiGame.instance.achievPopup = null;
    this.free()
};
GuiPopupAchiev.prototype.onStopScreen = function() {
    this.doTimer = !0;
    SScreen.prototype.onStopScreen.call(this)
};
GuiPopupAchiev.prototype.update = function(a) {
    this.doTimer && (this.m_visibleTime += a, this.m_visibleTime >= GuiPopupAchiev.MAX_TIME && (this.m_visibleTime = 0, this.m_isCompleted = !0, this.onResumeScreen()));
    SScreen.prototype.update.call(this, a)
};

function GuiPopupTooltip(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.canvas.hitArea = null;
    this.m_visibleTime = 0;
    this.doTimer = this.m_isCompleted = !1;
    this.initData()
}
Application.subclass(GuiPopupTooltip, SScreen);
GuiPopupTooltip.MAX_TIME = 3E3;
GuiPopupTooltip.SPECIAL_ATTACK_TOOLTIP = 1;
GuiPopupTooltip.ATTACK_TOOLTIP = 2;
GuiPopupTooltip.PP_STRIKE_TOOLTIP = 10;
GuiPopupTooltip.PP_DEFLECT_TOOLTIP = 11;
GuiPopupTooltip.PP_DEATH_TROOPER_BLASTER_TOOLTIP = 12;
GuiPopupTooltip.PP_SONIC_BLASTER_TOOLTIP = 13;
GuiPopupTooltip.PP_SHIELD_TOOLTIP = 14;
GuiPopupTooltip.typeMessage = 0;
GuiPopupTooltip.prototype.initData = function() {
    Application.instance.playSound("SND_UI_POPUP_GENERAL");
    switch (GuiPopupTooltip.typeMessage) {
        case GuiPopupTooltip.SPECIAL_ATTACK_TOOLTIP:
            this.getControl("mcGuiTextInfo").setTextLocalized("STR_HELP_PAGE_4" + (Application.instance.isMobileDevice ? "_MOBILE" : ""));
            this.initScreenItem(4);
            break;
        case GuiPopupTooltip.ATTACK_TOOLTIP:
            this.getControl("mcGuiTextInfo").setTextLocalized("STR_HELP_PAGE_3" + (Application.instance.isMobileDevice ? "_MOBILE" : ""));
            this.initScreenItem(3);
            break;
        case GuiPopupTooltip.PP_STRIKE_TOOLTIP:
            this.getControl("mcGuiPowerups").setClip("gui_powerups_strikewave");
            this.getControl("mcGuiTextTitle").setTextLocalized("STR_POWERUP_NAME01");
            break;
        case GuiPopupTooltip.PP_DEFLECT_TOOLTIP:
            this.getControl("mcGuiPowerups").setClip("gui_powerups_deflect");
            this.getControl("mcGuiTextTitle").setTextLocalized("STR_POWERUP_NAME02");
            break;
        case GuiPopupTooltip.PP_DEATH_TROOPER_BLASTER_TOOLTIP:
            this.getControl("mcGuiPowerups").setClip("gui_powerups_deathtrooperblaster");
            this.getControl("mcGuiTextTitle").setTextLocalized("STR_POWERUP_NAME03");
            break;
        case GuiPopupTooltip.PP_SONIC_BLASTER_TOOLTIP:
            this.getControl("mcGuiPowerups").setClip("gui_powerups_sonicblaster");
            this.getControl("mcGuiTextTitle").setTextLocalized("STR_POWERUP_NAME04");
            break;
        case GuiPopupTooltip.PP_SHIELD_TOOLTIP:
            this.getControl("mcGuiPowerups").setClip("gui_powerups_shield"), this.getControl("mcGuiTextTitle").setTextLocalized("STR_POWERUP_NAME05")
    }
};
GuiPopupTooltip.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    this.doTimer = !0
};
GuiPopupTooltip.prototype.initScreenItem = function(a) {
    var b = "";
    switch (PlayerSettings.instance.m_currentPlayer) {
        case PlayerSettings.TYPE_KANAN:
            b = "_kanan";
            break;
        case PlayerSettings.TYPE_SABINE:
            b = "_sabine";
            break;
        case PlayerSettings.TYPE_HERA:
            b = "_hera";
            break;
        case PlayerSettings.TYPE_ZEB:
            b = "_zeb";
            break;
        case PlayerSettings.TYPE_CHOPPER:
            b = "_chopper"
    }
    a = PoolClips.instance.getClip("gui_popups_help_image0" + a + b);
    this.getControl("mcGuiPanel_1").canvas.addChild(a)
};
GuiPopupTooltip.prototype.update = function(a) {
    !this.m_isCompleted && this.doTimer && (this.m_visibleTime += a, this.m_visibleTime >= GuiPopupTooltip.MAX_TIME && (this.m_visibleTime = 0, this.m_isCompleted = !0, this.free()));
    SScreen.prototype.update.call(this, a)
};
GuiPopupTooltip.prototype.onKeyDown = function(a) {
    SScreen.prototype.onKeyDown.call(this, a);
    switch (GuiPopupTooltip.typeMessage) {
        case GuiPopupTooltip.SPECIAL_ATTACK_TOOLTIP:
            a === PlayerPlatform.KEY_BOMB && this.free();
            break;
        case GuiPopupTooltip.ATTACK_TOOLTIP:
            a === PlayerPlatform.KEY_ATTACK && this.free()
    }
};
GuiPopupTooltip.prototype.free = function() {
    this.blurBG && (this.blurContent.removeChild(this.blurBG), this.blurBG = null);
    var a = document.getElementById("MainCanvasDraw");
    a && (a.focus(), a.parentElement.focus());
    this.destroyToolTips();
    this.screenParent = null;
    for (var b in this.controls) this.controls[b].free(), this.controls[b] = null;
    this.controls = null;
    this.canvas && (Application.instance.canvas.hitArea = null, Application.instance.canvas.removeChild(this.canvas), this.canvas = null);
    document.getElementById("MainCanvasEvents") &&
        (document.getElementById("MainCanvasEvents").style.cursor = "default");
    HudPlatform.instance.tooltip = null
};

function GuiPopupVideo(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    GuiPopupVideo.instance = this;
    Application.instance.canvas.removeChild(this.canvas);
    Application.instance.renderVideoView = !0;
    Application.instance.videoRenderer.view.style.visibility = "visible";
    Application.instance.videoCanvas.addChild(this.canvas);
    this.canvas.addChild(Application.instance.addDisplayContainer());
    this.videoSprite = null;
    this.applyBlur()
}
Application.subclass(GuiPopupVideo, SScreen);
GuiPopupVideo.instance = null;
GuiPopupVideo.prototype.initVideo = function(a) {
    Application.instance.canvasEvents.addEventListener("touchend", Application.instance.videoRenderer.plugins.interaction.onTouchEnd, !0);
    Application.instance.stopAllSounds();
    this.videoSprite = a;
    var b = this.videoSprite.width / this.videoSprite.height;
    this.videoSprite.width = 1024;
    this.videoSprite.height = a.width / b;
    this.videoSprite.position.x = .5 * -a.width;
    this.videoSprite.position.y = .5 * -a.height;
    this.videoSprite.texture.baseTexture.source.play();
    this.getControl("mcGuiVideo").canvas.addChild(this.videoSprite)
};
GuiPopupVideo.prototype.onUIPress = function(a) {
    SScreen.prototype.onUIPress.call(this, a);
    this.videoSprite.texture.baseTexture.source.pause()
};
GuiPopupVideo.prototype.toggle = function(a) {
    a ? (this.videoSprite.texture.baseTexture.source.play(), this.canvas.visible = !0) : (this.videoSprite.texture.baseTexture.source.pause(), this.canvas.visible = !1)
};
GuiPopupVideo.prototype.onUIRelease = function(a) {
    switch (a.name) {
        case "mcGuiBtnClose":
            GuiPopupVideo.instance = null, this.videoSprite && (this.videoSprite.texture.baseTexture.source.currentTime = 0, this.videoSprite.texture.baseTexture.source.pause()), Application.instance.canvasEvents.addEventListener("touchend", Application.instance.renderer.plugins.interaction.onTouchEnd, !0), Application.instance.videoRenderer.view.style.visibility = "hidden", Application.instance.renderVideoView = !1, this.screenParent.showingVideo = !1, this.screenParent.dropPopup(), this.free()
    }
};

function GuiPopupLeaderboard(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.dataScreens = [];
    this.maskHeight = GuiPopupLeaderboard.BASE_MASK_HEIGHT;
    this.mask = (new window.PIXI.Graphics).beginFill(16711680).drawRect(275, 180, 465, this.maskHeight);
    this.getControl("mcGuiScores").canvas.mask = this.mask;
    this.canvas.addChild(this.mask);
    this.m_lastPointerY = 0;
    this.getControl("mcGuiBtnTime").gotoState(GuiControl.ST_SELECTED);
    GuiPopupLeaderboard.instance = this;
    this.shouldPlayMusic = this.m_waitFind = this.m_waitStop = !1
}
Application.subclass(GuiPopupLeaderboard, SScreen);
GuiPopupLeaderboard.BASE_HEIGHT_LINE = 40;
GuiPopupLeaderboard.BASE_MASK_HEIGHT = 415;
GuiPopupLeaderboard.INIT_Y_SCROLL = 225;
GuiPopupLeaderboard.INIT_X_SCROLL = 774;
GuiPopupLeaderboard.MAX_Y_SCROLL = 545;
GuiPopupLeaderboard.SCROLL_MAX_DISPLACE = 320;
GuiPopupLeaderboard.ITEMS_VIEW = 10;
GuiPopupLeaderboard.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    this.m_waitStop = !0
};
GuiPopupLeaderboard.prototype.onFindPlayer = function() {
    var a = ScoreAPI.instance.playerName;
    if ("" !== a) {
        PlatformGame.instance && PlatformGame.instance.isHighScore && (this.shouldPlayMusic = !0, PlatformGame.instance.isHighScore = !1);
        for (var b = -1, c = 0; c < this.dataScreens.length; c++) {
            var d = this.dataScreens[c],
                e = d.getControl("mcGuiTextScore_name").textfield.text;
            parseInt(d.getControl("mcGuiTextScore_numb").textfield.text, 10) === Global.data.data.lastSavedScore && e === a && (b = d.index)
        } - 1 !== b && this.scrollToPos(b + 1)
    }
};
GuiPopupLeaderboard.prototype._onGetScores = function(a) {
    GuiPopupLeaderboard.instance.onGetScores(a, !1)
};
GuiPopupLeaderboard.prototype.onGetScores = function(a, b) {
    this.getControl("mcGuiBtnScroller").canvas.position.y = GuiPopupLeaderboard.INIT_Y_SCROLL;
    this.getControl("mcGuiBtnScroller").canvas.position.x = GuiPopupLeaderboard.INIT_X_SCROLL;
    this.getControl("mcGuiScores").canvas.position.y = 0;
    for (var c = this.dataScreens.length - 1; 0 <= c; c--) this.dataScreens.splice(c, 1)[0].free();
    if (!a.error) {
        for (c = 0; c < a.results.length; c++) {
            var d = new GuiLeaderboardData("mcGuiPopupLeaderboardNames", this.dataScreens.length);
            this.getControl("mcGuiScores").canvas.addChild(d.canvas);
            d.initData(a.results[c], (c + 1).toString());
            this.dataScreens.push(d)
        }
        this.getControl("mcGuiTextScoreNum").textfield.setText({
            string: Global.data.data.myBestScore.toString(),
            color: "",
            size: 0,
            font: ""
        });
        for (c = 0; c < this.dataScreens.length; c++) this.dataScreens[c].canvas.position.y = c * GuiPopupLeaderboard.BASE_HEIGHT_LINE
    }
    this.getControl("mcGuiBtnScroller").setVisible(this.dataScreens.length > GuiPopupLeaderboard.ITEMS_VIEW);
    this.m_waitFind = !0
};
GuiPopupLeaderboard.instance = null;
GuiPopupLeaderboard.prototype.onPointerPress = function(a) {
    SScreen.prototype.onPointerPress.call(this, a);
    this.m_lastPointerY = Math.floor(Layout.fixInteractionEvent(a).data.global.y)
};
GuiPopupLeaderboard.prototype.onPointerRelease = function(a) {
    SScreen.prototype.onPointerRelease.call(this, a);
    this.scrollPressed = !1
};
GuiPopupLeaderboard.prototype.onPointerMove = function(a) {
    "mcGuiBtnScroller" === this.lastInteractionControl && (this.m_lastPointerY = Math.floor(Layout.fixInteractionEvent(a).data.global.y))
};
GuiPopupLeaderboard.prototype.update = function(a) {
    SScreen.prototype.update.call(this, a);
    this.shouldPlayMusic && (Application.instance.isPlayingSound("SND_BG_WIN") || Application.instance.isPlayingSound("SND_BG_LOSE") || Application.instance.isPlayingSound("SND_BG_SCORECARD") || Application.instance.playSound("SND_BG_SCORECARD"));
    this.m_waitFind && this.m_waitStop && (this.m_waitFind = !1, this.onFindPlayer());
    for (var b = 0; b < this.dataScreens.length; b++) this.dataScreens[b].update(a);
    this.scrollPressed && (a = this.m_lastPointerY,
        a = a < GuiPopupLeaderboard.INIT_Y_SCROLL ? GuiPopupLeaderboard.INIT_Y_SCROLL : a, a = a > GuiPopupLeaderboard.MAX_Y_SCROLL ? GuiPopupLeaderboard.MAX_Y_SCROLL : a, this.getControl("mcGuiBtnScroller").canvas.position.y = a, this.getControl("mcGuiBtnScroller").canvas.position.x = GuiPopupLeaderboard.INIT_X_SCROLL + .02 * (a - GuiPopupLeaderboard.INIT_Y_SCROLL), a = (a - GuiPopupLeaderboard.INIT_Y_SCROLL) / GuiPopupLeaderboard.SCROLL_MAX_DISPLACE, this.getControl("mcGuiScores").canvas.position.y = -a * GuiPopupLeaderboard.BASE_HEIGHT_LINE *
        (this.dataScreens.length - GuiPopupLeaderboard.ITEMS_VIEW))
};
GuiPopupLeaderboard.prototype.onUIPress = function(a) {
    SScreen.prototype.onUIPress.call(this, a);
    Application.instance.playSound("SND_UI_CLICK");
    switch (a.name) {
        case "mcGuiBtnTime":
            ScoreAPI.instance.getScores(GuiPopupLeaderboard.instance._onGetScores);
            a.gotoState(GuiControl.ST_SELECTED);
            this.getControl("mcGuiBtnToday").gotoState(GuiControl.ST_ENABLE);
            this.getControl("mcGuiBtnWeek").gotoState(GuiControl.ST_ENABLE);
            break;
        case "mcGuiBtnWeek":
            ScoreAPI.instance.getScoresThisWeek(GuiPopupLeaderboard.instance._onGetScores);
            a.gotoState(GuiControl.ST_SELECTED);
            this.getControl("mcGuiBtnToday").gotoState(GuiControl.ST_ENABLE);
            this.getControl("mcGuiBtnTime").gotoState(GuiControl.ST_ENABLE);
            break;
        case "mcGuiBtnToday":
            ScoreAPI.instance.getScoresToday(GuiPopupLeaderboard.instance._onGetScores);
            a.gotoState(GuiControl.ST_SELECTED);
            this.getControl("mcGuiBtnTime").gotoState(GuiControl.ST_ENABLE);
            this.getControl("mcGuiBtnWeek").gotoState(GuiControl.ST_ENABLE);
            break;
        case "mcGuiBtnScroller":
            this.scrollPressed = !0
    }
};
GuiPopupLeaderboard.prototype.onUIRelease = function(a) {
    switch (this.lastInteractionControl) {
        case "mcGuiBtnClose":
            PlatformGame.instance ? GuiManager.instance.gotoScreen(PlayerSettings.instance.doFinalCutscene ? GuiManager.SC_ENDGAME : GuiManager.SC_SELECT_LOCATION) : this.screenParent.dropPopup();
            break;
        case "mcGuiBtnScroller":
            this.scrollPressed = !1
    }
};
GuiPopupLeaderboard.prototype.scrollToPos = function(a) {
    if (a > GuiPopupLeaderboard.ITEMS_VIEW && this.dataScreens.length > GuiPopupLeaderboard.ITEMS_VIEW) {
        var b = (a - GuiPopupLeaderboard.ITEMS_VIEW) / (this.dataScreens.length - GuiPopupLeaderboard.ITEMS_VIEW),
            c = GuiPopupLeaderboard.INIT_Y_SCROLL + b * GuiPopupLeaderboard.SCROLL_MAX_DISPLACE;
        this.getControl("mcGuiBtnScroller").canvas.position.y = c;
        this.getControl("mcGuiBtnScroller").canvas.position.x = GuiPopupLeaderboard.INIT_X_SCROLL + .02 * (c - GuiPopupLeaderboard.INIT_Y_SCROLL);
        this.getControl("mcGuiScores").canvas.position.y = -b * GuiPopupLeaderboard.BASE_HEIGHT_LINE * (this.dataScreens.length - GuiPopupLeaderboard.ITEMS_VIEW)
    }
    this.makeFlashEffect(a - 1)
};
GuiPopupLeaderboard.prototype.makeFlashEffect = function(a) {
    this.dataScreens[a].showNameEffect(!0)
};
GuiPopupLeaderboard.prototype.free = function() {
    for (var a = 0; a < this.dataScreens.length; a++) this.dataScreens[a].free();
    SScreen.prototype.free.call(this)
};

function GuiPopupWarningLiberation(a, b) {
    SScreen.call(this, a);
    this.canvas.hitArea = null;
    this.hud = b;
    this.localizedTitle("gui_localized_title_warning", this.getControl("mcGuiTxtWarning").clip, 450, 44)
}
Application.subclass(GuiPopupWarningLiberation, SScreen);
GuiPopupWarningLiberation.MAX_TIME = 3E3;
GuiPopupWarningLiberation.prototype.onStopScreen = function() {
    SScreen.prototype.onStopScreen.call(this);
    this.hud.enableHud(!0);
    this.hud.setActiveAlertBackground(PlayerSettings.instance.isInLiberation);
    this.hud.warningPopup = null;
    this.free()
};

function GuiPopupName(a, b, c, d) {
    SScreen.call(this, a, b, c, d);
    this.mask = (new window.PIXI.Graphics).beginFill(16711680).drawRect(300, 310, 425, 125);
    this.canvas.addChild(this.mask);
    this.letters = [];
    this.initPos = [];
    this.bannedWord = "ASS CUM CNT DCK CNT FAG FCK GAY KKK PUD SEX SHT TIT XXX DIC FUC FUK GOD HOE JAP NIG CYC".split(" ");
    for (a = 0; 3 > a; a++) this.letters.push(new GuiNameLetter("mcGuiPopupEnterNameItem")), this.letters[a].canvas.position.x = this.getControl("mcGuiBtn" + (a + 1) + "Up").canvas.position.x, this.letters[a].canvas.position.y =
        .5 * (this.getControl("mcGuiBtn" + (a + 1) + "Up").canvas.position.y + this.getControl("mcGuiBtn" + (a + 1) + "Down").canvas.position.y), this.getControl("mcGuiText" + (a + 1)).canvas.addChild(this.letters[a].canvas), this.getControl("mcGuiText" + (a + 1)).canvas.mask = this.mask, this.initPos.push(.5 * (this.getControl("mcGuiBtn" + (a + 1) + "Up").canvas.position.y + this.getControl("mcGuiBtn" + (a + 1) + "Down").canvas.position.y));
    this.localizedTitle("gui_localized_name", this.getControl("mcGuiTextTitle").clip, 450, 44);
    this.isWaitingForDelay =
        this.inValidName = !1;
    this.getScoretimer = 0;
    GuiPopupName.instance = this;
    this.maxCharCode = this.baseCharCode = Application.strings.STR_LETTER_1.charCodeAt(0);
    for (a = "2";
        "undefined" !== typeof Application.strings["STR_LETTER_" + a];) this.maxCharCode++, a++;
    this.currentLetter = "" === ScoreAPI.instance.playerName ? [Global.data.data.lastName.charAt(0), Global.data.data.lastName.charAt(1), Global.data.data.lastName.charAt(2)] : [ScoreAPI.instance.playerName.charAt(0), ScoreAPI.instance.playerName.charAt(1), ScoreAPI.instance.playerName.charAt(2)];
    this.scrollLetter = [this.letters[0].canvas.position.y - GuiPopupName.SCROLL_SIZE * (this.currentLetter[0].charCodeAt(0) + 1 - this.baseCharCode), this.letters[1].canvas.position.y - GuiPopupName.SCROLL_SIZE * (this.currentLetter[1].charCodeAt(0) + 1 - this.baseCharCode), this.letters[2].canvas.position.y - GuiPopupName.SCROLL_SIZE * (this.currentLetter[2].charCodeAt(0) + 1 - this.baseCharCode)];
    this.isEnabled = !0
}
Application.subclass(GuiPopupName, SScreen);
GuiPopupName.SCROLL_SIZE = 100;
GuiPopupName.instance = null;
GuiPopupName.GETSCORE_DELAY = 250;
GuiPopupName.prototype.onUIPress = function(a) {
    switch (a.name) {
        case "mcGuiBtn1Down":
            if (0 === this.scrollLetter[0]) {
                var b = this.currentLetter[0].charCodeAt(0) + 1;
                b > this.maxCharCode ? b = this.baseCharCode : b < this.baseCharCode && (b = this.maxCharCode);
                this.currentLetter[0] = Application.strings["STR_LETTER_" + (b - (this.baseCharCode - 1))];
                b = this.letters[0].canvas.position.y;
                this.scrollLetter[0] = b - GuiPopupName.SCROLL_SIZE
            }
            break;
        case "mcGuiBtn1Up":
            0 === this.scrollLetter[0] && (b = this.currentLetter[0].charCodeAt(0) - 1, b > this.maxCharCode ?
                b = this.baseCharCode : b < this.baseCharCode && (b = this.maxCharCode), this.currentLetter[0] = Application.strings["STR_LETTER_" + (b - (this.baseCharCode - 1))], b = this.letters[0].canvas.position.y, this.scrollLetter[0] = b + GuiPopupName.SCROLL_SIZE);
            break;
        case "mcGuiBtn2Down":
            0 === this.scrollLetter[1] && (b = this.currentLetter[1].charCodeAt(0) + 1, b > this.maxCharCode ? b = this.baseCharCode : b < this.baseCharCode && (b = this.maxCharCode), this.currentLetter[1] = Application.strings["STR_LETTER_" + (b - (this.baseCharCode - 1))], b = this.letters[1].canvas.position.y,
                this.scrollLetter[1] = b - GuiPopupName.SCROLL_SIZE);
            break;
        case "mcGuiBtn2Up":
            0 === this.scrollLetter[1] && (b = this.currentLetter[1].charCodeAt(0) - 1, b > this.maxCharCode ? b = this.baseCharCode : b < this.baseCharCode && (b = this.maxCharCode), this.currentLetter[1] = Application.strings["STR_LETTER_" + (b - (this.baseCharCode - 1))], b = this.letters[1].canvas.position.y, this.scrollLetter[1] = b + GuiPopupName.SCROLL_SIZE);
            break;
        case "mcGuiBtn3Down":
            0 === this.scrollLetter[2] && (b = this.currentLetter[2].charCodeAt(0) + 1, b > this.maxCharCode ?
                b = this.baseCharCode : b < this.baseCharCode && (b = this.maxCharCode), this.currentLetter[2] = Application.strings["STR_LETTER_" + (b - (this.baseCharCode - 1))], b = this.letters[2].canvas.position.y, this.scrollLetter[2] = b - GuiPopupName.SCROLL_SIZE);
            break;
        case "mcGuiBtn3Up":
            0 === this.scrollLetter[2] && (b = this.currentLetter[2].charCodeAt(0) - 1, b > this.maxCharCode ? b = this.baseCharCode : b < this.baseCharCode && (b = this.maxCharCode), this.currentLetter[2] = Application.strings["STR_LETTER_" + (b - (this.baseCharCode - 1))], b = this.letters[2].canvas.position.y,
                this.scrollLetter[2] = b + GuiPopupName.SCROLL_SIZE);
            break;
        case "mcGuiBtnEnterName":
            if (this.inValidName) break;
            this.enableHud(!1);
            ScoreAPI.instance.playerName = this.currentLetter[0] + this.currentLetter[1] + this.currentLetter[2];
            Global.data.data.lastName = this.currentLetter[0] + this.currentLetter[1] + this.currentLetter[2];
            Global.data.data.lastSavedScore = PlatformGame.instance.currentMaxScore;
            Global.data.save();
            ScoreAPI.instance.sendScore(PlatformGame.instance.currentMaxScore, this.onSendScores)
    }
    SScreen.prototype.onUIPress.call(this,
        a)
};
GuiPopupName.prototype.enableHud = function(a) {
    this.isEnabled = a;
    for (var b in this.controls) this.getControl(b).clip ? this.getControl(b).setVisible(a) : this.getControl(b).setAlpha(a)
};
GuiPopupName.prototype.onSendScores = function() {
    GuiPopupName.instance.isWaitingForDelay = !0
};
GuiPopupName.prototype.onGetScores = function(a) {
    if (!a.error) GuiMainMenu.instance.addPopup(GuiPopupLeaderboard, "mcGuiPopupLeaderboard", 0, 0).onGetScores(a)
};
GuiPopupName.prototype.onUIRelease = function(a) {
    switch (this.lastInteractionControl) {
        case "mcGuiBtnClose":
            PlatformGame.instance ? GuiManager.instance.gotoScreen(PlayerSettings.instance.doFinalCutscene ? GuiManager.SC_ENDGAME : GuiManager.SC_SELECT_LOCATION) : this.screenParent.dropPopup()
    }
};
GuiPopupName.prototype.update = function(a) {
    Application.instance.isPlayingSound("SND_BG_WIN") || Application.instance.isPlayingSound("SND_BG_LOSE") || Application.instance.isPlayingSound("SND_BG_SCORECARD") || Application.instance.playSound("SND_BG_SCORECARD");
    this.isWaitingForDelay && (this.getScoretimer += a, this.getScoretimer >= GuiPopupName.GETSCORE_DELAY && (ScoreAPI.instance.getScoresToday(PlatformGame.instance.onGetTodayScores), this.isWaitingForDelay = !1));
    if (this.isEnabled) {
        for (var b = 0; 3 > b; b++)
            if (0 !== this.scrollLetter[b] &&
                (this.letters[b].canvas.position.y += Common.lerp(this.letters[b].canvas.position.y, this.scrollLetter[b], 15, a), 5 >= SMath.abs(this.letters[b].canvas.position.y - this.scrollLetter[b]))) {
                var c = this.currentLetter[b].charCodeAt(0) - this.baseCharCode;
                this.letters[b].canvas.position.y = this.initPos[b] - c * GuiPopupName.SCROLL_SIZE;
                this.scrollLetter[b] = 0
            }
        this.getControl("mcGuiBtnEnterName").clip.alpha = 1;
        this.getControl("mcGuiTextName").textfield.alpha = 1;
        this.inValidName = !1;
        for (b = 0; b < this.bannedWord.length; b++)
            if (this.bannedWord[b] ===
                this.currentLetter[0] + this.currentLetter[1] + this.currentLetter[2]) {
                this.getControl("mcGuiBtnEnterName").clip.alpha = .5;
                this.getControl("mcGuiTextName").textfield.alpha = .5;
                this.inValidName = !0;
                break
            }
        SScreen.prototype.update.call(this, a)
    }
};

function GuiNameLetter(a) {
    SScreen.call(this, a);
    this.canvas.hitArea = null
}
Application.subclass(GuiNameLetter, SScreen);

function GuiLeaderboardData(a, b) {
    SScreen.call(this, a);
    this.canvas.hitArea = null;
    this.showNameEffect(!1);
    this.index = b;
    this.getControl("mcGuiNameEffect").clip.onEndAnimation(this, this.onEndAnimation)
}
Application.subclass(GuiLeaderboardData, SScreen);
GuiLeaderboardData.prototype.onEndAnimation = function() {
    this.showNameEffect(!1)
};
GuiLeaderboardData.prototype.showNameEffect = function(a) {
    this.getControl("mcGuiNameEffect").setVisible(a);
    a ? (this.getControl("mcGuiNameEffect").clip.resume(), this.getControl("mcGuiTextScore_numb").textfield.setText({
        string: this.getControl("mcGuiTextScore_numb").textfield.text,
        color: "#abdffe",
        size: 0,
        font: ""
    }), this.getControl("mcGuiTextScore_name").textfield.setText({
        string: this.getControl("mcGuiTextScore_name").textfield.text,
        color: "#abdffe",
        size: 0,
        font: ""
    }), this.getControl("mcGuiTextScore_place").textfield.setText({
        string: this.getControl("mcGuiTextScore_place").textfield.text,
        color: "#abdffe",
        size: 0,
        font: ""
    })) : this.getControl("mcGuiNameEffect").clip.gotoAndStop(1)
};
GuiLeaderboardData.prototype.initData = function(a, b) {
    this.getControl("mcGuiTextScore_numb").textfield.setText({
        string: a.score_int,
        color: "",
        size: 0,
        font: ""
    });
    this.getControl("mcGuiTextScore_name").textfield.setText({
        string: a.name_str,
        color: "",
        size: 0,
        font: ""
    });
    this.getControl("mcGuiTextScore_place").textfield.setText({
        string: b,
        color: "",
        size: 0,
        font: ""
    })
};

function DataMission(a) {
    this.timerSinglePlayer = a.timerSinglePlayer;
    this.timerVersus = a.timerVersus;
    this.timerCooperative = a.timerCooperative;
    this.collectibleLimit = a.collectibleLimit;
    this.pointsObtainedPerObject = a.pointsObtainedPerObject;
    this.pointsBossDamage = a.pointsBossDamage;
    this.maxPointsTimer = a.maxPointsTimer;
    this.timeForMaxPointsSP = 1E3 * a.timeForMaxPointsSP;
    this.timeForPointsSP = 1E3 * a.timeForPointsSP;
    this.timeForMaxPointsVS = 1E3 * a.timeForMaxPointsVS;
    this.timeForPointsVS = 1E3 * a.timeForPointsVS;
    this.timeForMaxPointsCoop =
        1E3 * a.timeForMaxPointsCoop;
    this.timeForPointsCoop = 1E3 * a.timeForPointsCoop;
    this.minPointsStar1 = a.minPointsStar1;
    this.minPointsStar2 = a.minPointsStar2;
    this.minPointsStar3 = a.minPointsStar3;
    this.minPointsStar1Coop = a.minPointsStar1Coop;
    this.minPointsStar2Coop = a.minPointsStar2Coop;
    this.minPointsStar3Coop = a.minPointsStar3Coop
}

function TimerManager() {
    this.timers = []
}
TimerManager.prototype.update = function(a) {
    for (var b = this.timers.length - 1; 0 <= b; b--) {
        var c = this.timers[b];
        c.caller.isIdle || (c.caller && ("undefined" !== typeof c.caller.isAwaitingDelete && !c.caller.isAwaitingDelete || "undefined" === typeof c.caller.isAwaitingDelete) ? (c.currentTime += a, c.currentTime >= c.goalTime && (c.callback.call(c.caller, c.callbackParam), this.timers.splice(b, 1))) : this.timers.splice(b, 1))
    }
};
TimerManager.prototype.createTimer = function(a, b, c, d) {
    a = {
        goalTime: a,
        currentTime: 0,
        callback: c,
        caller: b,
        callbackParam: d
    };
    this.timers.push(a);
    return a
};
TimerManager.prototype.removeThisTimer = function(a) {
    for (var b = this.timers.length - 1; 0 <= b; b--)
        if (this.timers[b] === a) {
            this.timers.splice(b, 1);
            break
        }
};
TimerManager.prototype.removeMyTimers = function(a) {
    for (var b = this.timers.length - 1; 0 <= b; b--) this.timers[b].caller === a && this.timers.splice(b, 1)
};

function TriggerSystem(a) {
    this.m_world = a;
    this.triggers = [];
    this.bufferA = [];
    this.bufferB = [];
    this.callbacks = []
}
TriggerSystem.MAX_PLAYER_HALFWIDTH = 100;
TriggerSystem.MAX_PLAYER_HALFHEIGHT = 100;
TriggerSystem.prototype.update = function() {
    this.checkIfTriggers(this.m_world.m_player)
};
TriggerSystem.prototype.checkIfTriggers = function(a) {
    for (var b = a.m_x, c = a.m_y - TriggerSystem.MAX_PLAYER_HALFHEIGHT, d = null, e = 0, f = 0, e = null, g = this.triggers.length - 1; 0 <= g; g--)
        if (d = this.triggers[g], e = this.abs(b - d.xCenter), f = this.abs(c - d.yCenter), e <= d.xRange + TriggerSystem.MAX_PLAYER_HALFWIDTH && f <= d.yRange + TriggerSystem.MAX_PLAYER_HALFHEIGHT) {
            if (d.isActive)
                for (f = d.points.length - 1; 0 <= f; f--)
                    if (e = d.points[f], a.getBounds().contains(e.x, e.y)) {
                        d.isActive = !1;
                        this.executeTrigger(d, b, c, d.xCenter, d.yCenter);
                        0 === d.callbacks.length &&
                            this.triggers.splice(g, 1);
                        break
                    }
        } else d.isActive = !0
};
TriggerSystem.prototype.executeTrigger = function(a, b, c, d, e) {
    for (var f = a.callbacks.length - 1; 0 <= f; f--) {
        var g = a.callbacks[f];
        g.caller && g.callbackFunc.call(g.caller, {
            registeredParam: g.callbackParam,
            comesFromRight: b > d,
            comesFromAbove: c < e
        });
        !g.isOneTimeUse && g.caller || a.callbacks.splice(f, 1)
    }
};
TriggerSystem.prototype.registerCallback = function(a, b, c, d, e) {
    this.callbacks.push({
        triggerId: a,
        caller: b,
        callbackFunc: c,
        callbackParam: d,
        isOneTimeUse: e || !1
    })
};
TriggerSystem.prototype.setupTriggers = function() {
    for (var a = this.bufferA.length - 1; 0 <= a; a--)
        for (var b = this.bufferA[a], c = this.bufferB.length - 1; 0 <= c; c--) {
            var d = this.bufferB[c];
            if (b.id === d.id) {
                this.addTrigger(b, d);
                this.bufferB.splice(c, 1);
                break
            }
        }
    this.callbacks = this.bufferB = this.bufferA = null
};
TriggerSystem.prototype.addTrigger = function(a, b) {
    for (var c = b.point.x - a.point.x, d = b.point.y - a.point.y, e = Math.sqrt(c * c + d * d), f = a.point.x, g = a.point.y, c = Math.acos(c / e), c = 0 > d ? -c : c, h = 0, d = []; h < e;) d.push({
        x: f,
        y: g
    }), f += 25 * Math.cos(c), g += 25 * Math.sin(c), h += 25;
    f = [];
    for (g = this.callbacks.length - 1; 0 <= g; g--) h = this.callbacks[g], a.id === h.triggerId && (f.push(h), this.callbacks.splice(g, 1));
    e = {
        id: a.id,
        points: d,
        xCenter: (a.point.x + b.point.x) / 2,
        yCenter: (a.point.y + b.point.y) / 2,
        xRange: this.abs(Math.cos(c) * e) / 2 + 10,
        yRange: this.abs(Math.sin(c) *
            e) / 2 + 10,
        callbacks: f,
        isActive: !0
    };
    this.triggers.push(e)
};
TriggerSystem.prototype.abs = function(a) {
    return 0 > a ? -a : a
};
TriggerSystem.prototype.addToBuffer = function(a, b) {
    var c = {
        x: a.x,
        y: a.y
    };
    b ? this.bufferA.push({
        id: a.ingameId,
        point: c,
        isOneTimeUse: a.oneTimeUse
    }) : this.bufferB.push({
        id: a.ingameId,
        point: c
    })
};
TriggerSystem.prototype.removeTrigger = function(a) {
    this.triggers.splice(a, 1)
};
TriggerSystem.prototype.free = function() {
    this.callbacks = this.m_world = this.bufferB = this.bufferA = this.triggers = null
};

function TutorialComponent(a) {
    this.player = a;
    this.tutorials = [];
    this.tutorials[GuiPopupMessage.TUTORIAL_MOVE] = 0;
    this.tutorials[GuiPopupMessage.TUTORIAL_ATTACK] = 0;
    this.tutorials[GuiPopupMessage.TUTORIAL_JUMP] = 0;
    this.tutorials[GuiPopupMessage.TUTORIAL_DOUBLE_JUMP] = 0;
    this.tutorials[GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK] = 0;
    HudPlatform.instance.disableControlsForTutorial();
    this.specialEnded = this.finish = !1;
    this.waitTimer = 0;
    this.enemies = []
}
TutorialComponent.prototype.update = function(a) {
    if (!this.finish && !Global.game.isIntroBlending) {
        this.player.clipIntro || 0 !== this.tutorials[GuiPopupMessage.TUTORIAL_MOVE] || (Application.instance.isMobileDevice ? HudPlatform.instance.enableTouchControl(GuiPopupMessage.TUTORIAL_MOVE) : HudPlatform.instance.showTutorial(GuiPopupMessage.TUTORIAL_MOVE), this.tutorials[GuiPopupMessage.TUTORIAL_MOVE] = 1);
        if (1060 <= this.player.m_x && 0 === this.tutorials[GuiPopupMessage.TUTORIAL_ATTACK]) {
            this.tutorials[GuiPopupMessage.TUTORIAL_ATTACK] =
                1;
            return
        }
        1 !== this.tutorials[GuiPopupMessage.TUTORIAL_ATTACK] || this.player.m_control.isJumping() || (HudPlatform.instance.showTutorial(GuiPopupMessage.TUTORIAL_ATTACK), HudPlatform.instance.enableTouchControl(GuiPopupMessage.TUTORIAL_ATTACK), this.tutorials[GuiPopupMessage.TUTORIAL_ATTACK] = 2);
        if (2100 <= this.player.m_x && 0 === this.tutorials[GuiPopupMessage.TUTORIAL_JUMP]) {
            HudPlatform.instance.showTutorial(GuiPopupMessage.TUTORIAL_JUMP);
            HudPlatform.instance.enableTouchControl(GuiPopupMessage.TUTORIAL_JUMP);
            this.tutorials[GuiPopupMessage.TUTORIAL_JUMP] = 1;
            return
        }
        2 !== this.tutorials[GuiPopupMessage.TUTORIAL_JUMP] || 0 !== this.tutorials[GuiPopupMessage.TUTORIAL_DOUBLE_JUMP] || this.player.isJumping() || (HudPlatform.instance.showTutorial(GuiPopupMessage.TUTORIAL_DOUBLE_JUMP), HudPlatform.instance.enableTouchControl(GuiPopupMessage.TUTORIAL_DOUBLE_JUMP), this.tutorials[GuiPopupMessage.TUTORIAL_DOUBLE_JUMP] = 1);
        if (2250 <= this.player.m_x && 2800 > this.player.m_y && 0 === this.tutorials[GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK]) {
            this.player.disablePlayer = !0;
            this.player.m_control.stopMovement();
            this.tutorials[GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK] = 1;
            this.createEnemies(2250);
            return
        }
        if (2 === this.tutorials[GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK] && !this.player.m_control.isJumping()) {
            HudPlatform.instance.showTutorial(GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK);
            HudPlatform.instance.enableTouchControl(GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK);
            this.tutorials[GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK] = 2;
            this.finish = !0;
            return
        }
    }
    this.specialEnded && (this.waitTimer +=
        a, 1E3 <= this.waitTimer && (this.specialEnded = !1, this.endTutorial()));
    HudPlatform.instance.currentFinger && HudPlatform.instance.currentFinger.clip && HudPlatform.instance.currentFinger.clip.update(a)
};
TutorialComponent.prototype.createEnemies = function(a) {
    for (var b = 0; 3 > b; b++) {
        var c = new Npc;
        c.x = a - 200 + 180 * b;
        c.y = 2610 - (1 === b ? 100 : 0);
        c.limitLeft = 0;
        c.limitRight = 0;
        c.params = "";
        c = new Mandalorian(this.player.m_world.objectCanvas(), this.player.m_world, c);
        c.forceAppear();
        c.freezePos = !0;
        this.enemies.push(c);
        this.player.m_world.actorManager().add(c)
    }
    this.tutorials[GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK] = 2;
    this.enemies[this.enemies.length - 1].m_clip.onEndAnimation(this, this.setSpecialAttackTutorial)
};
TutorialComponent.prototype.setSpecialAttackTutorial = function() {
    for (var a = 0; a < this.enemies.length; a++) this.enemies[a].setState(BaseEnemy.ST_STAND, this.player.m_world.player().m_x < this.enemies[a].m_x)
};
TutorialComponent.prototype.endTutorial = function() {
    this.player.m_world.actorManager().toggleExtractionPoints(!0)
};
TutorialComponent.prototype.onEndSpecial = function() {
    if (!this.specialEnded) {
        for (var a = 0; a < this.enemies.length; a++) this.enemies[a].gotoState(BaseEnemy.ST_DIE);
        this.specialEnded = !0
    }
};
TutorialComponent.prototype.canPress = function(a) {
    switch (a) {
        case PlayerPlatform.KEY_ATTACK:
            return this.tutorials[GuiPopupMessage.TUTORIAL_ATTACK];
        case PlayerPlatform.KEY_BOMB:
            return this.tutorials[GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK]
    }
    return !0
};

function GhostingManager() {
    this.ghosting = null;
    this.ghostings = [];
    this.doReplays = this.isDisabled = !1
}
GhostingManager.instance = null;
GhostingManager.prototype.clear = function() {
    this.ghosting = null;
    this.ghostings = [];
    this.doReplays = this.isDisabled = !1
};
GhostingManager.prototype.update = function(a) {
    if (!this.isDisabled && (this.ghosting && this.ghosting.doRecord(a), this.doReplays))
        for (var b in this.ghostings) this.ghostings[b].update(a)
};
GhostingManager.prototype.startGhosting = function(a, b) {
    !PlayerSettings.instance.isMultiplayer() || MissionManager.instance.isCooperative() || MissionManager.instance.isMissionBossBattle() || (PlayerSettings.instance.isLastMultiplayerPlayer() || (this.ghosting = new BaseGhosting, this.ghosting.startRecording(a)), this.activateReplays(a.m_type, b))
};
GhostingManager.prototype.activateReplays = function(a, b) {
    for (var c in this.ghostings) b.oocManager.registerActor(this.ghostings[c], this.ghostings[c].m_occ_skin, OOCManager.GHOSTING), this.ghostings[c].startReplay(b);
    this.doReplays = !0
};
GhostingManager.prototype.stopRecording = function() {
    this.ghosting && (this.ghostings[this.ghosting.playerType] = this.ghosting, this.ghosting = null, this.doReplays = !1)
};

function WorldPlatform(a, b) {
    this.timerManager = new TimerManager;
    World.call(this, a, b);
    this.oocManager = new OOCManager(this);
    this.m_tempNpc = null
}
Application.subclass(WorldPlatform, World);
WorldPlatform.prototype.loadData = function(a, b) {
    World.prototype.loadData.call(this, a, b);
    this.createPlayer(b);
    this.m_actorManager.init(this.m_player);
    this.m_actorManager.setUpdateableObject(this.m_player);
    this.init();
    Application.externalTrack("Level Start", a)
};
WorldPlatform.prototype.createPlayer = function(a) {
    this.m_player && (this.m_player.free(), this.m_player = null);
    switch (PlayerSettings.instance.getPlayer()) {
        case PlayerSettings.TYPE_EZRA:
            this.m_player = new PlayerEzra(this.m_playerCanvas, this, this.playerInitX, this.playerInitY, a);
            break;
        case PlayerSettings.TYPE_KANAN:
            this.m_player = new PlayerKanan(this.m_playerCanvas, this, this.playerInitX, this.playerInitY, a);
            break;
        case PlayerSettings.TYPE_SABINE:
            this.m_player = new PlayerSabine(this.m_playerCanvas, this, this.playerInitX,
                this.playerInitY, a);
            break;
        case PlayerSettings.TYPE_HERA:
            this.m_player = new PlayerHera(this.m_playerCanvas, this, this.playerInitX, this.playerInitY, a);
            break;
        case PlayerSettings.TYPE_ZEB:
            this.m_player = new PlayerZeb(this.m_playerCanvas, this, this.playerInitX, this.playerInitY, a);
            break;
        case PlayerSettings.TYPE_CHOPPER:
            this.m_player = new PlayerChopper(this.m_playerCanvas, this, this.playerInitX, this.playerInitY, a);
            break;
        default:
            PlayerSettings.instance.setPlayer(PlayerSettings.TYPE_EZRA), this.m_player = new PlayerEzra(this.m_playerCanvas,
                this, this.playerInitX, this.playerInitY, a)
    }
    PlayerSettings.instance.isMultiplayer() && this.m_player.setHold(!0)
};
WorldPlatform.prototype.setPlayerInManager = function() {
    this.m_actorManager.setPlayer(this.m_player);
    this.m_actorManager.setUpdateableObject(this.m_player)
};
WorldPlatform.prototype.update = function(a) {
    PlatformGame.playerNearEnemy = 0 === this.m_actorManager.bulletManager.bullets.length;
    World.prototype.update.call(this, a);
    this.timerManager.update(a);
    this.oocManager.update(a);
    GhostingManager.instance.update(a);
    this.m_player.update(a);
    this.m_camera.update(a);
    for (var b = 0; b < this.m_actorManager.platforms.length; b++) this.m_actorManager.platforms[b].showInCamera(a);
    this.m_player.showInCamera(this.m_camera)
};
WorldPlatform.prototype.free = function() {
    Application.externalTrack("Level End");
    this.oocManager = this.timerManager = this.m_tempNpc = null;
    World.prototype.free.call(this)
};
WorldPlatform.prototype.createNpcManagers = function() {
    this.m_actorManager = new ActorManagerPlatform(this)
};
WorldPlatform.prototype.addNpc = function(a, b) {
    this.m_tempNpc = new NpcPlatform;
    this.m_tempNpc.id = a.id;
    this.m_tempNpc.sx = a.sx;
    this.m_tempNpc.sy = a.sy;
    this.m_tempNpc.x = a.x;
    this.m_tempNpc.y = a.y;
    this.m_tempNpc.rotation = 0;
    a.rot && (this.m_tempNpc.rotation = a.rot);
    this.m_tempNpc.movement = a.movement;
    this.m_tempNpc.alwaysAwake = 1 == a.alwaysAwake;
    this.m_tempNpc.params = a.params;
    this.m_tempNpc.missionType = a.missionType;
    this.m_tempNpc.gameMode = a.gameMode;
    this.m_tempNpc.limitLeft = a.limitLeft;
    this.m_tempNpc.limitRight =
        a.limitRight;
    this.m_tempNpc.useNavFloor = 1 === a.useNavFloor;
    this.m_tempNpc.lookLeft = 1 === a.lookLeft;
    this.m_tempNpc.lookDown = 1 === a.lookDown;
    this.m_tempNpc.stepOnTrigger = 1 === a.stepOnTrigger;
    this.m_tempNpc.initialDirection = a.initialDirection;
    this.m_tempNpc.vX = a.vX;
    this.m_tempNpc.type = a.type;
    this.m_tempNpc.canRespawn = 1 === a.canRespawn;
    this.m_tempNpc.autoFall = 1 === a.autoFall;
    this.m_tempNpc.respawnTime = a.respawnTime;
    this.m_tempNpc.xRangeTrigger = a.xRangeTrigger;
    this.m_tempNpc.yRangeTrigger = a.yRangeTrigger;
    this.m_tempNpc.autoFallTime =
        a.autoFallTime;
    this.m_tempNpc.vY = a.vY;
    this.m_tempNpc.aimAngleRange = a.aimAngleRange;
    this.m_tempNpc.baseAngle = a.baseAngle;
    this.m_tempNpc.weaponAngle = a.weaponAngle;
    this.m_tempNpc.useFrequency = 1 === a.useFrequency;
    this.m_tempNpc.attackDelay = a.attackDelay;
    this.m_tempNpc.turnSpeed = a.turnSpeed;
    this.m_tempNpc.aimAtPlayer = 1 === a.aimAtPlayer;
    this.m_tempNpc.bulletsInARow = a.bulletsInARow;
    this.m_tempNpc.alwaysOn = 1 === a.alwaysOn;
    this.m_tempNpc.flipRelativeX = 1 === a.flipRelativeX;
    this.m_tempNpc.turretId = a.turretId;
    this.m_tempNpc.manualBase =
        1 === a.manualBase;
    this.m_tempNpc.manualPosition = 1 === a.manualPosition;
    this.m_tempNpc.isStatic = 1 === a.isStatic;
    this.m_tempNpc.oneHitKill = 1 === a.oneHitKill;
    this.m_tempNpc.rearmDelay = a.rearmDelay;
    this.m_tempNpc.ingameId = a.ingameId;
    this.m_tempNpc.oneTimeUse = 1 === a.oneTimeUse;
    this.m_tempNpc.triggerId = a.triggerId;
    this.m_tempNpc.quantity = a.quantity;
    this.m_tempNpc.shooters = a.shooters;
    this.m_tempNpc.separation = a.separation;
    this.m_tempNpc.frecuency = a.frecuency;
    this.m_tempNpc.health = a.health;
    this.m_tempNpc.respawn =
        1 === a.respawn;
    this.m_tempNpc.idMission = a.idMission;
    this.m_tempNpc.dropArray = a.dropArray;
    this.m_tempNpc.dropChances = a.dropChances;
    this.m_tempNpc.enemiesToGenerate = a.enemiesToGenerate;
    this.m_tempNpc.playerTurn = a.playerTurn;
    this.m_tempNpc.controlId = a.controlId;
    this.m_tempNpc.skinName = a.skinName;
    this.m_tempNpc.canvas = b;
    if (this.m_tempNpc.id === ActorManagerPlatform.ENEMY_MANDALORIAN || this.m_tempNpc.id === ActorManagerPlatform.ENEMIES_GENERATOR || this.m_tempNpc.id === ActorManagerPlatform.CONQUER_BASE_VS_COOP ||
        this.m_tempNpc.id === ActorManagerPlatform.CONQUER_BASE_SP) this.m_tempNpc.rawData = a;
    this.m_actorManager.addNpc(this.m_tempNpc)
};
WorldPlatform.prototype.checkWorldBoundaries = function(a) {
    World.prototype.checkWorldBoundaries.call(this, a);
    if (!PlatformGame.instance.isIntroBlending && !this.m_player.disablePlayer) {
        var b = null,
            b = a.bounds();
        null !== b && (a.getX() - 50 < this.m_camera.m_x - this.m_camera.fixOffsetX && a.setX(this.m_camera.m_x - this.m_camera.fixOffsetX + 50), a.getX() + 50 > this.m_camera.m_x - this.m_camera.fixOffsetX + this.m_camera.fixWidthRatio && a.setX(this.m_camera.m_x - this.m_camera.fixOffsetX + this.m_camera.fixWidthRatio - 50))
    }
};

function PlatformGame(a, b, c, d) {
    SGame.call(this, a);
    this.onTransition = this.playerWin = this.isPaused = !1;
    this.shaker = new Shaker(a);
    PlatformGame.instance = this;
    this.reset = !1;
    this.world = null;
    this.isIntroBlending = this.m_collisionVisible = this.finish = !1;
    a = MissionManager.instance.getMissionId();
    this.currentMission = Settings.instance.getMission(a);
    this.m_dataWorld = c;
    this.m_dataGeneral = d;
    this.lives = 5;
    this.m_totalTimerRound = this.m_timerRound = this.score = 0;
    this.waitingForBlend = !1;
    this.waitingForBlendTimer = 0;
    this.blendIntroTarget =
        null;
    this.isHighScore = !1;
    this.onReset();
    this.basicStick = this.m_effect = null;
    Application.instance.isMobileDevice && (this.basicStick = new BasicJoystick(b, 60, 180, 600), this.basicStick.addPressListener(this, this.onPressBasic), this.basicStick.addChangeListener(this, this.onChangeBasic), this.basicStick.addReleaseListener(this, this.onReleaseBasic), this.basicStick.canvas.visible = !1);
    this.fixGameScale();
    this.spriteDisplace = null;
    Application.RENDER_MODE !== Application.RENDER_WEBGL || Application.isLowDevice || (this.spriteDisplace =
        Application.instance.getSpriteFromUrl("media/images/shader/shader.jpg"), this.spriteDisplace.pivot.x = 65, this.spriteDisplace.pivot.y = 65, this.spriteDisplaceMaxScale = 1, this.displacementFilter = new window.PIXI.filters.DisplacementFilter(this.spriteDisplace));
    this.currentMaxScore = 0;
    this.oldCameraPos = {}
}
Application.subclass(PlatformGame, SGame);
PlatformGame.WAIT_BLEND_TIME = 2E3;
PlatformGame.MAX_DELTA = 50;
PlatformGame.TIME_FOR_ALERT_BOSS = 1E4;
PlatformGame.instance = null;
PlatformGame.playerUseExpel = !1;
PlatformGame.playerNearEnemy = !1;
PlatformGame.playerCanUseForce = !0;
PlatformGame.prototype.checkMaxScores = function(a) {
    this.currentMaxScore = a;
    ScoreAPI.instance.getScoresToday(this._onGetScores)
};
PlatformGame.prototype.init = function() {
    this.hud = new HudPlatform("mcGuiHUDSingleplayer")
};
PlatformGame.prototype.createExplotionShader = function(a, b, c, d) {
    this.spriteDisplace && (this.removeExplotionShader(), this.spriteDisplaceMaxScale = c, this.spriteDisplace.scale.x = d || 1, this.spriteDisplace.scale.y = d || 1, this.spriteDisplace.position.x = a, this.spriteDisplace.position.y = b, this.canvas.addChild(this.spriteDisplace), this.canvas.filters = [this.displacementFilter])
};
PlatformGame.prototype.removeExplotionShader = function() {
    this.spriteDisplace && this.spriteDisplace.parent && this.canvas.removeChild(this.spriteDisplace);
    this.canvas.filters = null
};
PlatformGame.prototype.onShake = function(a, b, c) {
    this.shaker && (this.shaker.shake(a, b, c), this.shaker.start())
};
PlatformGame.prototype.fixGameScale = function() {
    Application.WIDE_SCREEN && this.basicStick && this.basicStick.updatePosition(.5 * Application.APP_WIDTH * (1 - Layout.aspectRatio / Layout.minAspectRatio))
};
PlatformGame.prototype.free = function() {
    Application.externalTrack("Game End");
    this.removeExplotionShader();
    this.m_dataGeneral = this.m_dataWorld = this.displacementFilter = this.spriteDisplace = null;
    this.basicStick && (this.basicStick.free(), this.basicStick = null);
    this.world && (this.world.free(), this.world = null);
    this.m_effect && (this.m_effect.free(), this.m_effect = null);
    PlatformGame.instance = null;
    SGame.prototype.free.call(this)
};
PlatformGame.prototype.timerRound = function() {
    return this.m_timerRound
};
PlatformGame.prototype.totalTimerRound = function() {
    return this.m_totalTimerRound
};
PlatformGame.prototype.timerCanBeChanged = function() {
    return -1 !== this.m_timerRound
};
PlatformGame.prototype.onPressBasic = function(a) {
    switch (a.forceX) {
        case 1:
            this.world.player().onKeyDown(PlayerControl.CMD_RIGHT_A);
            break;
        case -1:
            this.world.player().onKeyDown(PlayerControl.CMD_LEFT_A)
    }
};
PlatformGame.prototype.onReleaseBasic = function(a) {
    this.world && (this.world.player().onKeyUp(PlayerControl.CMD_RIGHT_A), this.world.player().onKeyUp(PlayerControl.CMD_LEFT_A))
};
PlatformGame.prototype.onChangeBasic = function(a) {
    switch (a.forceX) {
        case 0:
            this.world.player().onKeyUp(PlayerControl.CMD_RIGHT_A);
            this.world.player().onKeyUp(PlayerControl.CMD_LEFT_A);
            break;
        case 1:
            this.world.player().onKeyDown(PlayerControl.CMD_RIGHT_A);
            break;
        case -1:
            this.world.player().onKeyDown(PlayerControl.CMD_LEFT_A)
    }
};
PlatformGame.prototype.onPointerPress = function(a) {
    SGame.prototype.onPointerPress.call(this, a);
    if (this.basicStick) this.basicStick.onPointerPress(a)
};
PlatformGame.prototype.onPointerRelease = function(a) {
    SGame.prototype.onPointerRelease.call(this, a);
    if (this.basicStick) this.basicStick.onPointerRelease(a)
};
PlatformGame.prototype.onPointerMove = function(a) {
    SGame.prototype.onPointerMove.call(this, a);
    if (this.basicStick) this.basicStick.onPointerMove(a)
};
PlatformGame.prototype.addScore = function(a) {
    this.score += a;
    Global.totalStars = this.score;
    this.hud.setScore(this.score)
};
PlatformGame.prototype.setScore = function(a) {
    this.score = a;
    this.hud.setScore(this.score)
};
PlatformGame.prototype.addLife = function(a) {
    this.lives += a;
    if (0 > a)
        if (0 > this.lives) this.onGameEnd(!1);
        else this.reset = !0;
    else this.hud.setLives(this.lives)
};
PlatformGame.prototype.onGameEnd = function(a) {
    this.finish = !0
};
PlatformGame.prototype.onGameReset = function(a) {
    this.reset = !0
};
PlatformGame.prototype.onEndTransition = function() {
    this.hud.getControl("mcGuiTransition").setClip("mcGuiTransition_out");
    this.hud.getControl("mcGuiTransition").setVisible(!1);
    this.onTransition = !1;
    PlayerSettings.instance.isMultiplayer() || (this.world.player().setHold(!1), this.world.player().createIntro())
};
PlatformGame.prototype.onReset = function() {
    GuiGame.instance.showingAchiev = !1;
    var a = !Application.instance.isSoundOn();
    Application.instance.soundManager.m_muted = !1;
    Application.instance.stopAllSounds();
    var b = MissionManager.instance.isCooperative();
    b ? PlayerSettings.instance.isLastMultiplayerPlayer() || (PlayerSettings.instance.isInLiberation = !1, HudPlatform.instance.setActiveAlertBackground(!1), HudPlatform.instance.setActiveTimer(!0)) : (PlayerSettings.instance.isInLiberation = !1, HudPlatform.instance.setActiveAlertBackground(!1),
        HudPlatform.instance.setActiveTimer(!0));
    PlayerSettings.instance.resetTurnData(b);
    var c = b && PlayerSettings.instance.isLastMultiplayerPlayer();
    if (c) {
        var d = null;
        if (this.world) {
            switch (MissionManager.instance.getMissionType()) {
                case MissionManager.MISSION_COLLECTION:
                case MissionManager.MISSION_SABOTAGE:
                case MissionManager.MISSION_BOSS_BATTLE:
                case MissionManager.MISSION_LIBERATION:
                    d = new Vector2D(this.world.player().getX(), this.world.player().getY())
            }
            this.world.createPlayer(this.m_dataGeneral);
            this.world.setPlayerInManager();
            MissionManager.instance.isMissionBossBattle() && (Atdp.instance && Atdp.instance.updatePlayerCoop(), HeadAtat.instance && HeadAtat.instance.updatePlayerCoop(), TIEFighter.instance && TIEFighter.instance.updatePlayerCoop());
            d ? (this.world.m_camera.m_y = d.y - this.world.m_camera.downLimit, this.world.player().setPositionAndInvulnerable(d.x, d.y)) : this.setPositionPlayerPerMission();
            this.world.actorManager().respawnArrayEnemies();
            this.world.actorManager().checkDropsOnReset()
        }
        this.hud.setVisibilitySpecialReadyToUse(!0)
    } else this.world &&
        (this.world.free(), this.world = null), this.world = new WorldPlatform(this.canvas, this), this.world.loadData(this.m_dataWorld, this.m_dataGeneral), this.setPositionPlayerPerMission();
    this.world.oocManager.toggleAll(!1);
    this.world.m_actorManager.toggleExtractionPoints(!1);
    this.hud.stopTimingOut();
    this.hud.updateControls();
    this.hud.collectiblesDisabled = !1;
    this.basicStick && this.basicStick.doReleaseJoystick();
    this.setScore(Global.totalStars);
    this.world.player().setHealth(100);
    this.hud.setEnergyBar(100);
    this.hud.setSpecialBar(100, !1);
    this.hud.setLives(this.lives);
    MissionManager.instance.isMissionTutorial() ? (this.hud.enableTimer(!1), this.m_timerRound = -1) : PlayerSettings.instance.isMultiplayer() ? MissionManager.instance.isCooperative() ? this.m_timerRound = 1E3 * this.currentMission.timerCooperative : this.m_timerRound = 1E3 * this.currentMission.timerVersus : this.m_timerRound = 0;
    this.m_totalTimerRound = 0;
    this.hud.setTimer(this.m_timerRound);
    switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            this.hud.enableTextCollectiblesCoop(c);
            b ? this.hud.m_textCollectibles.setText(PlayerSettings.instance.getBothPlayersCollectedItems() + "/" + PlayerSettings.instance.getBothPlayersTotalItems()) : this.hud.m_textCollectibles.setText(PlayerSettings.instance.getCollectedItems() + "/" + PlayerSettings.instance.getTotalItems());
            break;
        case MissionManager.MISSION_LIBERATION:
            this.hud.m_textCollectibles.setText(PlayerSettings.instance.getBasesLiberated() + "/" + PlayerSettings.instance.getTotalBases());
            break;
        case MissionManager.MISSION_SABOTAGE:
            this.hud.enableTextCollectiblesCoop(c),
                b ? this.hud.m_textCollectibles.setText(PlayerSettings.instance.getBothPlayersSabotagesDone() + "/" + PlayerSettings.instance.getBothPlayersTotalSabotages()) : this.hud.m_textCollectibles.setText(PlayerSettings.instance.getSabotagesDone() + "/" + PlayerSettings.instance.getTotalSabotages())
    }
    Application.instance.soundManager.m_muted = a;
    this.hud.initData();
    PlayerSettings.instance.isMultiplayer() && (PlayerSettings.instance.isLastMultiplayerPlayer() || (MissionManager.instance.isCooperative() ? this.hud.addPopup(GuiPopupIntroVS,
        "mcGuiMessageCoopIntro") : this.hud.addPopup(GuiPopupIntroVS, "mcGuiMessageVsIntro")));
    PlayerSettings.instance.isLastMultiplayerPlayer() || (this.onTransition = !0, this.hud.getControl("mcGuiTransition").setVisible(!0), this.hud.getControl("mcGuiTransition").setClip("mcGuiTransition_wipein"), this.hud.getControl("mcGuiTransition").clip.onEndAnimation(this, this.onEndTransition), this.hud.enableHud(!1), this.world.player().setHold(!0));
    if (Application.sandbox) this.onDebugInit()
};
PlatformGame.prototype.waitForReturn = function() {
    this.waitingForBlend = !0
};
PlatformGame.prototype.onEndIntroFXCounter = function() {
    this.hud.getControl("mcGuiFxCounter2").setVisible(!1);
    this.hud.onEndCounterEffect()
};
PlatformGame.prototype.resumeIntroMission = function() {
    if (this.hud.popup) this.hud.popup.onResumeScreen()
};
PlatformGame.prototype.onEndReturnBlend = function() {
    this.world.m_camera.m_lockState = Camera.LOCK_OFF;
    this.world.player().setHold(!1);
    this.hud.enableMobileControls(!0);
    this.isIntroBlending = !1;
    this.blendIntroTarget = null;
    this.hud.getControl("mcGuiFxCounter2").setVisible(!1);
    this.hud.getControl("mcGuiFxCounter2").clip.gotoAndStop(1)
};
PlatformGame.prototype.doReturnBlend = function() {
    this.waitingForBlendTimer = 0;
    this.waitingForBlend = !1;
    this.world.m_camera.doBlendWithPos(this.oldCameraPos.x + (-this.world.m_camera.fixOffsetX + .5 * this.world.m_camera.fixWidthRatio), this.oldCameraPos.y + .5 * this.world.m_camera.m_height, 0, 0, 3, !0, this, this.resumeIntroMission, null)
};
PlatformGame.prototype.doIntroBlend = function() {
    this.oldCameraPos = {
        x: this.world.m_camera.m_x,
        y: this.world.m_camera.m_y
    };
    this.world.m_camera.m_lockState = Camera.LOCK_ON;
    this.isIntroBlending = !0;
    MissionManager.instance.isMissionTutorial() ? this.blendIntroTarget = this.world.m_actorManager.extractionPoints[0] : MissionManager.instance.isMissionSabotage() ? MissionManager.instance.isCooperative() ? PlayerSettings.instance.hasSabotagedAll() && PlayerSettings.instance.hasSabotagedAllCoop() ? this.blendIntroTarget = this.world.m_actorManager.m_antenna :
        this.setBlendTarget() : PlayerSettings.instance.hasSabotagedAll() ? this.blendIntroTarget = this.world.m_actorManager.m_antenna : this.setBlendTarget() : this.setBlendTarget();
    if (this.blendIntroTarget) this.world.m_camera.doBlendWithPos(this.blendIntroTarget.m_x, this.blendIntroTarget.m_y, 0, -150, 3, !0, this, this.waitForReturn, null), MissionManager.instance.isMissionBossBattle() || MissionManager.instance.isMissionTutorial() || this.blendIntroTarget === this.world.m_actorManager.extractionPoints[0] || this.blendIntroTarget ===
        this.world.m_actorManager.m_antenna || (this.hud.getControl("mcGuiFxCounter2").setClip("gui_hud_supplies_fx"), this.hud.getControl("mcGuiFxCounter2").clip.scale.x = .5, this.hud.getControl("mcGuiFxCounter2").clip.scale.y = .5, this.hud.getControl("mcGuiFxCounter2").setVisible(!0), this.hud.getControl("mcGuiFxCounter2").clip.resume());
    else this.onEndReturnBlend()
};
PlatformGame.prototype.setBlendTarget = function() {
    for (var a = 99999999, b = 0; b < this.world.m_actorManager.m_actors.length; b++) {
        var c = this.world.m_actorManager.m_actors[b];
        if ("undefined" !== typeof c.isMissionObjective && ("undefined" !== typeof c.m_created && c.m_created || "undefined" === typeof c.m_created) && c.m_type !== ImperialMachine.TYPE_ANTENNA && !c.hasBeenCollected) {
            var d = c.m_x - this.world.m_player.m_x,
                e = c.m_y - this.world.m_player.m_y,
                d = Math.sqrt(d * d + e * e);
            a > d && (this.blendIntroTarget = c, a = d)
        }
    }
};
PlatformGame.prototype.setCameraPosition = function() {
    this.world.player().setHold(!0);
    this.world.m_camera.m_lockState = Camera.LOCK_ON;
    this.setBlendTarget();
    this.world.m_camera.m_x = this.blendIntroTarget.m_x - (-this.world.m_camera.fixOffsetX + .5 * this.world.m_camera.fixWidthRatio);
    this.world.m_camera.m_y = this.blendIntroTarget.m_y - .5 * this.world.m_camera.m_height - 100;
    this.waitingForBlend = !0
};
PlatformGame.prototype.setPositionPlayerPerMission = function() {
    var a = null;
    switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_TUTORIAL:
        case MissionManager.MISSION_COLLECTION:
            a = this.world.actorManager().getPositionPlayerCollection(PlayerSettings.instance.getCurrentTurn());
            break;
        case MissionManager.MISSION_LIBERATION:
            a = this.world.actorManager().getPositionPlayerLiberation();
            break;
        case MissionManager.MISSION_SABOTAGE:
            a = this.world.actorManager().getPositionPlayerSabotage(PlayerSettings.instance.getCurrentTurn())
    }
    null !==
        a && (a.y = this.world.getFloorCollision(a.x, a.y).y, this.world.player().setPosition(a.x, a.y))
};
PlatformGame.prototype.onEndLock = function() {
    this.world.m_camera.m_lockState = Camera.LOCK_OFF;
    if (this.hud.popup) this.hud.popup.onResumeScreen();
    this.world.player().setHold(!1);
    this.world.player().createIntro()
};
PlatformGame.prototype.update = function(a) {
    if (Application.instance.updateable)
        if (PlatformGame.playerCanUseForce = !0, this.reset) Application.isLowDevice && (this.hud.onEndTrans(this, this.onReset), this.hud.doTransition(!0), this.reset = !1);
        else if (this.finish) GuiGame.instance && GuiGame.instance.removeGame();
    else {
        if (Application.instance.isSoundOn() && !this.world.player().finishedPlaying) switch (MissionManager.instance.getMissionType()) {
            case MissionManager.MISSION_COLLECTION:
                Application.instance.isPlayingSound("SND_BG_GAME") ||
                    Application.instance.playSound("SND_BG_GAME");
                break;
            case MissionManager.MISSION_LIBERATION:
                PlayerSettings.instance && (PlayerSettings.instance.isInLiberation ? Application.instance.isPlayingSound("SND_BG_LIBERATION_WAVE") || Application.instance.playSound("SND_BG_LIBERATION_WAVE") : Application.instance.isPlayingSound("SND_BG_LIBERATION") || Application.instance.playSound("SND_BG_LIBERATION"));
                break;
            case MissionManager.MISSION_SABOTAGE:
                Application.instance.isPlayingSound("SND_BG_SABOTAGE") || Application.instance.playSound("SND_BG_SABOTAGE");
                break;
            case MissionManager.MISSION_BOSS_BATTLE:
                Application.instance.isPlayingSound("SND_BG_SND_BG_BOSSGAME") || Application.instance.playSound("SND_BG_BOSS");
                break;
            case MissionManager.MISSION_TUTORIAL:
                Application.instance.isPlayingSound("SND_BG_TUTORIAL") || Application.instance.playSound("SND_BG_TUTORIAL")
        }
        this.waitingForBlend && (this.waitingForBlendTimer += a, this.waitingForBlendTimer >= PlatformGame.WAIT_BLEND_TIME && this.doReturnBlend());
        this.world && (this.m_effect && this.m_effect.update(a), a > PlatformGame.MAX_DELTA &&
            (a = PlatformGame.MAX_DELTA), this.shaker && this.shaker.update(a), this.spriteDisplace && this.spriteDisplace.parent && (this.spriteDisplace.rotation += .1, this.spriteDisplace.scale.x += .05 * a, this.spriteDisplace.scale.y += .05 * a, this.spriteDisplace.scale.x > this.spriteDisplaceMaxScale && this.removeExplotionShader()), this.world.player().isPlaying && (PlayerSettings.instance.isInLiberation || (this.m_totalTimerRound += a), MissionManager.instance.isSinglePlayer() ? MissionManager.instance.isMissionTutorial() || (this.m_timerRound +=
                a) : 0 < this.m_timerRound && (Atdp.instance && Atdp.instance.m_state !== Atdp.ST_DIE || !Atdp.instance) && (HeadAtat.instance && HeadAtat.instance.m_state !== HeadAtat.ST_DEFEAT || !HeadAtat.instance) && (TIEFighter.instance && TIEFighter.instance.m_state !== TIEFighter.ST_DIE || !TIEFighter.instance) && (this.world.player().isAwaitingLose || this.world.player().isAwaitingWin || (MissionManager.instance.isMissionLiberation() ? PlayerSettings.instance.isInLiberation || (this.m_timerRound -= a) : this.m_timerRound -= a), 0 >= this.m_timerRound ?
                (this.m_timerRound = 0, this.world.player().lose(!0)) : this.m_timerRound <= Application.config.settings.timeRunningOut && !this.hud.isTimingOut && this.hud.startTimingOut())), this.hud.isTimingOut && this.hud.doTimerScaleLerp(a), PlayerSettings.instance.isInLiberation || (PlayerSettings.instance.isMultiplayer() ? this.hud.setTimer(this.m_timerRound) : this.hud.setTimer(this.m_totalTimerRound)), SGame.prototype.update.call(this, a), this.world && this.world.update(a))
    }
};
PlatformGame.prototype.onKeyDown = function(a) {
    SGame.prototype.onKeyDown.call(this, a);
    this.world.player().onKeyDown(a)
};
PlatformGame.prototype.onKeyUp = function(a) {
    SGame.prototype.onKeyUp.call(this, a);
    this.world.player().onKeyUp(a)
};
PlatformGame.prototype.toggleDebugCollision = function() {
    SGame.prototype.toggleDebugCollision.call(this);
    this.m_collisionVisible = !this.m_collisionVisible;
    this.world.showCollision(this.m_collisionVisible)
};
PlatformGame.prototype.onDebugDraw = function(a) {
    SGame.prototype.onDebugDraw.call(this, a);
    if (this.showDebugCollision) this.world.onDebugDraw(a)
};
PlatformGame.prototype.onDebugInit = function() {
    Application.sandbox.clearGameSettings();
    Application.sandbox.addGameSettings(this.world.player().control(), "m_jumpSpeed", -2, .1, .001);
    Application.sandbox.addGameSettings(this.world.player().control(), "m_doubleJumpSpeed", -2, 0, .001);
    Application.sandbox.addGameSettings(this.world.player().control(), "maxSpeedAir", 0, 1, .001);
    Application.sandbox.addGameSettings(this.world.player(), "m_impulseJetpack", -10, 0, .01)
};
PlatformGame.prototype.onDebugCreateObject = function(a, b, c) {
    Application.log("[PLATFORM]" + c)
};
PlatformGame.prototype.onGetScores = function(a) {
    if (!a.error) GuiGame.instance.addPopup(GuiPopupLeaderboard, "mcGuiPopupLeaderboard", 0, 0).onGetScores(a)
};
PlatformGame.prototype.onGetTodayScores = function(a) {
    if (a.error) GuiManager.instance.gotoScreen(PlayerSettings.instance.doFinalCutscene ? GuiManager.SC_ENDGAME : GuiManager.SC_SELECT_LOCATION);
    else {
        var b = GuiGame.instance.addPopup(GuiPopupLeaderboard, "mcGuiPopupLeaderboard", 0, 0);
        b.onGetScores(a, !0);
        b.getControl("mcGuiBtnToday").gotoState(GuiControl.ST_SELECTED);
        b.getControl("mcGuiBtnTime").gotoState(GuiControl.ST_ENABLE);
        b.getControl("mcGuiBtnWeek").gotoState(GuiControl.ST_ENABLE)
    }
};
PlatformGame.prototype._onGetScores = function(a) {
    if (a.error) PlatformGame.instance.isHighScore = !1, GuiManager.instance.gotoScreen(PlayerSettings.instance.doFinalCutscene ? GuiManager.SC_ENDGAME : GuiManager.SC_SELECT_LOCATION);
    else {
        var b = a.results.length + 1 < ScoreAPI.instance.resultsPerPage;
        if (!b)
            for (var c = 0; c < a.results.length; c++)
                if (parseInt(a.results[c].score_int, 10) < PlatformGame.instance.currentMaxScore) {
                    b = !0;
                    break
                }
        PlatformGame.instance.isHighScore = b
    }
};
PlatformGame.prototype.onSendScores = function() {
    ScoreAPI.instance.getScores(PlatformGame.instance.onGetScores)
};

function NpcPlatform() {
    Npc.call(this);
    this.ePattern = "";
    this.eSquashFactor = 0;
    this.eDetectFloor = !1;
    this.movement = this.eBodyEnabled = "";
    this.alwaysAwake = !1;
    this.rotation = 0;
    this.gameMode = this.missionType = "";
    this.health = this.frecuency = this.separation = this.shooters = this.quantity = 0;
    this.respawn = !1;
    this.limitRight = this.limitLeft = 0;
    this.autoFall = this.canRespawn = this.lookDown = this.lookLeft = this.useNavFloor = !1;
    this.vY = this.autoFallTime = this.yRangeTrigger = this.xRangeTrigger = this.respawnTime = 0;
    this.oneHitKill =
        this.isStatic = !1;
    this.vX = this.initialDirection = this.rearmDelay = 0;
    this.aimAtPlayer = this.stepOnTrigger = !1;
    this.bulletsInARow = 0;
    this.alwaysOn = !1;
    this.weaponAngle = 0;
    this.attackDelay = this.useFrequency = !1;
    this.baseAngle = this.aimAngleRange = this.turnSpeed = 0;
    this.flipRelativeX = !1;
    this.turretId = "";
    this.manualBase = this.manualPosition = !1;
    this.triggerId = this.ingameId = "";
    this.oneTimeUse = !1;
    this.idMission = 1;
    this.dropChances = this.dropArray = "";
    this.type = 0;
    this.enemiesToGenerate = "";
    this.playerTurn = 1;
    this.skinName =
        this.controlId = "";
    this.rawData = null
}
Application.subclass(NpcPlatform, Npc);

function PoolClips() {
    this.clips = {}
}
PoolClips.instance = null;
PoolClips.initialize = function() {
    PoolClips.instance = new PoolClips
};
PoolClips.prototype.fill = function(a, b) {
    this.clips[a] = [];
    for (var c = 0; c < b; c++) this.clips[a].push(Application.instance.getClip(a))
};
PoolClips.prototype.getClip = function(a) {
    return this.clips[a] && 0 < this.clips[a].length ? (a = this.clips[a].splice(0, 1)[0], a.setFrame && (a.m_stopped = !1, a.setFrame(0)), a.setTint && 16777215 != a.tint && a.setTint(16777215), a.visible = !0, a.alpha = 1, a) : Application.instance.getClip(a)
};
PoolClips.prototype.releaseClip = function(a) {
    if (a) {
        this.clips[a.name] || (this.clips[a.name] = []);
        a.parent && a.parent.removeChild(a);
        if (a.onEndAnimation) a.onEndAnimation(null, null);
        this.clips[a.name].push(a)
    }
};
PoolClips.prototype.stats = function() {
    Application.log("----- CLIPS POOL STATS ------");
    for (var a in this.clips) Application.log("PoolClips [" + a + "] instances " + this.clips[a].length);
    Application.log("----------------------------")
};
PoolClips.prototype.clear = function() {
    for (var a in this.clips) {
        for (var b = 0; b < this.clips[a].length; b++) this.clips[a][b].free();
        this.clips[a] = null
    }
    this.clips = {}
};

function SimpleCharacter(a, b, c) {
    this.canvas = c;
    this.x = a || 0;
    this.y = b || 0;
    this.clip = null;
    this.states = [];
    this.state = this.animation = "";
    this.m_endAniFunction = this.m_endAniCaller = null;
    this.lastFrame = 0;
    this.functions = []
}
SimpleCharacter.prototype.free = function() {
    PoolClips.instance.releaseClip(this.clip);
    this.states = this.canvas = this.clip = null
};
SimpleCharacter.prototype.onEndAnimation = function(a, b) {
    this.m_endAniCaller = a;
    this.m_endAniFunction = b
};
SimpleCharacter.prototype._endAnimation = function(a) {
    null !== this.m_endAniCaller && null !== this.m_endAniFunction && this.m_endAniFunction.call(this.m_endAniCaller, this.state)
};
SimpleCharacter.prototype.setPosition = function(a, b) {
    this.x = a;
    this.y = b;
    this.clip && (this.clip.position.x = this.x, this.clip.position.y = this.y)
};
SimpleCharacter.prototype.addState = function(a, b, c) {
    this.states[a] = b;
    c = "undefined" !== typeof c ? c : [];
    for (var d in this.functions) - 1 != d.indexOf(a + "_") && delete this.functions[d];
    for (b = 0; b < c.length; b++) this.functions[a + "_" + c[b].frame] = c[b]
};
SimpleCharacter.prototype.gotoState = function(a, b) {
    b = "undefined" !== typeof b ? b : !0;
    this.states[a] ? (this.state = a, this.clip && (PoolClips.instance.releaseClip(this.clip), this.clip = null), this.clip = PoolClips.instance.getClip(this.states[a]), this.clip.position.x = this.x, this.clip.position.y = this.y, this.clip.onEndAnimation(this, this._endAnimation), this.clip.loop = b, this.animation = this.states[a], this.canvas.addChild(this.clip)) : Application.error("SimpleCharacter::gotoState() - State: [" + a + "] is not registered")
};
SimpleCharacter.prototype.update = function(a) {
    this.clip && (this.clip.update(a), this.lastFrame !== this.clip.currentFrame && (this.lastFrame = this.clip.currentFrame, this.functions[this.state + "_" + this.clip.currentFrame] && (a = this.functions[this.state + "_" + this.clip.currentFrame], a.callback.call(a.caller))))
};

function ActorManagerPlatform(a) {
    this.triggerSystem = new TriggerSystem(a);
    NpcManager.call(this, a);
    this.bulletManager = new BulletManager(a, 40);
    a = MissionManager.instance.getMissionId();
    a = Settings.instance.getMission(a);
    this.platforms = [];
    this.collectiblesLimit = a.collectibleLimit;
    this.m_positionsCollectibles = [];
    this.m_positionsCollectibles2 = [];
    this.m_positionsSabotageCoop = [];
    this.extractionPoints = [];
    this.drops = [];
    this.respawnEnemies = [];
    this.unitsToBeFliped = [];
    this.m_itemsCooperative = [];
    this.m_sabotagesCooperative = [];
    this.conquerBases = [];
    this.m_antenna = null;
    this.m_timerRespawn = 0;
    this.m_waitTimeRespawn = 2E3;
    this.m_player1InCollection = new Vector2D(0, 0);
    this.m_player2InCollection = new Vector2D(0, 0);
    this.m_playerInLiberation = new Vector2D(0, 0);
    this.m_player1InSabotage = new Vector2D(0, 0);
    this.m_player2InSabotage = new Vector2D(0, 0);
    this.tokens = []
}
Application.subclass(ActorManagerPlatform, NpcManager);
ActorManagerPlatform.ITEM_MOBILE_PLATFORM = 1;
ActorManagerPlatform.ITEM_COLLECTIBLE = 2;
ActorManagerPlatform.ITEM_COLLECTIBLE_2 = 8;
ActorManagerPlatform.ITEM_COLLECTIBLE_SP = 9;
ActorManagerPlatform.ITEM_HEALTH = 3;
ActorManagerPlatform.ITEM_ENEMY = 4;
ActorManagerPlatform.ITEM_SPRING = 5;
ActorManagerPlatform.ITEM_TELEPORTER = 6;
ActorManagerPlatform.ITEM_EXTRACTION_POINT = 7;
ActorManagerPlatform.ITEM_BREAKABLE = 10;
ActorManagerPlatform.ITEM_PIVOT = 20;
ActorManagerPlatform.ENEMY_STORMTROOPER = 11;
ActorManagerPlatform.ENEMY_SHOCKTROOPER = 12;
ActorManagerPlatform.ENEMY_EWEBREPEATER = 13;
ActorManagerPlatform.ENEMY_MANDALORIAN = 14;
ActorManagerPlatform.ENEMY_SENTINELDROID = 15;
ActorManagerPlatform.ENEMY_TROOPERS = 16;
ActorManagerPlatform.HAZARD_LANDMINE = 21;
ActorManagerPlatform.HAZARD_FALLINGROCK = 22;
ActorManagerPlatform.HAZARD_GROUNDSAW = 23;
ActorManagerPlatform.HAZARD_TURRET = 24;
ActorManagerPlatform.HAZARD_SPIKE = 25;
ActorManagerPlatform.TRIGGER_A = 26;
ActorManagerPlatform.TRIGGER_B = 27;
ActorManagerPlatform.HAZARD_LASER = 28;
ActorManagerPlatform.HAZARD_TURRET_TARGET = 29;
ActorManagerPlatform.HAZARD_MOVABLE_SPIKE = 32;
ActorManagerPlatform.BOSS_ATDP = 201;
ActorManagerPlatform.BOSS_ATAT = 202;
ActorManagerPlatform.BOSS_TIE_FIGHTER = 203;
ActorManagerPlatform.PLAYER_POSITION = 33;
ActorManagerPlatform.OBJECT_WALL = 34;
ActorManagerPlatform.OBJECT_WALL2 = 35;
ActorManagerPlatform.ITEM_SHIELD = 41;
ActorManagerPlatform.ITEM_PU_STRIKEWAVE = 42;
ActorManagerPlatform.ITEM_PU_PERFECTDEFLECT = 43;
ActorManagerPlatform.ITEM_PU_MULTIBLASTER = 44;
ActorManagerPlatform.ITEM_PU_EXPLOSIVEBLASTER = 45;
ActorManagerPlatform.ENEMIES_GENERATOR = 100;
ActorManagerPlatform.CONQUER_BASE_SP = 105;
ActorManagerPlatform.CONQUER_BASE_VS_COOP = 101;
ActorManagerPlatform.IMPERIAL_MACHINE = 102;
ActorManagerPlatform.IMPERIAL_MACHINE_COOP = 103;
ActorManagerPlatform.IMPERIAL_MACHINE_SP = 104;
ActorManagerPlatform.IMPERIAL_ANTENNA_COOP = 106;
ActorManagerPlatform.IMPERIAL_ANTENNA_SP = 107;
ActorManagerPlatform.ENVIRONMENT_ELEMENT = 501;
ActorManagerPlatform.LANDMARK = 502;
ActorManagerPlatform.TOKEN = 999;
ActorManagerPlatform.prototype.update = function(a) {
    NpcManager.prototype.update.call(this, a);
    this.bulletManager.update(a);
    this.triggerSystem.update();
    0 < this.m_timerRespawn && (this.m_timerRespawn -= a, 0 >= this.m_timerRespawn && (this.m_timerRespawn = 0, this.respawnArrayEnemies()))
};
ActorManagerPlatform.prototype.getEnemyInPosition = function(a, b) {
    for (var c = 0; c < this.m_actors.length; c++) {
        var d = this.m_actors[c];
        if (d.isEnemy && !d.isIdle && d.m_clip && 0 === d.m_clip.rotation) {
            var e = d.m_clip.getCollision("mcCollision");
            if (e && (new Rectangle(e.x + d.m_x, e.y + d.m_y, e.w, e.h)).contains(a, b)) return d
        }
    }
    return null
};
ActorManagerPlatform.prototype.getEnemyOnCollisionAttack = function() {
    if (this.m_world.m_player.getCollision("mcGunCollision"))
        for (var a = 0; a < this.m_actors.length; a++) {
            var b = this.m_actors[a];
            if (b.isEnemy && !b.isIdle && b.m_clip) {
                if (b.m_state === BaseEnemy.ST_HIT && 0 !== b.m_clip.currentFrame % BaseEnemy.FRAME_CAN_HIT) break;
                if (SDisplayObjectContainer.hitTestByBounds(b.m_clip, b.m_clip.getCollision(SimpleWorldActor.COLLISION), this.m_world.m_player.m_clip, this.m_world.m_player.m_clip.getCollision("mcGunCollision"))) return b
            }
        }
    return null
};
ActorManagerPlatform.prototype.checkDropsOnReset = function() {
    for (var a = 0; a < this.drops.length - 1; a++) PlayerSettings.instance.isPlayerMelee() && this.drops[a].data.use === ItemWorld.USE_RANGE && (this.drops[a].isAwaitingDelete = !0), PlayerSettings.instance.isPlayerRange() && this.drops[a].data.use === ItemWorld.USE_MEELE && (this.drops[a].isAwaitingDelete = !0)
};
ActorManagerPlatform.prototype.setTimerRespawnArrayEnemies = function() {};
ActorManagerPlatform.prototype.respawnArrayEnemies = function() {
    for (var a = this.respawnEnemies.length - 1; 0 <= a; a--) this.respawnEnemy(this.respawnEnemies[a])
};
ActorManagerPlatform.prototype.respawnEnemy = function(a) {
    if (a.actor)
        if (a.data.id !== ActorManagerPlatform.ENEMY_TROOPERS) a.actor.isAwaitingDelete = !0;
        else
            for (var b = 0; b < a.actor.troopers.length; b++) a.actor.troopers[b].isAwaitingDelete = !0;
    switch (a.data.id) {
        case ActorManagerPlatform.ENEMY_TROOPERS:
            var c = new DumbTrooperController(this.m_world, a.data);
            this.add(c);
            break;
        case ActorManagerPlatform.ENEMY_STORMTROOPER:
            c = new Stormtrooper(this.m_world.objectCanvas(), this.m_world, a.data, "Stormtrooper", !1);
            this.add(c);
            break;
        case ActorManagerPlatform.ENEMY_SHOCKTROOPER:
            c = new Stormtrooper(this.m_world.objectCanvas(), this.m_world, a.data, "Shocktrooper", !1);
            this.add(c);
            break;
        case ActorManagerPlatform.ENEMY_EWEBREPEATER:
            c = new EWebRepeaterBlaster(this.m_world.objectCanvas(), this.m_world, a.data, !1);
            this.add(c);
            break;
        case ActorManagerPlatform.ENEMY_SENTINELDROID:
            c = new SentinelDroid(this.m_world.objectCanvas(), this.m_world, a.data, !1);
            this.add(c);
            break;
        case ActorManagerPlatform.ENEMY_MANDALORIAN:
            c = new Mandalorian(this.m_world.objectCanvas(),
                this.m_world, a.data);
            this.add(c);
            break;
        case ActorManagerPlatform.HAZARD_LANDMINE:
            c = new Landmine(this.m_world.objectCanvas(), this.m_world, a.data);
            this.add(c);
            break;
        case ActorManagerPlatform.HAZARD_FALLINGROCK:
            c = new FallingRock(this.m_world.objectCanvas(), this.m_world, a.data);
            this.add(c);
            break;
        case ActorManagerPlatform.HAZARD_GROUNDSAW:
            c = new GroundSaw(this.m_world.objectCanvas(), this.m_world, a.data);
            this.add(c);
            break;
        case ActorManagerPlatform.HAZARD_TURRET:
            c = new Turret(this.m_world.objectCanvas(), this.m_world,
                a.data, this.m_buffer);
            this.add(c);
            break;
        case ActorManagerPlatform.ITEM_BREAKABLE:
            c = new Breakable(this.m_world.objectCanvas(), this.m_world, a.data), this.add(c)
    }
    a.actor = c
};
ActorManagerPlatform.prototype.addDrop = function(a, b, c) {
    a = new ItemWorld(this.m_world, a, b, c);
    this.drops.push(a);
    this.add(a)
};
ActorManagerPlatform.prototype.createDumbTroopers = function(a, b, c, d, e, f) {
    c = this.m_world.getFloorCollision(b, c);
    for (var g = 0, h = 0, h = null, g = 0; g < e; g++) h = c.y + Common.randomInt(1, 20) - 10, h = new DumbTrooper(this.m_world.objectCanvas(), this.m_world, b, h, d), this.add(h), a && a.troopers.push(h), b += Common.randomInt(f - 10, f + 10)
};
ActorManagerPlatform.prototype.isValidMission = function(a) {
    if (MissionManager.instance.isMissionTutorial() || a.id === ActorManagerPlatform.PLAYER_POSITION || a.id === ActorManagerPlatform.ITEM_EXTRACTION_POINT) return !0;
    if ("undefined" !== typeof a.missionType) {
        for (var b = a.missionType.split(";"), c = 0; c < b.length; c++) {
            var d = parseInt(b[c], 10);
            if (d === MissionManager.MISSION_NONE)
                if (a.id === ActorManagerPlatform.OBJECT_WALL || a.id === ActorManagerPlatform.OBJECT_WALL2) {
                    if (PlayerSettings.instance.isMultiplayer()) return !0;
                    break
                } else return !0;
            if (PlayerSettings.instance.isMultiplayer()) {
                if (d === MissionManager.instance.getMissionType()) return !0
            } else if (d === MissionManager.GAME_SINGLEPLAYER) return !0
        }
        return !1
    }
    return !0
};
ActorManagerPlatform.prototype.preInit = function() {
    for (var a = 0; a < this.m_buffer.length;) {
        switch (this.m_buffer[a].id) {
            case ActorManagerPlatform.ITEM_EXTRACTION_POINT:
                if (this.isValidMission(this.m_buffer[a])) {
                    var b = new ExtractionPoint(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a].x, this.m_buffer[a].y, this.m_buffer[a].playerTurn, this.m_buffer[a].params);
                    this.extractionPoints.push(b);
                    this.add(b)
                }
                break;
            case ActorManagerPlatform.CONQUER_BASE_SP:
                MissionManager.instance.isMissionLiberation() && MissionManager.instance.isSinglePlayer() &&
                    (b = new ConquerBase(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a], this.m_buffer), this.conquerBases.push(b), this.add(b));
                break;
            case ActorManagerPlatform.CONQUER_BASE_VS_COOP:
                b = !1;
                if ("undefined" !== typeof this.m_buffer[a].gameMode)
                    for (var c = this.m_buffer[a].gameMode.split(";"), d = 0; d < c.length; d++) switch (parseInt(c[d], 10)) {
                        case 1:
                            MissionManager.instance.isCooperative() && (b = !0);
                            break;
                        case 2:
                            MissionManager.instance.isVersus() && (b = !0)
                    }
                MissionManager.instance.isMissionLiberation() && !MissionManager.instance.isSinglePlayer() &&
                    b && (b = new ConquerBase(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a], this.m_buffer), this.conquerBases.push(b), this.add(b));
                break;
            case ActorManagerPlatform.ENVIRONMENT_ELEMENT:
                Application.isLowDevice || (b = new EnvironmentActor(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a], this.m_enviromentAnimations.length), this.m_enviromentAnimations.push(b));
                break;
            case ActorManagerPlatform.LANDMARK:
                b = new Landmark(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a]), this.m_landmarks.push(b)
        }
        a++
    }
};
ActorManagerPlatform.prototype.init = function(a) {
    this.preInit();
    this.m_player = a;
    for (a = 0; a < this.m_buffer.length;) {
        if (this.isValidMission(this.m_buffer[a])) switch (this.m_buffer[a].id) {
            case ActorManagerPlatform.ENEMY_TROOPERS:
                var b = new DumbTrooperController(this.m_world, this.m_buffer[a]);
                this.respawnEnemies.push({
                    actor: b,
                    data: this.m_buffer[a]
                });
                this.add(b);
                break;
            case ActorManagerPlatform.ITEM_COLLECTIBLE:
                MissionManager.instance.isSinglePlayer() || (b = new Vector2D(this.m_buffer[a].x, this.m_buffer[a].y),
                    this.m_positionsCollectibles.push(b));
                break;
            case ActorManagerPlatform.ITEM_COLLECTIBLE_2:
                MissionManager.instance.isSinglePlayer() || (b = new Vector2D(this.m_buffer[a].x, this.m_buffer[a].y), this.m_positionsCollectibles2.push(b));
                break;
            case ActorManagerPlatform.ITEM_COLLECTIBLE_SP:
                MissionManager.instance.isSinglePlayer() && (b = new Vector2D(this.m_buffer[a].x, this.m_buffer[a].y), this.m_positionsCollectibles.push(b));
                break;
            case ActorManagerPlatform.ITEM_HEALTH:
                this.add(new ItemWorld(this.m_world, this.m_buffer[a].x,
                    this.m_buffer[a].y, ItemWorld.TYPE_HEALTH));
                break;
            case ActorManagerPlatform.ITEM_MOBILE_PLATFORM:
                b = new MobilePlatform(this.m_world.objectCanvas(), this.m_world, "platform" + (this.m_buffer[a].type || 0), this.m_buffer[a], new DataMovement(this.m_buffer[a].params, this.m_buffer[a].movement));
                this.platforms.push(b);
                this.add(b);
                break;
            case ActorManagerPlatform.ENEMY_STORMTROOPER:
                b = new Stormtrooper(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a], "Stormtrooper", !1);
                this.respawnEnemies.push({
                    actor: b,
                    data: this.m_buffer[a]
                });
                this.add(b);
                break;
            case ActorManagerPlatform.ENEMY_SHOCKTROOPER:
                b = new Stormtrooper(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a], "Shocktrooper", !1);
                this.respawnEnemies.push({
                    actor: b,
                    data: this.m_buffer[a]
                });
                this.add(b);
                break;
            case ActorManagerPlatform.ENEMY_EWEBREPEATER:
                b = new EWebRepeaterBlaster(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a], !1);
                this.respawnEnemies.push({
                    actor: b,
                    data: this.m_buffer[a]
                });
                this.add(b);
                break;
            case ActorManagerPlatform.ENEMY_SENTINELDROID:
                b = new SentinelDroid(this.m_world.objectCanvas(),
                    this.m_world, this.m_buffer[a], !1);
                this.respawnEnemies.push({
                    actor: b,
                    data: this.m_buffer[a]
                });
                this.add(b);
                break;
            case ActorManagerPlatform.HAZARD_LANDMINE:
                b = new Landmine(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a]);
                this.respawnEnemies.push({
                    actor: b,
                    data: this.m_buffer[a]
                });
                this.add(b);
                break;
            case ActorManagerPlatform.HAZARD_FALLINGROCK:
                b = new FallingRock(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a]);
                this.respawnEnemies.push({
                    actor: b,
                    data: this.m_buffer[a]
                });
                this.add(b);
                break;
            case ActorManagerPlatform.HAZARD_GROUNDSAW:
                b =
                    new GroundSaw(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a]);
                this.respawnEnemies.push({
                    actor: b,
                    data: this.m_buffer[a]
                });
                this.add(b);
                break;
            case ActorManagerPlatform.HAZARD_TURRET:
                b = new Turret(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a], this.m_buffer);
                this.respawnEnemies.push({
                    actor: b,
                    data: this.m_buffer[a]
                });
                this.add(b);
                break;
            case ActorManagerPlatform.HAZARD_SPIKE:
                this.add(new Spike(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a], !1));
                break;
            case ActorManagerPlatform.HAZARD_MOVABLE_SPIKE:
                this.add(new Spike(this.m_world.objectCanvas(),
                    this.m_world, this.m_buffer[a], !0));
                break;
            case ActorManagerPlatform.HAZARD_LASER:
                b = new LaserHazard(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a]);
                this.add(b);
                break;
            case ActorManagerPlatform.TRIGGER_A:
                this.triggerSystem.addToBuffer(this.m_buffer[a], !0);
                break;
            case ActorManagerPlatform.TRIGGER_B:
                this.triggerSystem.addToBuffer(this.m_buffer[a], !1);
                break;
            case ActorManagerPlatform.ITEM_SPRING:
                this.add(new Spring(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a].x, this.m_buffer[a].y, this.m_buffer[a].rotation,
                    this.m_buffer[a].params, 1));
                break;
            case ActorManagerPlatform.ITEM_TELEPORTER:
                this.add(new Teleporter(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a].x, this.m_buffer[a].y, this.m_buffer[a].params));
                break;
            case ActorManagerPlatform.IMPERIAL_MACHINE:
                MissionManager.instance.isMissionSabotage() && !MissionManager.instance.isSinglePlayer() && this.add(new ImperialMachine(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a].x, this.m_buffer[a].y, ImperialMachine.TYPE_NORMAL));
                break;
            case ActorManagerPlatform.IMPERIAL_MACHINE_COOP:
                MissionManager.instance.isMissionSabotage() &&
                    !MissionManager.instance.isSinglePlayer() && (b = new Vector2D(this.m_buffer[a].x, this.m_buffer[a].y), this.m_positionsSabotageCoop.push(b));
                break;
            case ActorManagerPlatform.IMPERIAL_MACHINE_SP:
                MissionManager.instance.isMissionSabotage() && MissionManager.instance.isSinglePlayer() && this.add(new ImperialMachine(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a].x, this.m_buffer[a].y, ImperialMachine.TYPE_NORMAL));
                break;
            case ActorManagerPlatform.IMPERIAL_ANTENNA_COOP:
                MissionManager.instance.isMissionSabotage() &&
                    PlayerSettings.instance.isMultiplayer() && (this.m_antenna = new ImperialMachine(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a].x, this.m_buffer[a].y, ImperialMachine.TYPE_ANTENNA), this.add(this.m_antenna));
                break;
            case ActorManagerPlatform.IMPERIAL_ANTENNA_SP:
                MissionManager.instance.isMissionSabotage() && MissionManager.instance.isSinglePlayer() && (this.m_antenna = new ImperialMachine(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a].x, this.m_buffer[a].y, ImperialMachine.TYPE_ANTENNA), this.add(this.m_antenna));
                break;
            case ActorManagerPlatform.ENEMY_MANDALORIAN:
                b = new Mandalorian(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a]);
                this.respawnEnemies.push({
                    actor: b,
                    data: this.m_buffer[a]
                });
                this.add(b);
                break;
            case ActorManagerPlatform.ENEMIES_GENERATOR:
                this.add(new Generator(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a]));
                break;
            case ActorManagerPlatform.BOSS_ATDP:
                this.add(new Atdp(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a]));
                break;
            case ActorManagerPlatform.BOSS_ATAT:
                this.add(new HeadAtat(this.m_world.objectCanvas(),
                    this.m_world, this.m_buffer[a]));
                break;
            case ActorManagerPlatform.BOSS_TIE_FIGHTER:
                this.add(new TIEFighter(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a]));
                break;
            case ActorManagerPlatform.ITEM_SHIELD:
                this.add(new ItemWorld(this.m_world, this.m_buffer[a].x, this.m_buffer[a].y, ItemWorld.TYPE_SHIELD));
                break;
            case ActorManagerPlatform.ITEM_PU_STRIKEWAVE:
                this.add(new ItemWorld(this.m_world, this.m_buffer[a].x, this.m_buffer[a].y, ItemWorld.TYPE_PU_STRIKEWAVE));
                break;
            case ActorManagerPlatform.ITEM_PU_PERFECTDEFLECT:
                this.add(new ItemWorld(this.m_world,
                    this.m_buffer[a].x, this.m_buffer[a].y, ItemWorld.TYPE_PU_PERFECTDEFLECT));
                break;
            case ActorManagerPlatform.ITEM_PU_MULTIBLASTER:
                this.add(new ItemWorld(this.m_world, this.m_buffer[a].x, this.m_buffer[a].y, ItemWorld.TYPE_PU_MULTIBLASTER));
                break;
            case ActorManagerPlatform.ITEM_PU_EXPLOSIVEBLASTER:
                this.add(new ItemWorld(this.m_world, this.m_buffer[a].x, this.m_buffer[a].y, ItemWorld.TYPE_PU_EXPLOSIVEBLASTER));
                break;
            case ActorManagerPlatform.ITEM_BREAKABLE:
                b = new Breakable(this.m_world.objectCanvas(), this.m_world,
                    this.m_buffer[a]);
                this.respawnEnemies.push({
                    actor: b,
                    data: this.m_buffer[a]
                });
                this.add(b);
                break;
            case ActorManagerPlatform.PLAYER_POSITION:
                switch (this.m_buffer[a].idMission) {
                    case 1:
                        if ("undefined" !== typeof this.m_buffer[a].playerTurn) switch (this.m_buffer[a].playerTurn) {
                            case 1:
                                this.m_player1InCollection.x = this.m_buffer[a].x;
                                this.m_player1InCollection.y = this.m_buffer[a].y;
                                break;
                            case 2:
                                this.m_player2InCollection.x = this.m_buffer[a].x, this.m_player2InCollection.y = this.m_buffer[a].y
                        } else this.m_player1InCollection.x =
                            this.m_buffer[a].x, this.m_player1InCollection.y = this.m_buffer[a].y, this.m_player2InCollection.x = this.m_buffer[a].x, this.m_player2InCollection.y = this.m_buffer[a].y;
                        break;
                    case 2:
                        this.m_playerInLiberation.x = this.m_buffer[a].x;
                        this.m_playerInLiberation.y = this.m_buffer[a].y;
                        break;
                    case 3:
                        if ("undefined" !== typeof this.m_buffer[a].playerTurn) switch (this.m_buffer[a].playerTurn) {
                            case 1:
                                this.m_player1InSabotage.x = this.m_buffer[a].x;
                                this.m_player1InSabotage.y = this.m_buffer[a].y;
                                break;
                            case 2:
                                this.m_player2InSabotage.x =
                                    this.m_buffer[a].x, this.m_player2InSabotage.y = this.m_buffer[a].y
                        } else this.m_player1InSabotage.x = this.m_buffer[a].x, this.m_player1InSabotage.y = this.m_buffer[a].y, this.m_player2InSabotage.x = this.m_buffer[a].x, this.m_player2InSabotage.y = this.m_buffer[a].y
                }
                break;
            case ActorManagerPlatform.OBJECT_WALL:
            case ActorManagerPlatform.OBJECT_WALL2:
                b = this.m_buffer[a].id === ActorManagerPlatform.OBJECT_WALL ? Wall.TYPE_WALL1 : Wall.TYPE_WALL2;
                this.add(new Wall(this.m_world.objectCanvas(), this.m_world, this.m_buffer[a].x,
                    this.m_buffer[a].y, this.m_buffer[a].params, b));
                break;
            case ActorManagerPlatform.TOKEN:
                this.tokens.push(this.m_buffer[a])
        }
        a++
    }
    switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            this.createCollectibles();
            MissionManager.instance.isCooperative() && (this.createCollectiblesCoop(), this.enableCooperativeItems());
            break;
        case MissionManager.MISSION_SABOTAGE:
            MissionManager.instance.isCooperative() && (this.createSabotageCoop(), this.enableCooperativeMachine())
    }
    a = window.config.settings.overrideSpawnTokens;
    Global.data.data.shouldSpawnTokens && !a && this.createToken();
    this.triggerSystem.setupTriggers()
};
ActorManagerPlatform.prototype.createToken = function() {
    if (0 < this.tokens.length) {
        var a = Common.randomInt(0, this.tokens.length - 1);
        this.add(new Token(this.m_world.objectCanvas(), this.m_world, this.tokens[a]));
        this.tokens = null
    }
};
ActorManagerPlatform.prototype.getPositionPlayerCollection = function(a) {
    return this.m_player1InCollection
};
ActorManagerPlatform.prototype.getPositionPlayerLiberation = function() {
    return this.m_playerInLiberation
};
ActorManagerPlatform.prototype.getPositionPlayerSabotage = function(a) {
    return this.m_player1InSabotage
};
ActorManagerPlatform.prototype.checkPlayerExtraction = function(a) {
    for (var b = 0; b < this.extractionPoints.length; b++)
        if ("undefined" !== typeof this.extractionPoints[b].playerTurn && this.extractionPoints[b].playerTurn === a) return !0;
    return !1
};
ActorManagerPlatform.prototype.toggleExtractionPoints = function(a) {
    if (PlayerSettings.instance.isMultiplayer()) {
        this.checkPlayerExtraction(2);
        this.checkPlayerExtraction(1);
        for (var b = 0; b < this.extractionPoints.length; b++)
            if (a || !a) this.extractionPoints[b].gotoState(a ? ExtractionPoint.ST_EXTRACTION : ExtractionPoint.ST_STAND), (this.extractionPoints[b].showOOC = a) ? (this.extractionPoints[b].signalContainer = this.extractionPoints[b].m_clip.arrowPos, this.extractionPoints[b].signalContainer.addChild(this.extractionPoints[b].signalClip)) :
                this.extractionPoints[b].signalContainer && this.extractionPoints[b].signalContainer.removeChild(this.extractionPoints[b].signalClip), this.extractionPoints[b].ooc.m_actor.showOOC = a, (this.extractionPoints[b].ooc.isActive = a) && this.extractionPoints[b].ooc.calculatePos()
    } else
        for (b = 0; b < this.extractionPoints.length; b++) this.extractionPoints[b].gotoState(a ? ExtractionPoint.ST_EXTRACTION : ExtractionPoint.ST_STAND), (this.extractionPoints[b].showOOC = a) ? (this.extractionPoints[b].signalContainer = this.extractionPoints[b].m_clip.arrowPos,
            this.extractionPoints[b].signalContainer.addChild(this.extractionPoints[b].signalClip)) : this.extractionPoints[b].signalContainer && this.extractionPoints[b].signalContainer.removeChild(this.extractionPoints[b].signalClip)
};
ActorManagerPlatform.prototype.createCollectibles = function() {
    if (!PlayerSettings.instance.isLastMultiplayerPlayer()) {
        var a = ~~(2 * Math.random());
        PlayerSettings.instance.m_collectSkin = Application.config.missions[4 * (Global.level - 1)].skinIds[2 === a ? 1 : a]
    }
    for (var a = [], b = 0; b < this.m_positionsCollectibles.length; b++) a.push(b);
    Common.shuffleArray(a);
    for (var c = this.m_positionsCollectibles.length < this.collectiblesLimit ? this.m_positionsCollectibles.length : this.collectiblesLimit, d = -1, b = 0; b < c; b++) d = a[b], this.add(new Item(this.m_world.objectCanvas(),
        this.m_world, this.m_positionsCollectibles[d].x, this.m_positionsCollectibles[d].y, Item.TYPE_COLLECTIBLE))
};
ActorManagerPlatform.prototype.createCollectiblesCoop = function() {
    for (var a = [], b = 0; b < this.m_positionsCollectibles2.length; b++) a.push(b);
    Common.shuffleArray(a);
    for (var c = this.m_positionsCollectibles2.length < this.collectiblesLimit ? this.m_positionsCollectibles2.length : this.collectiblesLimit, d = -1, b = 0; b < c; b++) d = a[b], d = new Item(this.m_world.objectCanvas(), this.m_world, this.m_positionsCollectibles2[d].x, this.m_positionsCollectibles2[d].y, Item.TYPE_COLLECTIBLE_COOP), this.add(d), this.m_itemsCooperative.push(d)
};
ActorManagerPlatform.prototype.enableCooperativeItems = function() {
    for (var a = 0; a < this.m_itemsCooperative.length; a++) this.m_itemsCooperative[a].doStand()
};
ActorManagerPlatform.prototype.createSabotageCoop = function() {
    for (var a = this.m_positionsSabotageCoop.length, b = 0; b < a; b++) {
        var c = new ImperialMachine(this.m_world.objectCanvas(), this.m_world, this.m_positionsSabotageCoop[b].x, this.m_positionsSabotageCoop[b].y, ImperialMachine.TYPE_COOPERATIVE);
        this.add(c);
        this.m_sabotagesCooperative.push(c)
    }
};
ActorManagerPlatform.prototype.enableCooperativeMachine = function() {
    for (var a = 0; a < this.m_sabotagesCooperative.length; a++) this.m_sabotagesCooperative[a].doStand()
};
ActorManagerPlatform.prototype.updateAntenna = function() {
    this.m_antenna ? this.m_antenna.setAntennaVulnerable() : (GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_RETURN_EXTRACTION, HudPlatform.instance.addPopup(GuiPopupMessage, "mcGuiMessageMissionUpdate"), Global.game.world.actorManager().toggleExtractionPoints(!0))
};
ActorManagerPlatform.prototype.createEnemies = function(a, b, c) {
    var d = new NpcPlatform;
    d.x = a + (.5 < Math.random() ? -1 : 1) * Math.random() * c;
    d.y = b - 20;
    d.limitLeft = 200;
    d.limitRight = 200;
    d.params = "";
    this.add(new SentinelDroid(this.m_world.objectCanvas(), this.m_world, d, !1));
    for (d = 0; 4 > d; d++) {
        var e = new NpcPlatform;
        e.x = a + (.5 < Math.random() ? -1 : 1) * Math.random() * c;
        e.y = b - 20;
        e.limitLeft = 200;
        e.limitRight = 200;
        e.params = "";
        this.add(new Mandalorian(this.m_world.objectCanvas(), this.m_world, e))
    }
};
ActorManagerPlatform.prototype.free = function() {
    this.m_antenna = this.m_sabotagesCooperative = this.m_itemsCooperative = this.m_positionsCollectibles2 = this.m_positionsCollectibles = null;
    NpcManager.prototype.free.call(this);
    this.respawnEnemies = null
};

function ExtractionPoint(a, b, c, d, e, f) {
    SimpleWorldActor.call(this, a, b, c, d);
    this.playerTurn = e;
    this.clipName = "mcObj_extractionPoint";
    this.showOOC = !1;
    this.m_character = new SimpleCharacter(0, 0, this.m_canvas);
    this.m_character.addState(ExtractionPoint.ST_STAND, this.clipName + "_stand");
    this.m_character.addState(ExtractionPoint.ST_EXTRACTION, this.clipName + "_extraction");
    this.signalContainer = null;
    this.signalClip = PoolClips.instance.getClip(this.clipName + "_arrow");
    this.gotoState(ExtractionPoint.ST_STAND);
    this.ooc =
        b.oocManager.registerActor(this, "gui_hud_pointer_extraction", OOCManager.EXTRACTION_POINT)
}
Application.subclass(ExtractionPoint, SimpleWorldActor);
ExtractionPoint.ST_STAND = "st1";
ExtractionPoint.ST_EXTRACTION = "st2";
ExtractionPoint.SIGNAL_DISTANCE = 150;
ExtractionPoint.prototype.update = function(a) {
    SimpleWorldActor.prototype.update.call(this, a);
    switch (this.m_state) {
        case ExtractionPoint.ST_EXTRACTION:
            if (this.signalClip.visible = !this.playerCloseToExtraction(), !this.signalClip.visible && this.m_clip.hitTest(this.m_world.m_player.m_clip)) {
                if (HudPlatform.instance.popup && "GuiPopupMessage" === HudPlatform.instance.popup.className) HudPlatform.instance.popup.onResumeScreen();
                this.m_world.m_player.onWin(!1);
                MissionManager.instance.isMissionTutorial() && (PlayerSettings.instance.setUsedCharacter(this.m_world.m_player.m_type -
                    1), Global.data.data.tutorial = 1, PlayerSettings.instance.specialTooltipshown = !0, Global.data.save())
            }
    }
};
ExtractionPoint.prototype.playerCloseToExtraction = function() {
    var a = this.m_world.m_player.m_y > this.m_y ? this.m_world.m_player.m_y - this.m_y : this.m_y - this.m_world.m_player.m_y;
    return (this.m_world.m_player.m_x > this.m_x ? this.m_world.m_player.m_x - this.m_x : this.m_x - this.m_world.m_player.m_x) <= ExtractionPoint.SIGNAL_DISTANCE && a <= ExtractionPoint.SIGNAL_DISTANCE
};
ExtractionPoint.prototype.toggleExtraction = function(a) {
    a ? (this.gotoState(ExtractionPoint.ST_EXTRACTION), this.signalContainer = this.m_clip.arrowPos, this.signalContainer.addChild(this.signalClip), this.showOOC = !0) : (this.signalContainer.removeChild(this.signalClip), this.gotoState(ExtractionPoint.ST_STAND), this.showOOC = !1)
};

function Teleporter(a, b, c, d, e) {
    this.m_params = null;
    this.m_targetY = this.m_targetX = 0;
    this.m_currentPlayerCollision = this.m_prePlayerCollision = !1;
    WorldActor.call(this, a, b, c, d);
    this.m_clip = Application.instance.getClip("mcItemDoorWarp");
    a.addChild(this.m_clip);
    this.m_clip.position.x = c;
    this.m_clip.position.y = d;
    this.m_params = Common.getParams(e);
    this.m_targetX = parseInt(this.m_params.targetX, 10);
    this.m_targetY = parseInt(this.m_params.targetY, 10);
    this.setFlipX(1 === parseInt(this.m_params.flip, 10));
    this.updateBounds()
}
Application.subclass(Teleporter, WorldActor);
Teleporter.prototype.teleportPlayer = function(a) {
    a.setPosition(this.m_targetX, this.m_targetY)
};
Teleporter.prototype.update = function(a) {
    var b = this.m_world.player();
    this.m_prePlayerCollision = this.m_currentPlayerCollision;
    !b.isDead() && b.hitTest(this) ? this.m_currentPlayerCollision = b.isReadyToTeleport = !0 : (this.m_currentPlayerCollision = !1, this.m_prePlayerCollision && (b.isReadyToTeleport = !1));
    this.m_currentPlayerCollision && !b.isDead() && b.doTeleport && (this.teleportPlayer(b), b.doTeleport = !1);
    WorldActor.prototype.update.call(this, a)
};

function ConquerBase(a, b, c, d) {
    PlayerSettings.instance.liberationState = ConquerBase.ST_CONQUER_NONE;
    c.y = b.getFloorCollision(c.x, c.y).y;
    this.m_npc = c;
    this.playerIsCaged = this.m_currentPlayerCollision = this.m_prePlayerCollision = !1;
    this.fixedCameraPoint = null;
    this.isMissionObjective = this.isActive = !0;
    this.m_type = c.rawData.gameMode ? c.rawData.gameMode : ConquerBase.TYPE_NORMAL;
    SimpleWorldActor.call(this, a, b, c.x, c.y);
    this.isRangeControlled = !1;
    this.originPoints = [
        [this.m_x - 180, this.m_y],
        [this.m_x, this.m_y],
        [this.m_x +
            180, this.m_y
        ]
    ];
    this.waveDoors = [];
    for (d = 0; 3 > d; d++) {
        var e = new WaveDoor(this.originPoints[d][0], this.originPoints[d][1], a, this);
        this.waveDoors.push(e);
        MissionManager.instance.isCooperative() || e.gotoState(WaveDoor.ST_STAND)
    }
    this.m_conquerState = ConquerBase.ST_CONQUER_NONE;
    PlayerSettings.instance.addBasesRemaining(1);
    this.m_config = window.liberation;
    this.m_idGroupOfWaves = c.rawData.idGroupOfWaves ? c.rawData.idGroupOfWaves : 0;
    this.m_idCurrentWave = this.m_totalWaves = this.m_totalEnemies = 0;
    this.m_currentWave = null;
    a = this.m_config.liberation_groups_waves[this.m_idGroupOfWaves];
    this.m_totalWaves = a.idWaves.length;
    for (d = 0; d < this.m_totalWaves; d++)
        for (c = a.idWaves[d], e = 0; e < c.length; e++) this.m_totalEnemies += this.m_config.liberation_waves[c[e]].idEnemies.length;
    this.hasBeenCollected = !1;
    this.m_interval = null;
    this.showOOC = !1;
    b.oocManager.registerActor(this, "gui_hud_pointer_door", ActorManagerPlatform.CONQUER_BASE_SP)
}
Application.subclass(ConquerBase, SimpleWorldActor);
ConquerBase.TYPE_COOPERATIVE = 1;
ConquerBase.TYPE_NORMAL = 2;
ConquerBase.ST_CONQUER_NONE = 0;
ConquerBase.ST_CONQUER_PROGRESS = 1;
ConquerBase.ST_CONQUER_DONE = 2;
ConquerBase.ST_BLENDING_TO_BASE = 3;
ConquerBase.prototype.getFixedCameraPoint = function(a) {
    for (var b = 0; b < a.length; b++)
        if (a[b].controlId === this.m_npc.controlId) return a[b];
    return null
};
ConquerBase.prototype.update = function(a) {
    for (var b = 0; 3 > b; b++) this.waveDoors[b].update(a);
    if (this.isActive) switch (this.playerIsCaged && (this.m_world.m_player.getX() - 25 < this.m_x - 550 && this.m_world.m_player.setX(this.m_x - 550 + 25), this.m_world.m_player.getX() + 25 > this.m_x + 550 && this.m_world.m_player.setX(this.m_x + 550 - 25)), this.m_conquerState) {
        case ConquerBase.ST_CONQUER_NONE:
            this.playerDetected() && (this.m_world.m_camera.stopBlending(), this.startWaves());
            break;
        case ConquerBase.ST_CONQUER_PROGRESS:
            this.m_interval &&
                this.m_interval.update(a)
    }
    SimpleWorldActor.prototype.update.call(this, a)
};
ConquerBase.prototype.startWaves = function() {
    this.m_conquerState = ConquerBase.ST_BLENDING_TO_BASE;
    HudPlatform.instance.activateWarningMessage();
    this.fixedCameraPoint ? this.m_world.m_camera.doBlendWithPos(this.fixedCameraPoint.x, this.fixedCameraPoint.y, 0, 0, 2, !0, this, this.onEndLock, !0) : this.m_world.m_camera.doBlendWithPos(this.m_x, this.m_y, 0, -150, 2, !0, this, this.onEndLock, !0);
    this.m_world.oocManager.toggleAll(!1);
    this.playerIsCaged = !0;
    PlayerSettings.instance.isInLiberation = !0;
    HudPlatform.instance.setActiveTimer(!1);
    HudPlatform.instance.reminderPopup && (HudPlatform.instance.reminderPopup.free(), HudPlatform.instance.reminderPopup = null);
    var a = !Application.instance.isSoundOn();
    Application.instance.soundManager.m_muted = !1;
    Application.instance.stopSound("SND_BG_LIBERATION");
    Application.instance.soundManager.m_muted = a
};
ConquerBase.prototype.playerDetected = function() {
    if (this.m_conquerState === ConquerBase.ST_CONQUER_NONE && !PlayerSettings.instance.isInLiberation) {
        var a = this.m_x - this.m_world.m_player.m_x,
            b = this.m_y - 125 - this.m_world.m_player.m_y;
        if (350 >= (0 > a ? -a : a) && 130 >= (0 > b ? -b : b)) return !0
    }
    return !1
};
ConquerBase.prototype.onEndLock = function(a) {
    a ? (this.playerIsCaged = !1, this.m_world.m_camera.m_lockState = Camera.LOCK_ON, this.m_conquerState = ConquerBase.ST_CONQUER_PROGRESS, PlayerSettings.instance.liberationState = ConquerBase.ST_CONQUER_PROGRESS, this.m_world.oocManager.setActiveOfType(ActorManagerPlatform.CONQUER_BASE_SP, !1), this.m_currentWave = new Wave(this.m_config.liberation_waves, this.m_config.liberation_groups_waves[this.m_idGroupOfWaves].idWaves[0], this), this.waveDoors[0].m_timer = 0, this.waveDoors[1].m_timer =
        0, this.waveDoors[2].m_timer = 0) : (PlayerSettings.instance.liberationState = ConquerBase.ST_CONQUER_DONE, this.m_world.m_camera.m_lockState = Camera.LOCK_OFF)
};
ConquerBase.prototype.nextWave = function() {
    this.m_idCurrentWave++;
    this.m_currentWave = null;
    if (this.m_idCurrentWave >= this.m_totalWaves) this.onConqueredBase();
    else this.m_interval && this.m_interval.free(), this.m_interval = null, this.m_interval = new SInterval(this, "onEndInterval", this.m_config.liberation_groups_waves[this.m_idGroupOfWaves].delay)
};
ConquerBase.prototype.onEndInterval = function() {
    this.m_interval && this.m_interval.free();
    this.m_interval = null;
    this.m_currentWave = new Wave(this.m_config.liberation_waves, this.m_config.liberation_groups_waves[this.m_idGroupOfWaves].idWaves[this.m_idCurrentWave], this);
    this.waveDoors[0].startTimer();
    this.waveDoors[1].startTimer();
    this.waveDoors[2].startTimer()
};
ConquerBase.prototype.onConqueredBase = function() {
    if (this.m_conquerState !== ConquerBase.ST_CONQUER_DONE) {
        this.m_conquerState = ConquerBase.ST_CONQUER_DONE;
        this.hasBeenCollected = !0;
        for (var a = 0; 3 > a; a++) {
            this.waveDoors[a].gotoState(WaveDoor.ST_BREAK);
            this.m_world.createEffect("aniFxEnemyExplote", this.waveDoors[a].m_x, this.waveDoors[a].m_y - 60);
            var b = new Hostage(this.m_world.objectCanvas(), this.m_world, this.waveDoors[a].m_x, this.waveDoors[a].m_y);
            this.m_world.actorManager().add(b)
        }
        HudPlatform.instance.setActiveAlertBackground(!1);
        PlayerSettings.instance.doLiberation(1);
        HudPlatform.instance.codedByAnimationCollectibles(PlayerSettings.instance.getBasesLiberated(), PlayerSettings.instance.getTotalBases());
        a = !Application.instance.isSoundOn();
        Application.instance.soundManager.m_muted = !1;
        Application.instance.soundManager.m_muted = a;
        Global.game.world.oocManager.removeThisActor(this);
        this.m_world.m_player.resetMissionActionTimer();
        a = Application.config.settings["minQuantityToShowHintsPlanet" + Global.level];
        PlayerSettings.instance.getBasesLiberated() >=
            a && (this.m_world.m_player.missionActionTimer = 0);
        this.m_world.m_camera.doBlendWithTarget(Global.game.world.m_player, 60, -150, 8, !0, this, this.onEndLock, !1);
        PlayerSettings.instance.isInLiberation = !1;
        HudPlatform.instance.setActiveTimer(!0);
        if (PlayerSettings.instance.hasLiberatedAll()) this.onAllConquered();
        Application.instance.stopSound("SND_BG_LIBERATION_WAVE")
    }
};
ConquerBase.prototype.onAllConquered = function() {};
ConquerBase.prototype.free = function() {
    SimpleWorldActor.prototype.free.call(this)
};
ConquerBase.prototype.onDebugDraw = function(a) {
    ContextGraphics.drawRectangle(a, this.m_x - 325 - this.m_world.m_camera.m_x, this.m_y - 250 - this.m_world.m_camera.m_y, 700, 250, 1, Common.COLOR_YELLOW, Common.COLOR_NONE)
};

function Wave(a, b, c) {
    this.m_data = a;
    this.m_id = b;
    this.m_base = c;
    this.m_timer = this.m_data[this.m_id].freq;
    this.numTotalEnemies = this.m_data[this.m_id].idEnemies.length;
    for (a = this.counterKilledEnemies = this.counterCreatedEnemies = 0; a < this.numTotalEnemies; a++) {
        b = Common.random(0, 2);
        c = {};
        var d = this.m_base.originPoints[b];
        c.x = d[0];
        c.y = d[1];
        c.params = "";
        c.rawData = {
            behaviorType: 0
        };
        c.id = this.m_data[this.m_id].idEnemies[a];
        c.timer = this.m_timer;
        c.wave = this;
        c.limitLeft = 0;
        c.limitRight = 0;
        this.m_base.waveDoors[b].queue.push(c)
    }
}
Wave.prototype.notifyKill = function() {
    this.counterKilledEnemies++;
    this.counterKilledEnemies >= this.numTotalEnemies && this.m_base.nextWave()
};

function WaveDoor(a, b, c, d) {
    this.m_state = WaveDoor.ST_STAND;
    this.m_x = a;
    this.m_y = b;
    this.m_canvas = new window.PIXI.Container;
    c.addChild(this.m_canvas);
    this.m_base = d;
    this.m_timer = -1;
    this.queue = [];
    this.m_character = new SimpleCharacter(a, b, this.m_canvas);
    this.m_character.addState(WaveDoor.ST_STAND, "basedoor_stand");
    this.m_character.addState(WaveDoor.ST_BLOCKED, "basedoor_blocked");
    this.m_character.addState(WaveDoor.ST_SPAWN, "basedoor_spawn");
    this.m_character.addState(WaveDoor.ST_DONE, "basedoor_defeat");
    this.m_character.addState(WaveDoor.ST_BREAK,
        "basedoor_break", [{
            caller: this,
            callback: this.playSpraySound,
            frame: 65
        }]);
    this.gotoState(WaveDoor.ST_STAND);
    this.m_character.onEndAnimation(this, this.onEndAnimation)
}
WaveDoor.ST_STAND = "stand";
WaveDoor.ST_BLOCKED = "blocked";
WaveDoor.ST_SPAWN = "spawn";
WaveDoor.ST_DONE = "done";
WaveDoor.ST_BREAK = "break";
WaveDoor.prototype.playSpraySound = function() {
    Application.instance.playSound("SND_CONQUER_DESTROY")
};
WaveDoor.prototype.gotoState = function(a) {
    this.m_character.gotoState(a);
    this.m_character.setPosition(this.m_x - this.m_base.m_world.m_camera.m_x, this.m_y - this.m_base.m_world.m_camera.m_y);
    this.m_state = a;
    a === WaveDoor.ST_BREAK && Application.instance.playSound("SND_CONQUER_DOOR_EXPLOSION")
};
WaveDoor.prototype.onEndAnimation = function(a) {
    switch (a) {
        case WaveDoor.ST_SPAWN:
            this.gotoState(WaveDoor.ST_STAND);
            this.startTimer();
            break;
        case WaveDoor.ST_BREAK:
            this.gotoState(WaveDoor.ST_DONE)
    }
};
WaveDoor.prototype.update = function(a) {
    this.m_character.update(a);
    this.m_character.setPosition(this.m_x - this.m_base.m_world.m_camera.m_x, this.m_y - this.m_base.m_world.m_camera.m_y);
    0 <= this.m_timer && (this.m_timer -= a, 0 >= this.m_timer && (this.m_timer = -1, this.spawnEnemy()))
};
WaveDoor.prototype.spawnEnemy = function() {
    var a = this.queue.shift();
    if (a) {
        var b = null;
        switch (a.id) {
            case ActorManagerPlatform.ENEMY_STORMTROOPER:
                b = new Stormtrooper(this.m_base.m_world.m_playerCanvas, this.m_base.m_world, a, "Stormtrooper", !0);
                break;
            case ActorManagerPlatform.ENEMY_SHOCKTROOPER:
                b = new Stormtrooper(this.m_base.m_world.m_playerCanvas, this.m_base.m_world, a, "Shocktrooper", !0);
                break;
            case ActorManagerPlatform.ENEMY_EWEBREPEATER:
                b = new EWebRepeaterBlaster(this.m_base.m_world.m_playerCanvas, this.m_base.m_world,
                    a, !0);
                break;
            case ActorManagerPlatform.ENEMY_SENTINELDROID:
                b = new SentinelDroid(this.m_base.m_world.m_playerCanvas, this.m_base.m_world, a, !0);
                break;
            case ActorManagerPlatform.ENEMY_MANDALORIAN:
                a.y -= 100;
                b = new Mandalorian(this.m_base.m_world.m_playerCanvas, this.m_base.m_world, a);
                b.forceAppear();
                break;
            default:
                b = new Stormtrooper(this.m_base.m_world.m_playerCanvas, this.m_base.m_world, a, "Stormtrooper", !0)
        }
        b.waveDoor = this;
        b.wave = a.wave;
        this.m_base.m_world.actorManager().add(b);
        a.wave.counterCreatedEnemies++;
        a.id !== ActorManagerPlatform.ENEMY_MANDALORIAN && a.id !== ActorManagerPlatform.ENEMY_SENTINELDROID ? this.gotoState(WaveDoor.ST_SPAWN) : this.startTimer()
    }
};
WaveDoor.prototype.startTimer = function() {
    this.m_timer = this.queue[0] ? this.queue[0].timer : -1
};

function ImperialMachine(a, b, c, d, e) {
    PlayerSettings.instance.sabotageState = ImperialMachine.ST_SABOTAGE_NONE;
    d = b.getFloorCollision(c, d).y;
    SimpleWorldActor.call(this, a, b, c, d);
    this.m_type = e;
    this.skin = this.m_type === ImperialMachine.TYPE_NORMAL || this.m_type === ImperialMachine.TYPE_COOPERATIVE ? "machine" : "machine_antenna";
    this.m_created = !1;
    this.isShielded = this.m_type === ImperialMachine.TYPE_ANTENNA;
    this.initCharacter();
    this.isMissionObjective = !0;
    this.m_health = this.m_initHealth = this.m_type === ImperialMachine.TYPE_NORMAL ||
        this.m_type === ImperialMachine.TYPE_COOPERATIVE ? Application.config.settings.imperialMachineLife : Application.config.settings.antennaLife;
    this.isEnemy = !0;
    this.showOOC = !1;
    this.m_type === ImperialMachine.TYPE_ANTENNA ? b.oocManager.registerActor(this, "gui_hud_pointer_machine_antenna", OOCManager.IMPERIAL_ANTENNA) : b.oocManager.registerActor(this, "gui_hud_pointer_imperial", ActorManagerPlatform.IMPERIAL_MACHINE);
    this.m_tint = this.m_countTint = this.m_timerTint = 0;
    this.hasBeenCollected = !1
}
Application.subclass(ImperialMachine, SimpleWorldActor);
ImperialMachine.TYPE_NORMAL = 1;
ImperialMachine.TYPE_COOPERATIVE = 2;
ImperialMachine.TYPE_ANTENNA = 3;
ImperialMachine.ST_SABOTAGE_PROGRESS = 10;
ImperialMachine.ST_SABOTAGE_NONE = 0;
ImperialMachine.TIME_PER_TINT = 80;
ImperialMachine.COUNT_TINTS = 4;
ImperialMachine.prototype.onTint = function(a) {
    this.m_clip.setTint(a);
    this.m_tint = a
};
ImperialMachine.prototype.onHit = function(a, b, c) {
    if (!this.isAwaitingDelete) {
        PlayerSettings.instance.sabotageState === ImperialMachine.ST_SABOTAGE_NONE && (PlayerSettings.instance.sabotageState = ImperialMachine.ST_SABOTAGE_PROGRESS);
        this.isShielded ? (HudPlatform.instance.reminderPopup || (GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_DESTROY_IMPERIALMACHINES, HudPlatform.instance.reminderPopup = new GuiPopupMessage("mcGuiPopupDialogue", 0, 0, HudPlatform.instance)), Application.instance.playSound("SND_ANTENNA_FORCEFIELD")) :
            (this.m_type === ImperialMachine.TYPE_ANTENNA && (this.onTint(16728642), this.m_timerTint = ImperialMachine.TIME_PER_TINT, this.m_countTint = ImperialMachine.COUNT_TINTS), this.m_health -= a);
        if (0 >= this.m_health) {
            this.m_world.createEffect("scnFxObjectExplotion", this.m_x, this.m_y - 50);
            Global.game.createExplotionShader(this.m_x - this.m_world.m_camera.m_x, this.m_y - this.m_world.m_camera.m_y, 9, .1);
            this.gotoState(ImperialMachine.ST_BREAK);
            this.hasBeenCollected = !0;
            Global.game.world.oocManager.removeThisActor(this);
            this.m_world.m_player.resetMissionActionTimer();
            a = Application.config.settings["minQuantityToShowHintsPlanet" + Global.level];
            switch (this.m_type) {
                case ImperialMachine.TYPE_NORMAL:
                    PlayerSettings.instance.doSabotage(1);
                    MissionManager.instance.isCooperative() ? (HudPlatform.instance.codedByAnimationCollectibles(PlayerSettings.instance.getBothPlayersSabotagesDone(), PlayerSettings.instance.getBothPlayersTotalSabotages()), PlayerSettings.instance.getBothPlayersSabotagesDone() >= a && (this.m_world.m_player.missionActionTimer = 0)) : (HudPlatform.instance.codedByAnimationCollectibles(PlayerSettings.instance.getSabotagesDone(),
                        PlayerSettings.instance.getTotalSabotages()), PlayerSettings.instance.getSabotagesDone() >= a && (this.m_world.m_player.missionActionTimer = 0));
                    break;
                case ImperialMachine.TYPE_COOPERATIVE:
                    PlayerSettings.instance.doSabotageCoop(1), HudPlatform.instance.codedByAnimationCollectibles(PlayerSettings.instance.getBothPlayersSabotagesDone(), PlayerSettings.instance.getBothPlayersTotalSabotages()), PlayerSettings.instance.getBothPlayersSabotagesDone() >= a && (this.m_world.m_player.missionActionTimer = 0)
            }
            if (this.m_type ===
                ImperialMachine.TYPE_ANTENNA) switch (PlayerSettings.instance.getCurrentTurn()) {
                case 1:
                    PlayerSettings.instance.player1GotAntenna = !0;
                    break;
                case 2:
                    PlayerSettings.instance.player2GotAntenna = !0
            }
            Application.instance.playSound("SND_IMPERIALMACHINE_ONBREAK")
        } else this.gotoState(ImperialMachine.ST_HIT), this.isShielded || Application.instance.playSound("SND_IMPERIALMACHINE_ONHIT");
        return !0
    }
};
ImperialMachine.prototype.onExpel = function() {
    this.onHit(2 * this.m_world.m_player.data.damageMelee, 0, 0)
};
ImperialMachine.prototype.onAllSabotaged = function() {
    GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_RETURN_IMPERIALANTENNA;
    HudPlatform.instance.addPopup(GuiPopupMessage, "mcGuiMessageMissionUpdateAntenna");
    this.m_world.actorManager().updateAntenna()
};
ImperialMachine.prototype.setAntennaVulnerable = function() {
    this.m_type === ImperialMachine.TYPE_ANTENNA && (this.isShielded && this.m_world.m_actorManager.createEnemies(this.m_x, this.m_y, 100), this.isShielded = !1, this.m_character.addState(ImperialMachine.ST_STAND, this.skin + "_stand"), this.m_character.addState(ImperialMachine.ST_HIT, this.skin + "_hit"), this.m_state = -1, this.gotoState(ImperialMachine.ST_STAND));
    HudPlatform.instance.disableCollectibles();
    this.m_world.oocManager.setActiveOfType(OOCManager.IMPERIAL_ANTENNA, !0)
};
ImperialMachine.prototype.onCompleteMission = function() {
    GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_RETURN_EXTRACTION;
    HudPlatform.instance.addPopup(GuiPopupMessage, "mcGuiMessageMissionUpdate");
    Global.game.world.actorManager().toggleExtractionPoints(!0)
};
ImperialMachine.prototype.update = function(a) {
    if (this.m_created && (SimpleWorldActor.prototype.update.call(this, a), !this.isAwaitingDelete))
        if (0 < this.m_timerTint && (this.m_timerTint -= a, 0 >= this.m_timerTint && (--this.m_countTint, 0 < this.m_countTint ? (this.m_clip.alpha = 1, this.onTint(this.m_tint), this.m_timerTint = Atdp.TIME_PER_TINT) : (this.m_clip.alpha = 1, this.onTint(16777215), this.m_timerTint = 0))), this.checkPlayerNearby(), !PlatformGame.playerUseExpel && this.hitCollisions(SimpleWorldActor.COLLISION, this.m_world.m_player,
                SimpleWorldActor.COLLISION_EXPEL)) PlatformGame.playerUseExpel = !0, this.onHit(20, 0, 0);
        else {
            if (this.hitCollisions(SimpleWorldActor.COLLISION, this.m_world.player(), SimpleWorldActor.COLLISION_ATTACK)) this.onHit(10, 0, 0);
            if (this.m_world.m_player.clipSpecialAttack && SDisplayObjectContainer.hitTestByBounds(this.m_clip, this.m_clip.getCollision(SimpleWorldActor.COLLISION), this.m_world.m_player.clipSpecialAttack, this.m_world.m_player.clipSpecialAttack.getCollision(SimpleWorldActor.COLLISION_SPECIAL))) this.onHit(100,
                0, 0)
        }
};
ImperialMachine.prototype.checkPlayerNearby = function() {
    this.m_world.m_player.m_flipX && this.m_world.m_player.m_x > this.m_x && 180 > this.m_world.m_player.m_x - this.m_x ? PlatformGame.playerNearEnemy = !0 : !this.m_world.m_player.m_flipX && this.m_x > this.m_world.m_player.m_x && 180 > this.m_x - this.m_world.m_player.m_x && (PlatformGame.playerNearEnemy = !0)
};
ImperialMachine.ST_STAND = "stand";
ImperialMachine.ST_HIT = "hit";
ImperialMachine.ST_BREAK = "break";
ImperialMachine.prototype.initCharacter = function() {
    switch (this.m_type) {
        case ImperialMachine.TYPE_NORMAL:
            PlayerSettings.instance.addSabotagesRemaining(1);
            break;
        case ImperialMachine.TYPE_COOPERATIVE:
            PlayerSettings.instance.addSabotagesRemainingCoop(1)
    }
    this.m_character = new SimpleCharacter(this.m_x, this.m_y, this.m_canvas);
    this.m_character.addState(ImperialMachine.ST_STAND, this.skin + (this.m_type === ImperialMachine.TYPE_ANTENNA ? "_shield" : "") + "_stand");
    this.m_character.addState(ImperialMachine.ST_HIT, this.skin +
        (this.m_type === ImperialMachine.TYPE_ANTENNA ? "_shield" : "") + "_hit");
    this.m_character.addState(ImperialMachine.ST_BREAK, this.skin + "_break");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.m_character.worldActor = this;
    this.m_type !== ImperialMachine.TYPE_COOPERATIVE && (this.gotoState(ImperialMachine.ST_STAND), this.m_created = !0);
    this.m_className = "ImperialMachine"
};
ImperialMachine.prototype.onEndAnimation = function(a) {
    switch (this.m_type) {
        case ImperialMachine.TYPE_NORMAL:
        case ImperialMachine.TYPE_COOPERATIVE:
            switch (a) {
                case ImperialMachine.ST_HIT:
                    this.m_character.addState(ImperialMachine.ST_STAND, this.skin + "_stand2");
                    this.gotoState(ImperialMachine.ST_STAND);
                    break;
                case ImperialMachine.ST_BREAK:
                    this.m_character.addState(ImperialMachine.ST_STAND, this.skin + "_breakstand"), this.gotoState(ImperialMachine.ST_STAND), PlayerSettings.instance.sabotageState = ImperialMachine.ST_SABOTAGE_NONE
            }
            break;
        case ImperialMachine.TYPE_ANTENNA:
            switch (a) {
                case ImperialMachine.ST_HIT:
                    this.isShielded || (this.m_character.addState(ImperialMachine.ST_HIT, this.skin + "_hit" + (this.m_health > .35 * this.m_initHealth ? "2" : "3")), this.m_character.addState(ImperialMachine.ST_STAND, this.skin + "_stand" + (this.m_health > .35 * this.m_initHealth ? "2" : "3")));
                    this.gotoState(ImperialMachine.ST_STAND);
                    break;
                case ImperialMachine.ST_BREAK:
                    this.onCompleteMission(), this.isAwaitingDelete = !0
            }
    }
};
ImperialMachine.prototype.doStand = function() {
    this.gotoState(ImperialMachine.ST_STAND);
    this.m_created = !0
};

function Item(a, b, c, d, e, f) {
    SimpleWorldActor.call(this, a, b, c, d);
    f = void 0 !== f ? f : "";
    this.type = e;
    this.showOOC = e === Item.TYPE_COLLECTIBLE_GROUP;
    a = "";
    this.m_plusScore = 0;
    this.m_created = !1;
    this.isMissionObjective = !0;
    switch (this.type) {
        case Item.TYPE_COLLECTIBLE:
            a = "mcObj_collectible" + PlayerSettings.instance.m_collectSkin;
            PlayerSettings.instance.addItemsRemaining(1);
            b.oocManager.registerActor(this, "gui_hud_pointer_collect_0" + PlayerSettings.instance.m_collectSkin, ActorManagerPlatform.ITEM_COLLECTIBLE);
            this.m_className =
                "ItemCollectible";
            break;
        case Item.TYPE_COLLECTIBLE_COOP:
            a = "mcObj_collectible" + PlayerSettings.instance.m_collectSkin;
            PlayerSettings.instance.addItemsRemainingCoop(1);
            b.oocManager.registerActor(this, "gui_hud_pointer_collect_0" + PlayerSettings.instance.m_collectSkin, ActorManagerPlatform.ITEM_COLLECTIBLE);
            this.m_className = "ItemCollectible";
            break;
        case Item.TYPE_COLLECTIBLE_GROUP:
            this.m_plusScore = PlayerSettings.instance.getRemainingObjects(), b.oocManager.registerActor(this, "gui_hud_pointer_collect_07", -1),
                a = "mcObj_collectibleGroup", this.m_className = "ItemCollectible"
    }
    this.m_character = new SimpleCharacter(0, 0, this.m_canvas);
    this.m_character.addState(Item.ST_ITEM_STAND, a + "_stand");
    this.m_character.addState(Item.ST_ITEM_FADING, a + "_disappear");
    this.m_character.addState(Item.ST_ITEM_OFF, a + "_off");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.type !== Item.TYPE_COLLECTIBLE_COOP && (this.gotoState(Item.ST_ITEM_STAND), this.m_created = !0);
    this.hasBeenCollected = !1;
    this.msg = Application.strings[f]
}
Application.subclass(Item, SimpleWorldActor);
Item.TYPE_COLLECTIBLE = 900;
Item.TYPE_COLLECTIBLE_COOP = 902;
Item.TYPE_ADD_HEALTH = 901;
Item.TYPE_COLLECTIBLE_GROUP = 903;
Item.ST_ITEM_STAND = "st1";
Item.ST_ITEM_FADING = "st2";
Item.ST_ITEM_OFF = "st3";
Item.prototype.update = function(a) {
    if (this.m_created) switch (SimpleWorldActor.prototype.update.call(this, a), this.m_state) {
        case Item.ST_ITEM_STAND:
            if (this.m_clip.hitTest(this.m_world.m_player.m_clip)) switch (this.hasBeenCollected = !0, Application.instance.playSound("SND_ITEM_COLLECT"), Global.game.world.oocManager.removeThisActor(this), this.m_world.m_player.resetMissionActionTimer(), a = Application.config.settings["minQuantityToShowHintsPlanet" + Global.level], this.type) {
                case Item.TYPE_COLLECTIBLE:
                    PlayerSettings.instance.obtainItem(1);
                    MissionManager.instance.isCooperative() ? (HudPlatform.instance.codedByAnimationCollectibles(PlayerSettings.instance.getBothPlayersCollectedItems(), PlayerSettings.instance.getBothPlayersTotalItems()), PlayerSettings.instance.getBothPlayersCollectedItems() >= a && (this.m_world.m_player.missionActionTimer = 0)) : (HudPlatform.instance.codedByAnimationCollectibles(PlayerSettings.instance.getCollectedItems(), PlayerSettings.instance.getTotalItems()), PlayerSettings.instance.getCollectedItems() >= a && (this.m_world.m_player.missionActionTimer =
                        0));
                    this.gotoState(Item.ST_ITEM_FADING);
                    break;
                case Item.TYPE_COLLECTIBLE_COOP:
                    PlayerSettings.instance.obtainItemCoop(1), HudPlatform.instance.codedByAnimationCollectibles(PlayerSettings.instance.getBothPlayersCollectedItems(), PlayerSettings.instance.getBothPlayersTotalItems()), this.gotoState(Item.ST_ITEM_FADING), PlayerSettings.instance.getBothPlayersCollectedItems() >= a && (this.m_world.m_player.missionActionTimer = 0)
            }
    }
};
Item.prototype.onEndAnimation = function(a) {
    switch (a) {
        case Item.ST_ITEM_FADING:
            switch (this.type) {
                case Item.TYPE_COLLECTIBLE:
                case Item.TYPE_COLLECTIBLE_COOP:
                    if (MissionManager.instance.isCooperative()) {
                        if (PlayerSettings.instance.hasGrabbedAllItems() && PlayerSettings.instance.hasGrabbedAllItemsCoop()) this.onAllItemsCollected()
                    } else if (PlayerSettings.instance.hasGrabbedAllItems()) this.onAllItemsCollected();
                    this.gotoState(Item.ST_ITEM_OFF);
                    break;
                case Item.TYPE_ADD_HEALTH:
                case Item.TYPE_COLLECTIBLE_GROUP:
                    this.isAwaitingDelete = !0
            }
    }
};
Item.prototype.onAllItemsCollected = function() {};
Item.prototype.doStand = function() {
    this.gotoState(Item.ST_ITEM_STAND);
    this.m_created = !0
};

function ItemWorld(a, b, c, d) {
    SimpleWorldActor.call(this, a.m_playerCanvas, a, b, a.getFloorCollision(b, c).y - 30);
    this.type = d;
    this.data = Application.config.items[this.type];
    this.amount = this.data.amount;
    this.m_skin = this.data.skin;
    this.isPowerup = !(this.type === ItemWorld.TYPE_DROP_HEALTH || this.type === ItemWorld.TYPE_HEALTH);
    this.m_character = new SimpleCharacter(0, 0, this.m_canvas);
    this.m_character.addState(ItemWorld.ST_STAND, this.m_skin + "_stand");
    this.m_character.addState(ItemWorld.ST_FADING, this.m_skin + "_fading");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.gotoState(ItemWorld.ST_STAND);
    PlayerSettings.instance.isPlayerMelee() && this.data.use === ItemWorld.USE_RANGE && (this.isAwaitingDelete = !0);
    PlayerSettings.instance.isPlayerRange() && this.data.use === ItemWorld.USE_MEELE && (this.isAwaitingDelete = !0)
}
Application.subclass(ItemWorld, SimpleWorldActor);
ItemWorld.PICKUP_RANGE = 200;
ItemWorld.TYPE_NONE = 0;
ItemWorld.TYPE_HEALTH = 1;
ItemWorld.TYPE_SHIELD = 2;
ItemWorld.TYPE_PU_STRIKEWAVE = 3;
ItemWorld.TYPE_PU_PERFECTDEFLECT = 4;
ItemWorld.TYPE_PU_MULTIBLASTER = 5;
ItemWorld.TYPE_PU_EXPLOSIVEBLASTER = 6;
ItemWorld.TYPE_DROP_HEALTH = 7;
ItemWorld.USE_BOTH = 0;
ItemWorld.USE_MEELE = 1;
ItemWorld.USE_RANGE = 2;
ItemWorld.ST_STAND = "st1";
ItemWorld.ST_FADING = "st2";
ItemWorld.prototype.update = function(a) {
    SimpleWorldActor.prototype.update.call(this, a);
    switch (this.m_state) {
        case ItemWorld.ST_STAND:
            if (this.m_clip.hitTest(this.m_world.m_player.m_clip)) {
                switch (this.type) {
                    case ItemWorld.TYPE_HEALTH:
                    case ItemWorld.TYPE_DROP_HEALTH:
                        a = this.m_world.player().getHealth() + this.amount;
                        100 < a && (a = 100);
                        this.m_world.player().setHealth(a);
                        HudPlatform.instance.setEnergyBar(a, !0);
                        this.m_world.createEffect("aniFxPowerupHPRecovery", this.m_world.m_player.m_x, this.m_world.m_player.m_y -
                            60);
                        Application.instance.playSound("SND_ITEM_HEALTH");
                        break;
                    case ItemWorld.TYPE_SHIELD:
                        this.m_world.m_player && (this.m_world.m_player.activatePowerUp(this.type, this.amount), this.m_world.createEffect("aniFxPlayerPickPowerup", this.m_world.m_player.m_x, this.m_world.m_player.m_y - 60), Application.instance.playSound("SND_PUP_SHIELD_ON"), this.m_world.m_player.PP5Tooltipshown || (HudPlatform.instance.tooltip && HudPlatform.instance.tooltip.free(), GuiPopupTooltip.typeMessage = GuiPopupTooltip.PP_SHIELD_TOOLTIP, HudPlatform.instance.tooltip =
                            new GuiPopupTooltip("mcGuiPopupPowerup", 0, 0, HudPlatform.instance), this.m_world.m_player.PP5Tooltipshown = !0));
                        break;
                    case ItemWorld.TYPE_PU_STRIKEWAVE:
                        this.m_world.m_player && (this.m_world.m_player.activatePowerUp(this.type, this.amount), this.m_world.createEffect("aniFxPlayerPickPowerup", this.m_world.m_player.m_x, this.m_world.m_player.m_y - 60), Application.instance.playSound("SND_ITEM_POWERUP"), this.m_world.m_player.PP1Tooltipshown || (HudPlatform.instance.tooltip && HudPlatform.instance.tooltip.free(), GuiPopupTooltip.typeMessage =
                            GuiPopupTooltip.PP_STRIKE_TOOLTIP, HudPlatform.instance.tooltip = new GuiPopupTooltip("mcGuiPopupPowerup", 0, 0, HudPlatform.instance), this.m_world.m_player.PP1Tooltipshown = !0));
                        break;
                    case ItemWorld.TYPE_PU_PERFECTDEFLECT:
                        this.m_world.m_player && (this.m_world.m_player.activatePowerUp(this.type, this.amount), this.m_world.createEffect("aniFxPlayerPickPowerup", this.m_world.m_player.m_x, this.m_world.m_player.m_y - 60), Application.instance.playSound("SND_ITEM_POWERUP"), this.m_world.m_player.PP2Tooltipshown || (HudPlatform.instance.tooltip &&
                            HudPlatform.instance.tooltip.free(), GuiPopupTooltip.typeMessage = GuiPopupTooltip.PP_DEFLECT_TOOLTIP, HudPlatform.instance.tooltip = new GuiPopupTooltip("mcGuiPopupPowerup", 0, 0, HudPlatform.instance), this.m_world.m_player.PP2Tooltipshown = !0));
                        break;
                    case ItemWorld.TYPE_PU_MULTIBLASTER:
                        this.m_world.m_player && this.m_world.m_player.gunWeapon && (this.m_world.m_player.activatePowerUp(this.type, this.amount), this.m_world.createEffect("aniFxPlayerPickPowerup", this.m_world.m_player.m_x, this.m_world.m_player.m_y - 60),
                            Application.instance.playSound("SND_ITEM_POWERUP"), this.m_world.m_player.PP4Tooltipshown || (HudPlatform.instance.tooltip && HudPlatform.instance.tooltip.free(), GuiPopupTooltip.typeMessage = GuiPopupTooltip.PP_SONIC_BLASTER_TOOLTIP, HudPlatform.instance.tooltip = new GuiPopupTooltip("mcGuiPopupPowerup", 0, 0, HudPlatform.instance), this.m_world.m_player.PP4Tooltipshown = !0));
                        break;
                    case ItemWorld.TYPE_PU_EXPLOSIVEBLASTER:
                        this.m_world.m_player && this.m_world.m_player.gunWeapon && (this.m_world.m_player.activatePowerUp(this.type,
                            this.amount), this.m_world.createEffect("aniFxPlayerPickPowerup", this.m_world.m_player.m_x, this.m_world.m_player.m_y - 60), Application.instance.playSound("SND_ITEM_POWERUP"), this.m_world.m_player.PP3Tooltipshown || (HudPlatform.instance.tooltip && HudPlatform.instance.tooltip.free(), GuiPopupTooltip.typeMessage = GuiPopupTooltip.PP_DEATH_TROOPER_BLASTER_TOOLTIP, HudPlatform.instance.tooltip = new GuiPopupTooltip("mcGuiPopupPowerup", 0, 0, HudPlatform.instance), this.m_world.m_player.PP3Tooltipshown = !0))
                }
                this.m_world.createEffect(this.m_skin +
                    "_fx", this.m_world.m_player.m_x, this.m_world.m_player.m_y - 60);
                this.isAwaitingDelete = !0;
                HudPlatform.instance.codedPickupAnimation(this.type)
            } else {
                var b = this.m_x - this.m_world.m_player.m_x,
                    c = this.m_y - (this.m_world.m_player.m_y - (this.m_y > this.m_world.m_player.m_y - 60 ? 75 : 45)),
                    b = SMath.abs(b),
                    c = SMath.abs(c);
                b <= ItemWorld.PICKUP_RANGE && c <= ItemWorld.PICKUP_RANGE && (this.m_x += Common.lerp(this.m_x, this.m_world.m_player.m_x, 5, a), this.m_y += Common.lerp(this.m_y, this.m_world.m_player.m_y - (this.m_y > this.m_world.m_player.m_y -
                    60 ? 75 : 45), 5, a))
            }
    }
};
ItemWorld.prototype.onEndAnimation = function(a) {};

function Bullet(a, b, c) {
    this.clip = null;
    this.subType = this.type = 0;
    this.x = b;
    this.y = c;
    this.speed = this.vy = this.vx = this.angle = this.damage = 0;
    this.isAlive = !1;
    this.world = a;
    this.motionLimit = new Rectangle;
    this.move = null;
    this.fxImpactName = Bullet.FX_IMPACT_LASER_ENEMY
}
Bullet.NAME_SKIN_BULLET_ENEMY = "mcBulletEnemy";
Bullet.FX_IMPACT_LASER_ENEMY = "aniFxEnemyHit";
Bullet.FX_IMPACT_LASER_PLAYER = "aniFxPlayerHit";
Bullet.FX_IMPACT_EXPLOSIVE = "aniFxBulletExplotion";
Bullet.FX_IMPACT_WAVE = "aniFxExplotion1";
Bullet.FX_IMPACT_ELECTRICITY = "aniFxChooperPlayerHit00";
Bullet.FX_IMPACT_BOSS = "aniFxBoss01Hit";
Bullet.FX_IMPACT_GRENADE = "aniFxBulletExplotion";
Bullet.TYPE_PLAYER = 1;
Bullet.TYPE_ENEMY = 2;
Bullet.TYPE_DUMMY = 3;
Bullet.TYPE_ENEMY_NO_DEFLECT = 4;
Bullet.TYPE_ENEMY_NO_CAMERA = 5;
Bullet.SUB_TYPE_NONE = 0;
Bullet.SUB_TYPE_PLAYER_LASER = 1;
Bullet.SUB_TYPE_PLAYER_EXPLOSIVE = 2;
Bullet.SUB_TYPE_PLAYER_WAVE = 3;
Bullet.SUB_TYPE_PLAYER_ELECTRICITY = 4;
Bullet.SUB_TYPE_PLAYER_ELECTRICITY_EXPLOSIVE = 5;
Bullet.prototype.free = function() {
    this.world = null;
    this.clip && PoolClips.instance.releaseClip(this.clip);
    this.motionLimit = this.clip = null;
    this.move && (this.move.free(), this.move = null)
};
Bullet.prototype.setType = function(a, b) {
    this.type = a;
    this.clip = PoolClips.instance.getClip(b);
    this.clip.position.x = this.x - this.world.m_camera.m_x;
    this.clip.position.y = this.y - this.world.m_camera.m_y;
    this.world.objectCanvas().addChild(this.clip)
};
Bullet.prototype.settingMotionLimit = function(a, b, c, d) {
    this.motionLimit.x = 0 <= c ? a : a + c;
    this.motionLimit.y = 0 <= d ? b : b + d;
    this.motionLimit.w = 0 <= c ? c : -c;
    this.motionLimit.h = 0 <= d ? d : -d
};
Bullet.prototype.goto = function(a, b) {
    0 > a && (Application.error("gotoRadialPoint() - distance: " + a), a *= -1);
    if (0 === a) this.isAlive = !1;
    else {
        this.isAlive = !0;
        this.angle = b;
        var c = a * Math.cos(this.angle),
            d = a * Math.sin(this.angle);
        this.settingMotionLimit(this.x, this.y, c, d);
        this.vx = c / a * this.speed;
        this.vy = d / a * this.speed;
        this.type == Bullet.TYPE_DUMMY ? this.clip.scale.x = 0 === this.angle ? -1 : 1 : this.clip.rotation = this.angle
    }
};
Bullet.prototype.gotoParabolic = function(a, b, c, d, e) {
    this.isAlive = !0;
    this.move = new ParametricParabolicMovement(a, b, c, d, e, .12);
    this.move.onComplete(this, this.onCompleteParabolicMove)
};
Bullet.prototype.onCompleteParabolicMove = function(a) {
    a = !0;
    this.move && (a = this.move.toFront, this.move.free(), this.move = null);
    this.goto(800, a ? 0 : Common.gradToRadian(180))
};
Bullet.prototype.update = function(a) {
    this.isAlive && this.clip && (this.move ? (this.x = this.move.m_rx, this.y = this.move.m_ry, this.clip.position.x = this.x - this.world.m_camera.m_x, this.clip.position.y = this.y - this.world.m_camera.m_y, this.clip.update(a), this.move.update(a)) : (this.x += this.vx * a, this.y += this.vy * a, this.clip.position.x = this.x - this.world.m_camera.m_x, this.clip.position.y = this.y - this.world.m_camera.m_y, this.clip.update(a), 0 != this.world.getCellInPosition(this.x, this.y) ? (a = this.world.createEffect(this.fxImpactName,
        this.x, this.y), this.type == Bullet.TYPE_DUMMY && (a.clip.scale.x = 0 === this.angle ? -1 : 1, Global.game.onShake(5, 10, 300)), this.isAlive = !1) : this.type !== Bullet.TYPE_ENEMY_NO_CAMERA && (this.x < this.world.m_camera.m_x - this.world.m_camera.fixOffsetX || this.x > this.world.m_camera.m_x - this.world.m_camera.fixOffsetX + this.world.m_camera.fixWidthRatio) ? (a = this.world.createEffect(this.fxImpactName, this.x, this.y), this.type == Bullet.TYPE_DUMMY && (a.clip.scale.x = 0 === this.angle ? -1 : 1, Global.game.onShake(4, 10, 200)), this.isAlive = !1) : this.motionLimit.contains(this.x, this.y) ? this.checkCollsions() : this.isAlive = !1))
};
Bullet.prototype.onStandBy = function() {
    PoolClips.instance.releaseClip(this.clip);
    this.clip = null;
    this.move && (this.move.free(), this.move = null)
};
Bullet.prototype.checkCollsions = function() {
    switch (this.type) {
        case Bullet.TYPE_PLAYER:
            for (var a = this.world.m_actorManager.m_actors.length, b = 0, c = !1, b = 0; b < a; b++) {
                var d = this.world.m_actorManager.m_actors[b];
                if (d.isEnemy && !d.isIdle && d.m_clip && this.clip.hitTest(d.m_clip)) {
                    switch (this.subType) {
                        case Bullet.SUB_TYPE_PLAYER_EXPLOSIVE:
                        case Bullet.SUB_TYPE_PLAYER_ELECTRICITY_EXPLOSIVE:
                            c = !0;
                            d.onExpel();
                            Global.game.createExplotionShader(this.x - this.world.m_camera.m_x, this.y - this.world.m_camera.m_y, 5);
                            break;
                        case Bullet.SUB_TYPE_PLAYER_WAVE:
                            c = !0;
                            d.onExpel();
                            Global.game.createExplotionShader(this.x - this.world.m_camera.m_x, this.y - this.world.m_camera.m_y, 5);
                            break;
                        default:
                            c = MissionManager.instance.isMissionBossBattle() ? this.world.m_player.data.regularDamageToBoss : this.damage, c = d.onHit(c)
                    }
                    c && (this.world.createEffect(this.fxImpactName, this.x, this.y), this.isAlive = !1, Global.game.onShake(4, 10, 200), this.subType !== Bullet.SUB_TYPE_PLAYER_ELECTRICITY || d.isBoss || this.world.createEffect("aniFxChooperPlayerHit", d.m_x, d.m_y - 70))
                }
            }
            break;
        case Bullet.TYPE_ENEMY:
        case Bullet.TYPE_ENEMY_NO_DEFLECT:
        case Bullet.TYPE_ENEMY_NO_CAMERA:
            this.world.m_player &&
                this.world.m_player.m_clip && (this.world.m_player.clipSpecialAttack ? SDisplayObjectContainer.hitTestByBounds(this.clip, this.clip.getCollision(SimpleWorldActor.COLLISION), this.world.m_player.clipSpecialAttack, this.world.m_player.clipSpecialAttack.getCollision(SimpleWorldActor.COLLISION_SPECIAL)) && (this.world.createEffect(this.fxImpactName, this.x, this.y), this.isAlive = !1) : this.world.m_player.checkCollisionShield(this.x, this.y) ? (this.world.createEffect(this.fxImpactName, this.x, this.y), this.world.createEffect("aniFxPoweruoShieldHit",
                        this.world.m_player.m_x, this.world.m_player.m_y - 70), Global.game.createExplotionShader(this.world.m_player.m_x - this.world.m_camera.m_x, this.world.m_player.m_y - this.world.m_camera.m_y - 70, 5), Global.game.onShake(5, 10, 200), this.isAlive = !1) : this.type !== Bullet.TYPE_ENEMY_NO_DEFLECT && SDisplayObjectContainer.hitTestByBounds(this.clip, this.clip.getCollision(SimpleWorldActor.COLLISION), this.world.m_player.m_clip, this.world.m_player.m_clip.getCollision("mcCollisionDeflect")) ? (this.type = Bullet.TYPE_PLAYER, this.speed +=
                        .8 * Math.random(), this.damage = this.world.m_player.data.damageMelee, Global.game.createExplotionShader(this.x - this.world.m_camera.m_x, this.y - this.world.m_camera.m_y, 3, .1), this.world.m_player.activePowerUp === ItemWorld.TYPE_PU_PERFECTDEFLECT ? (this.world.m_player.createDeflectBullet(this.x, this.y), this.isAlive = !1) : this.goto(400, this.angle + Math.PI + (3 * Math.random() - 1.5)), this.world.createEffect(this.fxImpactName, this.x, this.y), Global.game.onShake(5, 10, 200)) : this.clip.hitTest(this.world.m_player.m_clip) &&
                    this.world.m_player.onBulletCollision(this, this.damage) && (this.world.createEffect(this.fxImpactName, this.x, this.y), this.isAlive = !1))
    }
};

function StrikeWave(a, b, c) {
    Bullet.call(this, a, b, c)
}
Application.subclass(StrikeWave, Bullet);
StrikeWave.prototype.update = function(a) {
    Bullet.prototype.update.call(this, a)
};
StrikeWave.prototype.setType = function(a, b) {
    this.type = a;
    this.clip = PoolClips.instance.getClip(b);
    this.clip.position.x = this.x - this.world.m_camera.m_x;
    this.clip.position.y = this.y - this.world.m_camera.m_y;
    this.world.objectCanvas().addChild(this.clip);
    this.clip.onEndAnimation(this, this.onEndAnimation)
};
StrikeWave.prototype.onEndAnimation = function() {
    this.clip.stop()
};
StrikeWave.prototype.getCollision = function() {
    var a = this.clip.getCollision("mcCollision");
    return new Rectangle(this.x - .5 * a.w, this.y - .5 * a.h, a.w, a.h)
};
StrikeWave.prototype.checkCollsions = function() {
    for (var a = this.world.m_actorManager.m_actors.length, b = 0, b = 0; b < a; b++) {
        var c = this.world.m_actorManager.m_actors[b];
        if (c.isEnemy && !c.isIdle && c.m_clip && (this.getCollision(), this.clip.hitTest(c.m_clip))) {
            if ("undefined" !== typeof c.onStrikeWaveHit) c.onStrikeWaveHit();
            else c.onHit(c.health);
            Global.game.onShake(4, 10, 200)
        }
    }
};

function BulletManager(a, b) {
    this.world = a;
    this.bullets = [];
    this.pool = [];
    this.sWaveBullets = [];
    this.sWavePool = [];
    this.missilesPool = [];
    this.missiles = [];
    this.atdpMissilesPool = [];
    this.atdpMissiles = [];
    for (var c = 0; c < b; c++) this.pool.push(new Bullet(this.world, 0, 0));
    this.setupMissiles();
    this.setupStrikeWaveBullets();
    this.setupAtdpMissiles()
}
BulletManager.prototype.setupStrikeWaveBullets = function() {};
BulletManager.prototype.createDummyBullet = function(a, b, c, d, e) {
    if (0 < this.pool.length) {
        var f = this.pool.splice(0, 1)[0];
        f.x = c;
        f.y = d;
        f.setType(Bullet.TYPE_DUMMY, a);
        f.speed = 1.1 + .1 * Math.random();
        f.damage = 0;
        f.goto(1E3, e);
        f.fxImpactName = b;
        this.bullets.push(f)
    }
};
BulletManager.prototype.createForceBullet = function(a, b, c, d, e, f, g, h) {
    0 < this.pool.length && (a = this.pool.splice(0, 1)[0], a.x = b, a.y = c, a.setType(Bullet.TYPE_PLAYER, "mcEnviromentProjectil_" + Global.level + "_" + Common.randomInt(1, 4)), a.speed = f, a.damage = g, a.gotoParabolic(b, c, d, e, .15 * h), this.bullets.push(a))
};
BulletManager.prototype.create = function(a, b, c, d, e, f, g, h, k, m) {
    if (0 !== this.world.getCellInPosition(c, d)) "undefined" !== typeof k && this.world.createEffect(k, c, d);
    else {
        if (a === Bullet.TYPE_PLAYER) {
            var l = this.world.m_actorManager.getEnemyOnCollisionAttack();
            if (l && 0 < l.m_health) {
                "undefined" !== typeof k && this.world.createEffect(k, c, d);
                l.onHit(h);
                return
            }
        }
        l = null;
        0 < this.pool.length && (l = this.pool.splice(0, 1)[0], l.x = c, l.y = d, l.setType(a, b), l.speed = g, l.damage = h, l.goto(e, f), l.subType = m || 0, l.fxImpactName = k || Bullet.FX_IMPACT_LASER_ENEMY,
            this.bullets.push(l));
        return l
    }
};
BulletManager.prototype.createStrikeWave = function(a, b, c, d, e, f, g) {
    if (0 == this.world.getCellInPosition(b, c) && 0 < this.sWavePool.length) {
        var h = this.sWavePool.splice(0, 1)[0];
        h.x = b;
        h.y = c;
        h.setType(Bullet.TYPE_PLAYER, a);
        h.speed = f;
        h.damage = g;
        h.goto(d, e);
        this.sWaveBullets.push(h)
    }
};
BulletManager.prototype.update = function(a) {
    for (var b = 0; b < this.bullets.length; b++)
        if (this.bullets[b].update(a), !this.bullets[b].isAlive) {
            var c = this.bullets.splice(b, 1)[0];
            c.onStandBy();
            this.pool.push(c);
            b--
        }
    for (b = 0; b < this.sWaveBullets.length; b++) this.sWaveBullets[b].update(a), this.sWaveBullets[b].isAlive || (c = this.sWaveBullets.splice(b, 1)[0], c.onStandBy(), this.sWavePool.push(c), b--);
    for (b = 0; b < this.atdpMissiles.length; b++) this.atdpMissiles[b].update(a), this.atdpMissiles[b].isAlive || (c = this.atdpMissiles.splice(b,
        1)[0], this.atdpMissilesPool.push(c), b--);
    this.updateMissiles(a)
};
BulletManager.prototype.updateMissiles = function(a) {
    for (var b = this.missiles.length - 1; 0 <= b; b--) this.missiles[b].isIdle || this.missiles[b].update(a)
};
BulletManager.prototype.createMissile = function(a, b, c, d, e, f, g, h, k, m) {
    if (0 < this.missilesPool.length) {
        var l = this.missilesPool.splice(0, 1)[0];
        l.setParams(a, b, c, d, e, f, g, h, k, m);
        this.missiles.push(l)
    }
};
BulletManager.prototype.moveMissileToPool = function(a) {
    for (var b = this.missiles.length - 1; 0 <= b; b--)
        if (this.missiles[b] === a) {
            this.missiles.splice(b, 1);
            this.missilesPool.push(a);
            break
        }
};
BulletManager.prototype.setupMissiles = function() {
    for (var a = 0; 20 > a; a++) {
        var b = new Missile(this.world);
        this.missilesPool.push(b)
    }
};
BulletManager.prototype.missilesAvailable = function() {
    return 0 < this.missilesPool.length
};
BulletManager.prototype.createAtdpMissile = function(a, b, c, d, e, f, g, h) {
    if (0 < this.atdpMissilesPool.length) {
        var k = this.atdpMissilesPool.splice(0, 1)[0];
        k.setParams(a, b, c, d, e, f, g, h);
        this.atdpMissiles.push(k)
    }
};
BulletManager.prototype.moveAtdpMissileToPool = function(a) {
    for (var b = this.atdpMissiles.length - 1; 0 <= b; b--)
        if (this.atdpMissiles[b] === a) {
            this.atdpMissiles.splice(b, 1);
            this.atdpMissilesPool.push(a);
            break
        }
};
BulletManager.prototype.setupAtdpMissiles = function() {
    for (var a = 0; 20 > a; a++) {
        var b = new AtdpMissile(this.world);
        this.atdpMissilesPool.push(b)
    }
};
BulletManager.prototype.free = function() {};

function SaberWeapon(a) {
    this.clip = null;
    this.angle = this.vy = this.vx = this.y = this.x = this.ox = 0;
    this.skin = "mcSaberJedi";
    this.speed = 0;
    this.range = 600;
    this.damage = 100;
    this.isAlive = this.isReturn = !1;
    this.world = a
}
SaberWeapon.SPEED = 1.1;
SaberWeapon.SPEED_RETURN = 1.3;
SaberWeapon.OFFSET_Y = -80;
SaberWeapon.prototype.onLaunch = function(a, b) {
    this.isAlive || (this.isAlive = !0, this.isReturn = !1, this.x = this.ox = a, this.y = b, this.speed = 0 < this.world.m_player.m_clip.scale.x ? SaberWeapon.SPEED : -SaberWeapon.SPEED, this.clip = PoolClips.instance.getClip(this.skin), this.clip.position.x = this.x - this.world.m_camera.m_x, this.clip.position.y = this.y - this.world.m_camera.m_y, this.world.objectCanvas().addChild(this.clip))
};
SaberWeapon.prototype.onStandBy = function() {
    this.isAlive = !1;
    PoolClips.instance.releaseClip(this.clip);
    this.clip = null
};
SaberWeapon.prototype.update = function(a) {
    if (this.isAlive && this.clip) {
        this.clip.update(a);
        this.clip.position.x = this.x - this.world.m_camera.m_x;
        this.clip.position.y = this.y - this.world.m_camera.m_y;
        for (var b = this.world.m_actorManager.m_actors.length, c = 0, c = 0; c < b; c++) {
            var d = this.world.m_actorManager.m_actors[c];
            if (d.isEnemy && !d.isIdle && d.m_clip && this.clip.hitTest(d.m_clip)) d.onHit(this.damage, 0, 0)
        }
        if (this.isReturn) {
            if (this.angle = Math.atan2(this.world.m_player.m_y + SaberWeapon.OFFSET_Y - this.y, this.world.m_player.m_x -
                    this.x), this.vx = SaberWeapon.SPEED_RETURN * Math.cos(this.angle), this.vy = SaberWeapon.SPEED_RETURN * Math.sin(this.angle), this.x += this.vx * a, this.y += this.vy * a, 30 > Math.abs(this.world.m_player.m_x - this.x)) this.onStandBy()
        } else this.x < this.ox - this.range || this.x > this.ox + this.range ? this.isReturn = !0 : this.x += this.speed * a
    }
};
SaberWeapon.prototype.free = function() {
    PoolClips.instance.releaseClip(this.clip);
    this.skin = this.world = this.clip = null
};

function Spring(a, b, c, d, e, f, g) {
    d = b.getFloorCollision(c, d).y;
    WorldActor.call(this, a, b, c, d);
    this.m_type = g;
    this.m_params = Common.getParams(f);
    void 0 === e && (e = 0);
    this.m_rotation = e;
    this.m_character = new SimpleCharacter(c, d, a);
    this.m_character.addState(Spring.ST_SPRING_STAND, "spring_off");
    this.m_character.addState(Spring.ST_SPRING_RELEASE, "spring_on");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.m_character.worldActor = this;
    this.gotoState(Spring.ST_SPRING_STAND);
    this.updateBounds();
    this.m_clip.rotation =
        180 * e / Math.PI
}
Application.subclass(Spring, WorldActor);
Spring.ST_SPRING_STAND = "st01";
Spring.ST_SPRING_RELEASE = "st02";
Spring.prototype.onEndAnimation = function(a) {
    if (a == Spring.ST_SPRING_RELEASE || a == Spring.ST_SPRING_STAND) this.gotoState(Spring.ST_SPRING_STAND), this.m_clip.rotation = 180 * this.m_rotation / Math.PI
};
Spring.prototype.update = function(a) {
    this.m_character.update(a);
    switch (this.m_state) {
        case Spring.ST_SPRING_STAND:
            this.m_y + 5 >= this.m_world.m_player.m_y && this.m_world.m_player.m_state !== Player.ST_PLAYER_CELEBRATE && !this.m_world.m_player.waitingForCelebrate && this.m_world.player().m_state !== Player.ST_PLAYER_WIN && this.m_world.player().m_state !== Player.ST_PLAYER_LOSE && !PlayerSettings.instance.isInLiberation && this.m_world.player().hitTest(this) && (this.m_world.player().onSpringCollision(parseFloat(this.m_params.forceX),
                parseFloat(this.m_params.speedY), this.m_type, this), this.gotoState(Spring.ST_SPRING_RELEASE), Application.instance.playSound("SND_SPRING_ON"))
    }
    WorldActor.prototype.update.call(this, a)
};

function Missile(a) {
    this.m_world = a;
    this.clip = null;
    this.damage = 0;
    this.impactFx = this.m_skin = "";
    this.iniPos = {
        x: 0,
        y: 0
    };
    this.goalPos = {
        x: 0,
        y: 0
    };
    this.speed = {
        x: 0,
        y: 0
    };
    this.isDumb = !1;
    this.isIdle = !0;
    this.oldvY = this.angle = 0;
    this.fx = null
}
Missile.OFFSET_HEIGHT_BEFORE_FALL = 150;
Missile.AVERAGE_DT = 20;
Missile.prototype.setParams = function(a, b, c, d, e, f, g, h, k, m) {
    this.isIdle = !1;
    this.isDumb = h;
    this.angle = k || -1.57;
    this.damage = e;
    this.oldvY = 0;
    this.iniPos = {
        x: a,
        y: b
    };
    this.goalPos = {
        x: c,
        y: d
    };
    this.speed.x = Math.cos(this.angle) * g;
    this.speed.y = Math.sin(this.angle) * g;
    this.m_x = a;
    this.m_y = b;
    this.m_skin = f;
    this.impactFx = m;
    this.clip = PoolClips.instance.getClip(f);
    this.m_world.objectCanvas().addChild(this.clip);
    this.clip.visible = !1;
    this.fx = this.m_world.createEffect("aniFxBoss01Bullet02", this.m_x, this.m_y)
};
Missile.prototype.explode = function() {
    this.m_world.createEffect(this.impactFx, this.m_x, this.m_y);
    Global.game.onShake(3, 10, 300);
    Application.instance.playSound("SND_ENEMY_EXPLOSION");
    this.m_world.m_actorManager.bulletManager.moveMissileToPool(this);
    this.deactivate();
    this.fx && (this.fx.isAwaitingDelete = !0, this.fx = null)
};
Missile.prototype.doMovement = function(a) {
    this.m_x += this.speed.x;
    this.m_y += this.speed.y;
    this.oldvY = this.speed.y;
    this.speed.y += ParametricParabolicMovement.STD_GRAVITY * a;
    0 > this.oldvY && 0 <= this.speed.y && this.isDumb && (this.speed.x = (this.goalPos.x - this.m_x) / a);
    0 < this.speed.y && !this.isDumb && (this.speed.x = (this.m_world.m_player.m_x - this.m_x + (0 > this.speed.x ? -20 : 20)) / a * 2)
};
Missile.prototype.updateClip = function(a) {
    this.clip.position.x = this.m_x - this.m_world.m_camera.m_x;
    this.clip.position.y = this.m_y - this.m_world.m_camera.m_y;
    var b = Math.sqrt(this.speed.x * this.speed.x + this.speed.y * this.speed.y),
        b = Math.acos(this.speed.x / b),
        b = 0 > this.speed.y ? -b : b;
    this.clip.rotation = b;
    this.clip.update(a)
};
Missile.prototype.checkPlayerCollision = function() {
    100 > (this.m_world.m_player.m_x > this.m_x ? this.m_world.m_player.m_x - this.m_x : this.m_x - this.m_world.m_player.m_x) && this.clip.hitTest(this.m_world.m_player.m_clip) && (this.m_world.m_player.onBulletCollision(this, this.damage), this.explode())
};
Missile.prototype.update = function(a) {
    this.isIdle || (this.doMovement(a), this.updateClip(a), 30 >= this.goalPos.y - this.m_y && 0 < this.speed.y ? this.explode() : this.checkPlayerCollision());
    this.fx && (this.fx.x = this.m_x, this.fx.y = this.m_y)
};
Missile.prototype.deactivate = function() {
    PoolClips.instance.releaseClip(this.clip);
    this.isIdle = !0;
    this.clip.visible = !1
};
Missile.prototype.free = function() {
    this.clip && PoolClips.instance.releaseClip(this.clip);
    this.speed = this.goalPos = this.iniPos = this.m_world = null
};

function Wall(a, b, c, d, e, f) {
    SimpleWorldActor.call(this, a, b, c, d);
    this.m_params = Common.getParams(e);
    this.m_character = new SimpleCharacter(c, d, a);
    this.m_character.addState(Wall.ST_STAND, "mcObj_wall" + f);
    this.gotoState(Wall.ST_STAND);
    this.m_posLeftUpX = parseInt(this.m_params.leftUpX, 10);
    this.m_posLeftUpY = parseInt(this.m_params.leftUpY, 10);
    this.m_posBottomRightX = parseInt(this.m_params.bottomRightX, 10);
    this.m_posBottomRightY = parseInt(this.m_params.bottomRightY, 10);
    this.m_world.setRangeCollisionCell(this.m_posLeftUpX,
        this.m_posLeftUpY, this.m_posBottomRightX, this.m_posBottomRightY, WorldCollisionLayer.CELL_FULL, !0)
}
Application.subclass(Wall, SimpleWorldActor);
Wall.ST_STAND = "st01";
Wall.TYPE_WALL1 = 1;
Wall.TYPE_WALL2 = 2;
Wall.prototype.free = function() {
    this.m_world.setRangeCollisionCell(this.m_posLeftUpX, this.m_posLeftUpY, this.m_posBottomRightX, this.m_posBottomRightY, WorldCollisionLayer.CELL_EMPTY, !0);
    SimpleWorldActor.prototype.free.call(this)
};

function Token(a, b, c) {
    SimpleWorldActor.call(this, a, b, c.x, c.y);
    this.skin = "token";
    this.m_character = new SimpleCharacter(this.m_x, this.m_y, this.m_canvas);
    this.m_character.addState(Token.ST_STAND, this.skin + "_stand");
    this.m_character.addState(Token.ST_DISAPPEAR, this.skin + "_stand");
    this.gotoState(Token.ST_STAND)
}
Application.subclass(Token, SimpleWorldActor);
Token.ST_STAND = "st_101";
Token.ST_DISAPPEAR = "st_102";
Token.prototype.update = function(a) {
    SimpleWorldActor.prototype.update.call(this, a);
    switch (this.m_state) {
        case Token.ST_STAND:
            this.m_clip.hitTest(this.m_world.m_player.m_clip) && (Global.data.data.grabbedToken || (GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_TOKEN, HudPlatform.instance.addPopup(GuiPopupMessage, "mcGuiMessageToken")), Application.instance.playSound("SND_PICK_COIN"), Global.data.data.grabbedToken = !0, this.gotoState(Token.ST_DISAPPEAR), Global.data.dataArcade.coins++, Global.data.data.shouldSpawnTokens = !1, Global.data.save());
            break;
        case Token.ST_DISAPPEAR:
            this.m_clip.scale.x += Common.lerp(this.m_clip.scale.x, 2, 5, a), this.m_clip.scale.y += Common.lerp(this.m_clip.scale.y, 2, 5, a), this.m_clip.alpha += Common.lerp(this.m_clip.alpha, 0, 5, a), .1 >= this.m_clip.alpha && (this.isAwaitingDelete = !0)
    }
};

function Hostage(a, b, c, d) {
    SimpleWorldActor.call(this, a, b, c, d);
    this.skin = "chr_npc" + Common.randomInt(1, 6);
    this.m_character = new SimpleCharacter(this.m_x, this.m_y, this.m_canvas);
    this.m_character.addState(Hostage.ST_APPEAR, this.skin + "_appear");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.gotoState(Hostage.ST_APPEAR);
    a = Common.randomInt(1, 2);
    this.setFlipX(1 === a)
}
Application.subclass(Hostage, SimpleWorldActor);
Hostage.ST_APPEAR = "st_101";
Hostage.prototype.onEndAnimation = function(a) {
    switch (a) {
        case Hostage.ST_APPEAR:
            this.isAwaitingDelete = !0
    }
};
Hostage.prototype.update = function(a) {
    SimpleWorldActor.prototype.update.call(this, a)
};

function BaseEnemy(a, b, c, d, e) {
    this.m_npc = c;
    this.skin = "";
    this.isEnemy = !0;
    this.m_limits = this.m_data = null;
    this.m_oldState = 0;
    this.m_stateBeforeHit = BaseEnemy.ST_STAND;
    this.m_typeEnemy = e;
    this.m_isCollisionEnabled = !0;
    this.m_toLeft = !1;
    this.m_defaultViewLeft = !0;
    this.m_isInvulnerable = !1;
    this.settings(a, b, this.m_npc.x, this.m_npc.y, Common.getParams(this.m_npc.params), d);
    SimpleWorldActor.call(this, a, b, this.m_npc.x, this.m_limits.y);
    this.m_typeEnemy = e;
    this.canDamageToPlayer = !0;
    this.init();
    this.m_generator = null;
    this.m_probRespawn = 1;
    this.m_timeToRespawn = 3E3;
    this.wave = null
}
Application.subclass(BaseEnemy, SimpleWorldActor);
BaseEnemy.ST_STAND = "st100";
BaseEnemy.ST_WALK = "st101";
BaseEnemy.ST_ALERT = "st102";
BaseEnemy.ST_SHOOT = "st103";
BaseEnemy.ST_ATTACK = "st104";
BaseEnemy.ST_REST = "st107";
BaseEnemy.ST_RUN = "st108";
BaseEnemy.ST_HIT = "st301";
BaseEnemy.ST_DIE = "st302";
BaseEnemy.FRAME_CAN_HIT = 7;
BaseEnemy.ENEMY_GENERIC = 0;
BaseEnemy.ENEMY_BEAR = 1;
BaseEnemy.ENEMY_BOSS = 2;
BaseEnemy.prototype.init = function() {};
BaseEnemy.prototype.settings = function(a, b, c, d, e, f) {
    this.m_data = f;
    this.m_limits = new Rectangle(c, d)
};
BaseEnemy.prototype.setGenerator = function(a) {
    this.m_generator = a
};
BaseEnemy.prototype.setDefaultViewLeft = function(a) {
    this.m_defaultViewLeft = a
};
BaseEnemy.prototype.setState = function(a, b) {
    b = "undefined" !== typeof b ? b : !1;
    this.gotoState(a);
    this.setLookAtLeft(b)
};
BaseEnemy.prototype.setLookAtLeft = function(a) {
    this.m_toLeft = a;
    this.setFlipX(this.m_defaultViewLeft != this.m_toLeft)
};
BaseEnemy.prototype.proximityActivation = function() {
    if (this.m_world.player().isDead()) return !1;
    var a = this.m_world.player().getX() - this.m_x,
        b = this.m_world.player().getY() - this.m_y;
    return 0 <= b && 50 >= b && Math.abs(a) <= this.m_data.distanceAttack ? !0 : !1
};
BaseEnemy.prototype.onExpel = function() {
    if (!(this.m_state === BaseEnemy.ST_DIE && 25 < this.m_clip.currentFrame)) {
        this.isAwaitingDelete = !0;
        var a = this.m_world.m_player.m_x < this.m_x ? 0 : 3.14;
        Common.randomInt(30, 50);
        this.m_world.m_actorManager.bulletManager.createDummyBullet(this.skin + "_thrown_out", this.skin + "_die_wall", this.m_x, this.m_y - 30, a)
    }
};
BaseEnemy.prototype.onCheckCollisionPlayer = function() {
    if (!PlatformGame.playerUseExpel && this.hitCollisions(SimpleWorldActor.COLLISION, this.m_world.m_player, SimpleWorldActor.COLLISION_EXPEL)) PlatformGame.playerUseExpel = !0, this.onExpel(), Global.game.createExplotionShader(this.m_x - this.m_world.m_camera.m_x, this.m_y - this.m_world.m_camera.m_y - 60, 6);
    else {
        if (this.m_world.m_player.clipSpecialAttack && SDisplayObjectContainer.hitTestByBounds(this.m_clip, this.m_clip.getCollision(SimpleWorldActor.COLLISION), this.m_world.m_player.clipSpecialAttack,
                this.m_world.m_player.clipSpecialAttack.getCollision(SimpleWorldActor.COLLISION_SPECIAL)))
            if (Global.playerSelected === PlayerSettings.TYPE_KANAN || Global.playerSelected === PlayerSettings.TYPE_ZEB) this.onExpel();
            else this.onHit(100);
        if (this.hitCollisions(SimpleWorldActor.COLLISION, this.m_world.m_player, SimpleWorldActor.COLLISION_ATTACK)) {
            var a = 0,
                a = this.m_world.m_player.isJumpAttack() ? this.m_world.m_player.data.damageSpin : this.m_world.m_player.data.damageMelee;
            this.onHit(a) && this.m_world.createEffect("aniFxPlayerHit",
                this.m_x, this.m_y - 80);
            Global.game.onShake(4, 10, 200)
        } else if (this.m_world.m_player.checkCollisionShield(this.m_x, this.m_y) && this.canDamageToPlayer) this.onHit(0);
        else if (this.m_state !== BaseEnemy.ST_DIE && (a = SMath.abs(this.m_y - this.m_world.m_player.m_y), 75 > a && !PlatformGame.playerNearEnemy && (this.m_world.m_player.m_flipX && this.m_world.m_player.m_x > this.m_x && 300 > this.m_world.m_player.m_x - this.m_x ? PlatformGame.playerNearEnemy = !0 : !this.m_world.m_player.m_flipX && this.m_x > this.m_world.m_player.m_x && 300 > this.m_x -
                this.m_world.m_player.m_x && (PlatformGame.playerNearEnemy = !0))), this.canDamageToPlayer && this.m_state !== BaseEnemy.ST_HIT && this.m_state !== BaseEnemy.ST_DIE && 100 > a && this.m_world.m_player.m_clip.hitTest(this.m_clip)) this.m_world.player().onEnemyCollision(this, this.getCollDamage())
    }
};
BaseEnemy.prototype.getCollDamage = function() {
    return 0
};
BaseEnemy.prototype.onHit = function(a) {
    if (this.m_isInvulnerable || this.m_state === BaseEnemy.ST_DIE || this.m_state === BaseEnemy.ST_HIT && 0 !== this.m_clip.currentFrame % BaseEnemy.FRAME_CAN_HIT) return !1;
    this.m_health -= a;
    0 >= this.m_health ? (this.m_health = 0, this.setState(BaseEnemy.ST_DIE, this.m_toLeft)) : this.setState(BaseEnemy.ST_HIT, this.m_toLeft);
    return !0
};
BaseEnemy.prototype.update = function(a) {
    SimpleWorldActor.prototype.update.call(this, a);
    if (this.m_isCollisionEnabled) this.onCheckCollisionPlayer()
};
BaseEnemy.prototype.free = function() {
    this.m_generator && this.isAwaitingDelete && this.m_generator.notifyKill(this);
    this.m_limits = this.m_data = this.m_generator = null;
    SimpleWorldActor.prototype.free.call(this)
};

function Breakable(a, b, c) {
    this.m_health = 0;
    this.config = this.m_character = null;
    this.m_skin = "";
    this.drops = [];
    this.dropChances = [];
    this.isInvulnerable = !1;
    BaseEnemy.call(this, a, b, c, null, 0);
    this.canDamageToPlayer = !1;
    this.setupDrops();
    this.invulnerableTimer = 0
}
Application.subclass(Breakable, BaseEnemy);
Breakable.ST_STAND = "st_101";
Breakable.ST_STAND_DAMAGED = "st_102";
Breakable.ST_HIT = "st_103";
Breakable.ST_DIE = "st_104";
Breakable.GET_DAMAGE_DELAY = 200;
Breakable.prototype.init = function() {
    this.m_skin = "box" + this.m_npc.type;
    this.config = this.getConfig("Breakable");
    this.m_health = this.config.health;
    this.m_character = new SimpleCharacter(this.m_npc.x, this.m_npc.y, this.m_canvas);
    this.m_character.addState(Breakable.ST_STAND, this.m_skin + "_stand");
    this.m_character.addState(Breakable.ST_STAND_DAMAGED, this.m_skin + "_stand_2");
    this.m_character.addState(BaseEnemy.ST_HIT, this.m_skin + "_hit");
    this.m_character.addState(BaseEnemy.ST_DIE, this.m_skin + "_break");
    this.setState(Breakable.ST_STAND,
        .5 < Math.random());
    this.m_character.onEndAnimation(this, this.onEndAnimation)
};
Breakable.prototype.setupDrops = function() {
    var a = this.m_npc.dropArray.split(";");
    this.m_npc.dropChances.split(";");
    for (var b = 0; b < a.length; b++) {
        parseInt(a[b], 10);
        var c = !0;
        PlayerSettings.instance.isPlayerMelee() && window.config.items[a[b]].use === ItemWorld.USE_RANGE && (c = !1);
        PlayerSettings.instance.isPlayerRange() && window.config.items[a[b]].use === ItemWorld.USE_MEELE && (c = !1);
        c && (this.drops.push(parseInt(a[b], 10)), this.dropChances.push(parseInt(a[b], 10)))
    }
};
Breakable.prototype.onEndAnimation = function(a) {
    switch (a) {
        case BaseEnemy.ST_HIT:
            this.isInvulnerable = !1;
            this.invulnerableTimer = 0;
            this.gotoState(Breakable.ST_STAND_DAMAGED);
            break;
        case BaseEnemy.ST_DIE:
            this.isAwaitingDelete = !0
    }
};
Breakable.prototype.update = function(a) {
    BaseEnemy.prototype.update.call(this, a);
    this.isInvulnerable && (this.invulnerableTimer += a, this.invulnerableTimer >= Breakable.GET_DAMAGE_DELAY && (this.isInvulnerable = !1, this.invulnerableTimer = 0))
};
Breakable.prototype.onHit = function(a) {
    if (this.m_state === BaseEnemy.ST_DIE || this.isInvulnerable) return !1;
    this.isInvulnerable = !0;
    this.m_health -= a;
    0 >= this.m_health ? (this.m_health = 0, this.makeDrop(), this.gotoState(BaseEnemy.ST_DIE), Application.instance.playSound("SND_BREAKABLE_ONBREAK")) : (this.gotoState(BaseEnemy.ST_HIT), Application.instance.playSound("SND_BREAKABLE_ONHIT"));
    return !0
};
Breakable.prototype.onExpel = function() {
    this.onHit(this.m_health)
};
Breakable.prototype.getConfig = function(a) {
    for (var b = Application.config.hazards, c = 0; c < b.length; c++)
        if (b[c].type === a) return b[c]
};
Breakable.prototype.makeDrop = function() {
    for (var a = [], b = 0; b < this.dropChances.length; b++) 0 != this.dropChances[b] && Math.random() <= this.dropChances[b] && a.push(this.drops[b]);
    0 < a.length ? (b = Common.randomInt(0, a.length - 1), this.m_world.m_actorManager.addDrop(this.m_x, this.m_y, a[b])) : this.m_world.m_actorManager.addDrop(this.m_x, this.m_y, 1)
};

function HudPlatform(a, b, c) {
    SScreen.call(this, a, b, c);
    HudPlatform.instance = this;
    this.canvas.hitArea = null;
    this.collectiblesDisabled = this.showSpecialBar = this.canvas.interactive = !1;
    this.offsetXTimer = 0;
    MissionManager.instance.isMissionBossBattle() && (this.offsetXTimer = 50);
    this.getControl("mcGuiTimerBase").setOx(this.getControl("mcGuiTimerBase").getOx() - this.offsetXTimer);
    this.getControl("mcGuiTimerCountBack").setOx(this.getControl("mcGuiTimerCountBack").getOx() - this.offsetXTimer);
    this.clipAttack = this.getControl("mcGuiKeyAttack");
    this.clipJump = this.getControl("mcGuiKeyJump");
    this.clipSpecial = this.getControl("mcGuiKeySpecial");
    this.m_clipHpBar = this.getControl("mcGuiHpbar").clip;
    this.m_clipSpecialBar = this.getControl("mcGuiSpecialBar").clip;
    this.m_clipBossHpBar = this.getControl("mcGuiBossHpbar").clip;
    this.m_clipSpecialBarMobile = this.getControl("mcGuiBarspecial").clip;
    this.getControl("mcGuiFxCounter").clip.onEndAnimation(this, this.onEndCounterEffect);
    this.getControl("mcGuiFxCounter").clip.gotoAndStop(1);
    this.m_textCollectibles =
        this.getControl("mcGuiTextCollectibles");
    this.m_textCollectibles2 = this.getControl("mcGuiTextCollectibles_2");
    this.m_textCollectibles2.setTextEmpty();
    this.m_textTimer = this.getControl("mcGuiTextTimer");
    this.getControl("mcGuiBg").setVisible(!1);
    this.getControl("mcGuiTransition").setVisible(!1);
    this.getControl("mcGuiKeyArrowR").setVisible(!1);
    this.getControl("mcGuiKeyArrowL").setVisible(!1);
    this.getControl("mcGuiBarspecial").setVisible(!1);
    this.getControl("mcGuiBtnSkip").setVisible(!1);
    this.getControl("mcGuiFxTimer").setVisible(!1);
    this.hideP2Counter();
    this.deviceControlsScale = 1.125;
    Application.instance.isMobileDevice ? this.updateControls() : (this.clipAttack.setVisible(!1), this.clipJump.setVisible(!1), this.clipSpecial.setVisible(!1));
    this.isTimerHidden = this.isPowerUpActive = this.isBleedingOut = this.isTimingOut = !1;
    this.oldSeconds = 0;
    this.hpBarHeal = this.specialFull = this.m_game = this.onTransitionEndCaller = this.onTransitionEndCallback = this.currentFinger = this.transition = null;
    this.specialReadyToUse = !0;
    this.reminderPopup = this.tooltip = this.warningPopup =
        null;
    this.transitionTimer = 0;
    this.onTransition = !1;
    this.m_initControlPos = {};
    for (var d in this.controls) this.m_initControlPos[d] = this.controls[d].getOx() / Application.APP_WIDTH;
    this.childrenControl = [];
    this.frozeControls = [];
    this.clipsByAnimation = [];
    this.setInitialPos();
    this.setupChildren();
    this.fixGameScale();
    this.alertBkgVisible = this.hudIsEnabling = !1;
    this.tutorialFingertimer = this.specialReminderTimer = this.tutorialTimer = this.ppType = 0;
    this.warningTimerClip = this.getControl("mcGuiTimerCountBack").clip;
    this.warningTimerClip.gotoAndStop(30);
    this.getControl("mcGuiTimerCountBack").setVisible(!1);
    this.doFastEnergy = !1;
    this.fastEnergyTimer = this.fastEnergyTime = 0;
    this.showAttack = !1;
    this.circleMask = new CircleMask(850);
    this.circleMask.position.x = .5 * Application.APP_WIDTH;
    this.circleMask.position.y = .5 * Application.APP_HEIGHT;
    this.canvas.addChild(this.circleMask);
    this.tutorialClips = [];
    this.xLocalized = null;
    this.tutorialClips.specialKey = {
        clip: PoolClips.instance.getClip("mcGuiTutorialsSpecial"),
        position: {
            x: 0,
            y: 0
        },
        offset: {
            x: 0,
            y: 0
        },
        isAwaitingRemove: !1,
        isActive: !1
    };
    this.tutorialClips.attackKey = {
        clip: PoolClips.instance.getClip("mcGuiTutorialsSpacebar"),
        position: {
            x: 0,
            y: 0
        },
        offset: {
            x: 0,
            y: 0
        },
        isAwaitingRemove: !1,
        isActive: !1
    };
    this.xLocalized = Application.instance.getLocalizedImage("gui_localized_tutorial_x.png");
    this.xLocalized.position.y = -15;
    MissionManager.instance.isMissionTutorial() && (this.getControl("mcGuiFxSpecial").clip.gotoAndStop(1), this.tutorialClips.arrow = {
        clip: PoolClips.instance.getClip("mcGuiTutorials_StartSignal"),
        position: {
            x: 0,
            y: 0
        },
        offset: {
            x: 0,
            y: 0
        },
        isAwaitingRemove: !1,
        isActive: !1
    }, this.tutorialClips.jump = {
        clip: PoolClips.instance.getClip("mcGuiTutorials_JumpSignal"),
        position: {
            x: 2200,
            y: 4125
        },
        offset: {
            x: 200,
            y: -100
        },
        isAwaitingRemove: !1,
        isActive: !1
    }, this.tutorialClips.doubleJump = {
        clip: PoolClips.instance.getClip("mcGuiTutorials_JumpSignal"),
        position: {
            x: 0,
            y: 0
        },
        offset: {
            x: 120,
            y: -180
        },
        isAwaitingRemove: !1,
        isActive: !1
    }, Application.instance.isMobileDevice || (this.tutorialClips.moveKey = {
        clip: PoolClips.instance.getClip("mcGuiTutorialsDirectionalStart"),
        position: {
            x: 0,
            y: 0
        },
        offset: {
            x: 0,
            y: 0
        },
        isAwaitingRemove: !1,
        isActive: !1
    }, this.tutorialClips.jumpKey = {
        clip: PoolClips.instance.getClip("mcGuiTutorialsDirectional"),
        position: {
            x: 0,
            y: 0
        },
        offset: {
            x: 0,
            y: 0
        },
        isAwaitingRemove: !1,
        isActive: !1
    }))
}
Application.subclass(HudPlatform, SScreen);
HudPlatform.TUTORIAL_POPUP_TIME = 5E3;
HudPlatform.TUTORIAL_FINGER_TIME = 1E3;
HudPlatform.prototype.showXKeyTutorial = function() {
    this.tutorialClips.attackKey && this.tutorialClips.attackKey.isActive && (this.tutorialClips.attackKey.isAwaitingRemove = !0);
    this.tutorialClips.specialKey && this.xLocalized && !this.tutorialClips.specialKey.isActive && (this.specialReminderTimer = 0, this.tutorialClips.specialKey.isActive = !0, this.canvas.addChild(this.tutorialClips.specialKey.clip), this.canvas.addChild(this.xLocalized), this.tutorialClips.specialKey.clip.position.x = .5 * Global.game.world.m_camera.fixWidthRatio -
        Global.game.world.m_camera.fixOffsetX, this.tutorialClips.specialKey.clip.position.y = .8 * Global.game.world.m_camera.m_height, this.xLocalized.position.x = this.tutorialClips.specialKey.clip.position.x - .5 * this.xLocalized._texture.baseTexture.realWidth, this.xLocalized.alpha = .4, this.xLocalized.position.y = this.tutorialClips.specialKey.clip.position.y - 7 - .5 * this.xLocalized._texture.baseTexture.realHeight)
};
HudPlatform.prototype.updateControls = function() {
    PlayerSettings.instance.isPlayerMelee() ? this.clipAttack.setClip("mcGuiButtonControlJediAttack") : this.clipAttack.setClip("mcGuiButtonControlAttack")
};
HudPlatform.prototype.onEndCounterEffect = function() {
    this.m_textCollectibles.canvas.scale.x = 1;
    this.m_textCollectibles.canvas.scale.y = 1;
    this.getControl("mcGuiFxCounter").clip.gotoAndStop(1);
    this.getControl("mcGuiFxCounter2").clip.gotoAndStop(1);
    switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            MissionManager.instance.isMissionRequirementComplete() && (GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_RETURN_EXTRACTION, HudPlatform.instance.addPopup(GuiPopupMessage,
                "mcGuiMessageMissionUpdate"), Global.game.world.actorManager().toggleExtractionPoints(!0));
            break;
        case MissionManager.MISSION_LIBERATION:
            MissionManager.instance.isMissionRequirementComplete() && (GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_RETURN_EXTRACTION, HudPlatform.instance.addPopup(GuiPopupMessage, "mcGuiMessageMissionUpdate"), Global.game.world.actorManager().toggleExtractionPoints(!0));
            break;
        case MissionManager.MISSION_SABOTAGE:
            MissionManager.instance.isCooperative() ? PlayerSettings.instance.hasSabotagedAll() &&
                PlayerSettings.instance.hasSabotagedAllCoop() && (GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_RETURN_IMPERIALANTENNA, HudPlatform.instance.addPopup(GuiPopupMessage, "mcGuiMessageMissionUpdateAntenna"), Global.game.world.actorManager().updateAntenna()) : PlayerSettings.instance.hasSabotagedAll() && (GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_RETURN_IMPERIALANTENNA, HudPlatform.instance.addPopup(GuiPopupMessage, "mcGuiMessageMissionUpdateAntenna"), Global.game.world.actorManager().updateAntenna())
    }
};
HudPlatform.prototype.setActiveAlertBackground = function(a) {
    this.getControl("mcGuiBg").setVisible(a);
    this.alertBkgVisible = a
};
HudPlatform.prototype.doTimerScaleLerp = function(a) {
    var b = this.warningTimerClip.scale.x;
    this.warningTimerClip.scale.x += Common.lerp(b, 1, 2.5, a);
    this.warningTimerClip.scale.y += Common.lerp(b, 1, 2.5, a)
};
HudPlatform.prototype.initData = function() {
    MissionManager.instance.isMissionBossBattle() ? this.getControl("mcGuiTextCollectiblesPlayer").setTextEmpty() : this.getControl("mcGuiBossName").setTextEmpty();
    if (PlayerSettings.instance.isMultiplayer()) {
        var a = Global.playersForGame[PlayerSettings.instance.getCurrentTurn() - 1];
        this.getControl("mcGuiCharacter").clip.gotoAndStop(a);
        this.getControl("mcGuiName").setTextLocalized("STR_SELECTCHARACTER_0" + a);
        this.getControl("mcGuiTxtTag").setTextLocalized("STR_SELECTCHARACTER_P" +
            PlayerSettings.instance.getCurrentTurn())
    } else this.getControl("mcGuiCharacter").clip.gotoAndStop(Global.playerSelected), this.getControl("mcGuiName").setTextLocalized("STR_SELECTCHARACTER_0" + Global.playerSelected), this.getControl("mcGuiTxtTag").setTextEmpty();
    this.getControl("mcGuiTextTimerPlayer").setTextEmpty()
};
HudPlatform.prototype.fixGameScale = function() {
    var a = Layout.aspectRatio / Layout.minAspectRatio * Application.APP_WIDTH,
        b = Application.APP_WIDTH * (1 - Layout.aspectRatio / Layout.minAspectRatio) * .5;
    if (Application.WIDE_SCREEN) {
        for (var c in this.controls) "mcGuiTransition" !== this.controls[c].name && "undefined" === typeof this.childrenControl[this.controls[c].name] && this.controls[c].setOx(this.m_initControlPos[c] * a + b);
        this.setChildrenOxWithParent()
    }
};
HudPlatform.prototype.setupChildren = function() {
    for (var a in this.controls) {
        var b = this.controls[a];
        switch (b.name) {
            case "mcGuiKeyArrowR":
                this.childrenControl[b.name] = {
                    offsetX: b.getOx() - this.getControl("mcGuiKeyArrowL").getOx(),
                    child: b,
                    parent: this.getControl("mcGuiKeyArrowL")
                };
                break;
            case "mcGuiKeySpecial":
            case "mcGuiBarspecial":
            case "mcGuiKeyAttack":
                this.childrenControl[b.name] = {
                    offsetX: b.getOx() - this.getControl("mcGuiKeyJump").getOx(),
                    child: b,
                    parent: this.getControl("mcGuiKeyJump")
                };
                break;
            case "mcGuiTag":
            case "mcGuiTxtTag":
            case "mcGuiName":
            case "mcGuiPowerupFx":
            case "mcGuiPowerup1":
            case "mcGuiPowerupBase":
                this.childrenControl[b.name] = {
                    offsetX: b.getOx() - this.getControl("mcGuiBase").getOx(),
                    child: b,
                    parent: this.getControl("mcGuiBase")
                };
                break;
            case "mcGuiTextTimer":
            case "mcGuiTimerIcon":
                this.childrenControl[b.name] = {
                    offsetX: b.getOx() - this.getControl("mcGuiTimerBase").getOx() - this.offsetXTimer,
                    child: b,
                    parent: this.getControl("mcGuiTimerBase")
                };
                break;
            case "mcGuiCounterSupply":
            case "mcGuiFxCounter":
            case "mcGuiFxCounter2":
            case "mcGuiTextCollectibles":
                this.childrenControl[b.name] = {
                    offsetX: b.getOx() - this.getControl("mcGuiCounterBase").getOx(),
                    child: b,
                    parent: this.getControl("mcGuiCounterBase")
                };
                break;
            case "mcGuiTextCollectibles_2":
            case "mcGuiTextCollectiblesPlayer":
                this.childrenControl[b.name] = {
                    offsetX: b.getOx() - this.getControl("mcGuiCounter2Base").getOx(),
                    child: b,
                    parent: this.getControl("mcGuiCounter2Base")
                };
                break;
            case "mcGuiBossName":
            case "mcGuiBoss":
            case "mcGuiBossHpbar":
                this.childrenControl[b.name] = {
                    offsetX: b.getOx() - this.getControl("mcGuiBossBase").getOx(),
                    child: b,
                    parent: this.getControl("mcGuiBossBase")
                }
        }
    }
};
HudPlatform.prototype.setChildrenOxWithParent = function() {
    for (var a in this.childrenControl) this.childrenControl[a].child.setOx(this.childrenControl[a].parent.getOx() + this.childrenControl[a].offsetX)
};
HudPlatform.prototype.startTimingOut = function() {
    this.getControl("mcGuiTimerCountBack").setVisible(this.getControl("mcGuiTimerBase").canvas.visible);
    this.warningTimerClip.scale.x = 1.5;
    this.warningTimerClip.scale.y = 1.5;
    this.getControl("mcGuiTimerBase").setVisible(!1);
    this.getControl("mcGuiTextTimer").setTextEmpty();
    this.getControl("mcGuiTimerIcon").setVisible(!1);
    this.isTimingOut = !0;
    Application.instance.playSound("SND_UI_TIMER_ALERT")
};
HudPlatform.prototype.removeTimingOut = function() {
    this.isTimingOut = !1;
    this.getControl("mcGuiTimerCountBack").setVisible(!1)
};
HudPlatform.prototype.stopTimingOut = function() {
    this.isTimingOut = !1
};
HudPlatform.prototype.activatePowerup = function(a) {
    this.setPowerUpFxState(1);
    this.isPowerUpActive = !0;
    this.getControl("mcGuiPowerupFx").setVisible(this.isHudEnabled);
    this.getControl("mcGuiPowerupBase").setVisible(this.isHudEnabled);
    switch (a) {
        case ItemWorld.TYPE_SHIELD:
            this.getControl("mcGuiPowerup1").setClip("mcItemShield_hud");
            break;
        case ItemWorld.TYPE_PU_STRIKEWAVE:
            this.getControl("mcGuiPowerup1").setClip("gui_hud_powerup_strikewave");
            break;
        case ItemWorld.TYPE_PU_PERFECTDEFLECT:
            this.getControl("mcGuiPowerup1").setClip("gui_hud_powerup_deflect");
            break;
        case ItemWorld.TYPE_PU_MULTIBLASTER:
            this.getControl("mcGuiPowerup1").setClip("gui_hud_powerup_sonicblaster");
            break;
        case ItemWorld.TYPE_PU_EXPLOSIVEBLASTER:
            this.getControl("mcGuiPowerup1").setClip("gui_hud_powerup_deathtrooperblaster")
    }
    this.ppType = a;
    this.getControl("mcGuiPowerup1").setVisible(this.isHudEnabled)
};
HudPlatform.prototype.removePowerUp = function(a) {
    this.ppType === a && (this.isPowerUpActive = !1, this.getControl("mcGuiPowerupFx").setVisible(!1), this.getControl("mcGuiPowerup1").setVisible(!1), this.getControl("mcGuiPowerupBase").setVisible(!1))
};
HudPlatform.prototype.enableControls = function(a) {
    this.getControl("mcGuiFxHpAlert").setVisible(!1);
    this.getControl("mcGuiPowerupFx").setVisible(!1);
    this.getControl("mcGuiPowerup1").setVisible(!1);
    this.getControl("mcGuiPowerupBase").setVisible(!1);
    this.getControl("mcGuiFxSpecialAlert").setVisible(!1);
    this.getControl("mcGuiFxSpecial").setVisible(!1);
    this.getControl("mcGuiBtnSkip").setVisible(!1);
    this.getControl("mcGuiTimerCountBack").setVisible(!1);
    this.getControl("mcGuiTimerIcon").setVisible(!1);
    this.getControl("mcGuiTimerBase").setVisible(!1);
    this.getControl("mcGuiTimer2Base").setVisible(!1);
    this.getControl("mcGuiBoss").setVisible(!1);
    this.getControl("mcGuiBossBase").setVisible(!1);
    this.getControl("mcGuiBossHpbar").setVisible(!1);
    this.getControl("mcGuiCounterSupply").setVisible(!1);
    this.getControl("mcGuiCounterBase").setVisible(!1);
    this.getControl("mcGuiSpecialBar").setVisible(!1);
    this.getControl("mcGuiFxCounter2").setVisible(!1);
    MissionManager.instance.isMissionTutorial() && (this.getControl("mcGuiBase").clip.specialBar.visible = !1);
    this.m_textCollectibles.canvas.visible =
        a && !this.collectiblesDisabled;
    this.getControl("mcGuiFxCounter").setVisible(a);
    this.getControl("mcGuiFxCounter2").setVisible(a);
    PlatformGame.instance.basicStick && (PlatformGame.instance.basicStick.canvas.visible = a);
    a && (MissionManager.instance.isMissionTutorial() ? (this.getControl("mcGuiSpecialBar").setVisible(this.showSpecialBar), this.getControl("mcGuiBase").clip.specialBar.visible = this.showSpecialBar) : this.getControl("mcGuiSpecialBar").setVisible(!0), this.getControl("mcGuiFxHpAlert").setVisible(this.isBleedingOut),
        this.getControl("mcGuiPowerupFx").setVisible(this.isPowerUpActive), this.getControl("mcGuiPowerup1").setVisible(this.isPowerUpActive), this.getControl("mcGuiPowerupBase").setVisible(this.isPowerUpActive), this.getControl("mcGuiFxSpecialAlert").setVisible(MissionManager.instance.isMissionTutorial() ? !1 : 99 === this.getControl("mcGuiSpecialBar").clip.currentFrame), this.getControl("mcGuiBtnSkip").setVisible(MissionManager.instance.isMissionTutorial()), this.getControl("mcGuiTimerCountBack").setVisible(this.isTimingOut),
        MissionManager.instance.isMissionTutorial() || this.setActiveTimer(!this.isTimerHidden));
    for (var b = 0; b < this.clipsByAnimation.length; b++) this.clipsByAnimation[b].clip.visible = a;
    PlayerSettings.instance.isMultiplayer() ? (this.getControl("mcGuiTag").setVisible(a), a && this.getControl("mcGuiTag").clip.gotoAndStop(PlayerSettings.instance.getCurrentTurn())) : this.getControl("mcGuiTag").setVisible(!1);
    this.getControl("mcGuiBase").setVisible(a);
    this.getControl("mcGuiHpbar").setVisible(a);
    this.getControl("mcGuiBtnPause").setVisible(a);
    this.getControl("mcGuiCharacter").setVisible(a);
    MissionManager.instance.isCooperative() && PlayerSettings.instance.isLastMultiplayerPlayer();
    switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            if (this.collectiblesDisabled) this.disableCollectibles();
            else if (this.getControl("mcGuiCounterSupply").setVisible(a), this.getControl("mcGuiCounterBase").setVisible(a), a) {
                b = "";
                switch (PlayerSettings.instance.m_collectSkin) {
                    case 1:
                        b = "gui_supplies_weapons4";
                        break;
                    case 2:
                        b = "gui_supplies_weapons2";
                        break;
                    case 3:
                        b = "gui_supplies_bacta";
                        break;
                    case 4:
                        b = "gui_supplies_weapons3";
                        break;
                    case 5:
                        b = "gui_supplies_food";
                        break;
                    case 6:
                        b = "gui_supplies_weapons1"
                }
                this.getControl("mcGuiCounterSupply").setClip(b)
            }
            break;
        case MissionManager.MISSION_LIBERATION:
            this.collectiblesDisabled ? this.disableCollectibles() : (this.getControl("mcGuiCounterSupply").setVisible(a), this.getControl("mcGuiCounterBase").setVisible(a), a && this.getControl("mcGuiCounterSupply").setClip("gui_supplies_base"));
            break;
        case MissionManager.MISSION_SABOTAGE:
            this.collectiblesDisabled ?
                this.disableCollectibles() : (this.getControl("mcGuiCounterSupply").setVisible(a), this.getControl("mcGuiCounterBase").setVisible(a), a && this.getControl("mcGuiCounterSupply").setClip("gui_supplies_machine"));
            break;
        case MissionManager.MISSION_BOSS_BATTLE:
            this.getControl("mcGuiBoss").setVisible(a), this.getControl("mcGuiBoss").clip.gotoAndStop(Global.level), this.getControl("mcGuiBossBase").setVisible(a), this.getControl("mcGuiBossHpbar").setVisible(a), a && this.getControl("mcGuiBossName").setTextLocalized("STR_SELECTBOSS_0" +
                Global.level)
    }
    this.enableMobileControls(a);
    this.isTimingOut && (this.getControl("mcGuiTimerBase").setVisible(!1), this.getControl("mcGuiTextTimer").setTextEmpty(), this.getControl("mcGuiTimerIcon").setVisible(!1));
    PlayerSettings.instance.isLastMultiplayerPlayer() && MissionManager.instance.isMissionSabotage() && MissionManager.instance.isCooperative() && (PlatformGame.instance.world.m_actorManager.m_antenna && !PlatformGame.instance.world.m_actorManager.m_antenna.isShielded || !PlatformGame.instance.world.m_actorManager.m_antenna) &&
        this.disableCollectibles()
};
HudPlatform.prototype.enableMobileControls = function(a) {
    Application.instance.isMobileDevice && (MissionManager.instance.isMissionTutorial() ? (this.getControl("mcGuiBarspecial").setVisible(this.showSpecialBar && a && this.specialReadyToUse), this.getControl("mcGuiKeySpecial").setVisible(this.showSpecialBar && a && this.specialReadyToUse), this.clipAttack.setVisible(a && this.showAttack), this.clipJump.setVisible(a)) : (this.clipAttack.setVisible(a), this.clipJump.setVisible(a), this.getControl("mcGuiBarspecial").setVisible(a && !this.specialReadyToUse),
        this.getControl("mcGuiKeySpecial").setVisible(a && this.specialReadyToUse)), PlatformGame.instance.basicStick && (PlatformGame.instance.basicStick.canvas.visible = a))
};
HudPlatform.prototype.enableHud = function(a) {
    var b = (this.isHudEnabled = a) ? 1 : 0,
        c;
    for (c in this.controls) "mcGuiKeySpecial" === this.controls[c].name || "mcGuiKeyAttack" === this.controls[c].name || "mcGuiKeyJump" === this.controls[c].name || "mcGuiKeyArrowR" === this.controls[c].name || "mcGuiKeyArrowL" === this.controls[c].name || this.controls[c].clip || ("mcGuiTextTimer" === this.controls[c].name ? (a && (b = PlatformGame.instance.timerCanBeChanged() ? 1 : 0), this.controls[c].setAlpha(b)) : this.controls[c].setAlpha(a));
    this.enableControls(a)
};
HudPlatform.prototype.setHudAnimation = function() {
    this.enableHud(!0);
    this.hudIsEnabling = !0;
    this.canvas.position.y = -400;
    this.reposFrozenControls(-this.canvas.position.y);
    this.enableMobileControls(!1)
};
HudPlatform.prototype.free = function() {
    this.reminderPopup && this.reminderPopup.free();
    this.warningPopup && this.warningPopup.free();
    this.m_textTimer = this.m_textCollectibles2 = this.m_textCollectibles = this.m_clipBossHpBar = this.m_clipHpBar = this.clipSpecial = this.clipJump = this.clipAttack = HudPlatform.instance = null;
    SScreen.prototype.free.call(this)
};
HudPlatform.prototype.showTeleportButton = function(a) {};
HudPlatform.prototype.onDebugDraw = function(a) {};
HudPlatform.prototype.activateWarningMessage = function() {
    this.warningPopup = new GuiPopupWarningLiberation("mcGuiMessageWarning", this)
};
HudPlatform.prototype.onUIPress = function(a) {
    if (GuiGame.instance) switch (a.name) {
        case "mcGuiBtnSkip":
            GuiPopupQuit.typeMessage = GuiPopupQuit.TUTORIAL;
            GuiGame.instance.addPopup(GuiPopupQuit, "mcGuiPopupQuit", 0, 0);
            Application.instance.playSound("SND_UI_CLICK");
            break;
        case "mcGuiBtnPause":
            GuiGame.instance.addPopup(GuiPopupPause, "mcGuiPopupPause", 0, 0);
            Application.instance.playSound("SND_UI_CLICK");
            break;
        case "mcGuiKeyAttack":
            PlatformGame.instance.world.player().onKeyDown(PlayerPlatform.KEY_ATTACK);
            break;
        case "mcGuiKeyJump":
            PlatformGame.instance.world.player().onKeyDown(PlayerControl.CMD_UP_A);
            break;
        case "mcGuiKeySpecial":
            PlatformGame.instance.world.player().onKeyDown(PlayerPlatform.KEY_BOMB)
    }
};
HudPlatform.prototype.onUIRelease = function(a) {
    switch (a.name) {
        case "mcGuiKeyAttack":
            PlatformGame.instance.world.player().onKeyUp(PlayerPlatform.KEY_ATTACK);
            break;
        case "mcGuiKeyJump":
            PlatformGame.instance.world.player().onKeyUp(PlayerControl.CMD_UP_A);
            break;
        case "mcGuiKeySpecial":
            PlatformGame.instance.world.player().onKeyUp(PlayerPlatform.KEY_BOMB)
    }
};
HudPlatform.prototype.enableTimer = function(a) {
    this.m_textTimer.setAlpha(a ? 1 : 0);
    this.getControl("mcGuiTimerIcon").setVisible(a);
    this.getControl("mcGuiTimerBase").setVisible(a)
};
HudPlatform.prototype.setTimer = function(a) {
    if (!this.isTimerHidden) {
        var b = Math.floor(a / 1E3);
        a = Math.floor(b / 60);
        b %= 60;
        this.isTimingOut ? this.oldSeconds !== b && (Application.instance.playSound("SND_TIMER_COUNTDOWN"), this.warningTimerClip.gotoAndStop(b + 1), this.warningTimerClip.scale.x = 1.5, this.warningTimerClip.scale.y = 1.5, this.oldSeconds = b) : this.m_textTimer.setText((10 > a ? "0" + a : a) + ":" + (10 > b ? "0" + b : b))
    }
};
HudPlatform.prototype.setActiveTimer = function(a) {
    this.isTimingOut ? this.getControl("mcGuiTimerCountBack").setVisible(a && !PlayerSettings.instance.isInLiberation) : (this.getControl("mcGuiTextTimer").setTextEmpty(), this.getControl("mcGuiTimerBase").setVisible(a && !PlayerSettings.instance.isInLiberation), this.getControl("mcGuiTimerIcon").setVisible(a && !PlayerSettings.instance.isInLiberation));
    this.isTimerHidden = !a || PlayerSettings.instance.isInLiberation
};
HudPlatform.prototype.disableCollectibles = function() {
    this.collectiblesDisabled = !0;
    this.getControl("mcGuiCounterBase").setVisible(!1);
    this.getControl("mcGuiCounterSupply").setVisible(!1);
    this.m_textCollectibles.setTextEmpty()
};
HudPlatform.prototype.setCollectibles = function(a, b) {
    this.collectiblesDisabled || !this.isHudEnabled ? (this.m_textCollectibles.setAlpha(0), this.onEndCounterEffect()) : (this.getControl("mcGuiFxCounter").clip.resume(), this.m_textCollectibles.canvas.scale.x = 1.4, this.m_textCollectibles.canvas.scale.y = 1.4);
    this.m_textCollectibles.setText(a + "/" + b)
};
HudPlatform.prototype.codedByAnimationCollectibles = function(a, b) {
    var c = null,
        d = {
            x: 0,
            y: 0
        };
    switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            c = PoolClips.instance.getClip("gui_hud_pointer_collect_0" + PlayerSettings.instance.m_collectSkin);
            d = {
                x: this.getControl("mcGuiCounterSupply").canvas.position.x,
                y: this.getControl("mcGuiCounterSupply").canvas.position.y
            };
            break;
        case MissionManager.MISSION_LIBERATION:
            c = PoolClips.instance.getClip("gui_hud_pointer_door");
            d = {
                x: this.getControl("mcGuiCounterSupply").canvas.position.x,
                y: this.getControl("mcGuiCounterSupply").canvas.position.y
            };
            break;
        case MissionManager.MISSION_SABOTAGE:
            c = PoolClips.instance.getClip("gui_hud_pointer_imperial"), d = {
                x: this.getControl("mcGuiCounterSupply").canvas.position.x,
                y: this.getControl("mcGuiCounterSupply").canvas.position.y
            }
    }
    c.position.x = PlatformGame.instance.world.player().m_x - PlatformGame.instance.world.m_camera.m_x;
    c.position.y = PlatformGame.instance.world.player().m_y - PlatformGame.instance.world.m_camera.m_y;
    this.canvas.addChild(c);
    this.clipsByAnimation.push({
        clip: c,
        goal: d,
        type: -1,
        found: a,
        total: b
    })
};
HudPlatform.prototype.setCollectiblesCoop = function(a, b) {
    this.m_textCollectibles.canvas.visible && (this.getControl("mcGuiFxCounter").clip.resume(), this.m_textCollectibles.canvas.scale.x = 1.4, this.m_textCollectibles.canvas.scale.y = 1.4);
    this.m_textCollectibles.setText(a + "/" + b)
};
HudPlatform.prototype.enableTextCollectiblesCoop = function(a) {
    this.m_textCollectibles2.setAlpha(a ? 1 : 0)
};
HudPlatform.prototype.codedPickupAnimation = function(a) {
    var b = null,
        c = {
            x: 0,
            y: 0
        };
    switch (a) {
        case ItemWorld.TYPE_SHIELD:
            c = PoolClips.instance.getClip("mcItemShield_hud");
            b = PoolClips.instance.getClip("gui_hud_powerup_cooldown_base");
            b.addChild(c);
            c = {
                x: this.getControl("mcGuiPowerup1").canvas.position.x,
                y: this.getControl("mcGuiPowerup1").canvas.position.y
            };
            break;
        case ItemWorld.TYPE_PU_STRIKEWAVE:
            c = PoolClips.instance.getClip("gui_hud_powerup_strikewave");
            b = PoolClips.instance.getClip("gui_hud_powerup_cooldown_base");
            b.addChild(c);
            c = {
                x: this.getControl("mcGuiPowerup1").canvas.position.x,
                y: this.getControl("mcGuiPowerup1").canvas.position.y
            };
            break;
        case ItemWorld.TYPE_PU_PERFECTDEFLECT:
            c = PoolClips.instance.getClip("gui_hud_powerup_deflect");
            b = PoolClips.instance.getClip("gui_hud_powerup_cooldown_base");
            b.addChild(c);
            c = {
                x: this.getControl("mcGuiPowerup1").canvas.position.x,
                y: this.getControl("mcGuiPowerup1").canvas.position.y
            };
            break;
        case ItemWorld.TYPE_PU_MULTIBLASTER:
            c = PoolClips.instance.getClip("gui_hud_powerup_sonicblaster");
            b = PoolClips.instance.getClip("gui_hud_powerup_cooldown_base");
            b.addChild(c);
            c = {
                x: this.getControl("mcGuiPowerup1").canvas.position.x,
                y: this.getControl("mcGuiPowerup1").canvas.position.y
            };
            break;
        case ItemWorld.TYPE_PU_EXPLOSIVEBLASTER:
            c = PoolClips.instance.getClip("gui_hud_powerup_deathtrooperblaster"), b = PoolClips.instance.getClip("gui_hud_powerup_cooldown_base"), b.addChild(c), c = {
                x: this.getControl("mcGuiPowerup1").canvas.position.x,
                y: this.getControl("mcGuiPowerup1").canvas.position.y
            }
    }
    b && (b.position.x =
        PlatformGame.instance.world.player().m_x - PlatformGame.instance.world.m_camera.m_x, b.position.y = PlatformGame.instance.world.player().m_y - PlatformGame.instance.world.m_camera.m_y, this.canvas.addChild(b), this.clipsByAnimation.push({
            clip: b,
            goal: c,
            type: a
        }))
};
HudPlatform.prototype.setEnergyBar = function(a, b) {
    100 < a && (a = 100);
    var c = this.getControl("mcGuiFxHpAlert");
    "undefined" !== typeof b && b && this.doHpHealAnimation();
    this.m_clipHpBar.gotoAndStop(a);
    32 > a ? (this.isBleedingOut = !0, c.clip.resume()) : (this.isBleedingOut = !1, c.clip.gotoAndStop(1));
    c.setVisible(this.isBleedingOut && this.m_clipHpBar.visible)
};
HudPlatform.prototype.setSpecialBar = function(a, b) {
    100 <= a && (a = 100);
    this.m_clipSpecialBar.gotoAndStop(~~(a / 100 * this.m_clipSpecialBar.totalFrames) + 1);
    !b && Application.instance.isMobileDevice && this.m_clipSpecialBarMobile.gotoAndStop(~~(a / 100 * this.m_clipSpecialBarMobile.totalFrames) + 1)
};
HudPlatform.prototype.setVisibilitySpecialBlink = function(a) {
    this.getControl("mcGuiFxSpecial").setVisible(this.getControl("mcGuiBase").canvas.visible ? a : !1)
};
HudPlatform.prototype.setVisibilitySpecialReadyToUse = function(a) {
    this.specialReadyToUse = a;
    Application.instance.isMobileDevice && (this.getControl("mcGuiBarspecial").setVisible(!a && this.isHudEnabled), this.getControl("mcGuiKeySpecial").setVisible(a && this.isHudEnabled), this.getControl("mcGuiKeySpecial").clip.gotoAndStop(1));
    this.getControl("mcGuiFxSpecialAlert").setVisible(this.m_clipSpecialBar.visible && this.specialReadyToUse && this.isHudEnabled);
    a ? Application.instance.playSound("SND_SPECIAL_READY") : (this.doSpecialFullAnimation(),
        this.m_clipSpecialBarMobile.gotoAndStop(1))
};
HudPlatform.prototype.setEnergyBoss = function(a) {
    1E3 < a && (a = 1E3);
    this.m_clipBossHpBar.gotoAndStop(a)
};
HudPlatform.prototype.setScore = function(a) {};
HudPlatform.prototype.setLives = function(a) {};
HudPlatform.prototype.doScreenshotTransition = function() {
    Global.screenCapture ? (this.onTransition = !0, this.transitionTimer = 0, Global.screenCapture.mask = this.circleMask, Global.screenCapture.position.x = -Layout.left / Layout.scale, this.canvas.addChild(Global.screenCapture)) : this.doTransition(!0)
};
HudPlatform.prototype.doTransition = function(a) {
    this.getControl("mcGuiTransition").clip.loop = !1;
    this.getControl("mcGuiTransition").clip.gotoAndPlay(1);
    this.getControl("mcGuiTransition").setVisible(!0);
    if (a) this.getControl("mcGuiTransition").clip.onEndAnimation(this, this.transitionIn);
    else Global.game.world.player().setHold(!0), this.getControl("mcGuiTransition").clip.onEndAnimation(this.onTransitionEndCaller, this.onTransitionEndCallback)
};
HudPlatform.prototype.onEndTrans = function(a, b) {
    this.onTransitionEndCaller = a;
    this.onTransitionEndCallback = b
};
HudPlatform.prototype.transitionIn = function() {
    Global.game.world.player().setHold(!0);
    this.onTransitionEndCallback && this.onTransitionEndCallback.call(this.onTransitionEndCaller);
    this.transition = this.getControl("mcGuiTransition").canvas.addChild(PoolClips.instance.getClip("mcGuiTransition_in"));
    this.getControl("mcGuiTransition").canvas.removeChild(this.getControl("mcGuiTransition").clip);
    this.transition.onEndAnimation(this, this._onEndTransition)
};
HudPlatform.prototype._onEndTransition = function() {
    this.addPopup(GuiPopupTurn, "mcGuiMessageVsTurn")
};
HudPlatform.prototype.showTutorial = function(a) {
    GuiPopupMessage.typeMessage = a;
    switch (a) {
        case GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK:
            this.setVisibilitySpecialReadyToUse(!1);
            this.specialFull && this.removeSpecialClip();
            Application.instance.isMobileDevice && this.getControl("mcGuiBarspecial").setVisible(!0);
            this.getControl("mcGuiSpecialBar").setVisible(!0);
            this.showSpecialBar = this.getControl("mcGuiBase").clip.specialBar.visible = !0;
            this.doFastReplenish(500);
            this.setSpecialBar(0, !1);
            break;
        case GuiPopupMessage.TUTORIAL_JUMP:
            this.removeTutorialAttack();
            Application.instance.isMobileDevice ? this.showFinger(a) : (this.canvas.addChild(this.tutorialClips.jumpKey.clip), this.tutorialClips.jumpKey.isActive = !0, this.tutorialClips.jumpKey.clip.position.x = .5 * Global.game.world.m_camera.fixWidthRatio - Global.game.world.m_camera.fixOffsetX, this.tutorialClips.jumpKey.clip.position.y = .9 * Global.game.world.m_camera.m_height);
            this.tutorialClips.jump.isActive = !0;
            Global.game.world.objectCanvas().addChild(this.tutorialClips.jump.clip);
            this.tutorialClips.jump.clip.position.x =
                this.tutorialClips.jump.position.x - Global.game.world.m_camera.m_x;
            this.tutorialClips.jump.clip.position.y = this.tutorialClips.jump.position.y - Global.game.world.m_camera.m_y;
            break;
        case GuiPopupMessage.TUTORIAL_DOUBLE_JUMP:
            Application.instance.isMobileDevice ? this.showFinger(a) : (this.canvas.addChild(this.tutorialClips.jumpKey.clip), this.tutorialClips.jumpKey.isActive = !0, this.tutorialClips.jumpKey.clip.position.x = .5 * Global.game.world.m_camera.fixWidthRatio - Global.game.world.m_camera.fixOffsetX, this.tutorialClips.jumpKey.clip.position.y =
                .9 * Global.game.world.m_camera.m_height);
            this.tutorialClips.jump.isActive = !0;
            Global.game.world.objectCanvas().addChild(this.tutorialClips.jump.clip);
            this.tutorialClips.jump.clip.position.x = this.tutorialClips.jump.position.x + this.tutorialClips.jump.offset.x - Global.game.world.m_camera.m_x;
            this.tutorialClips.jump.clip.position.y = this.tutorialClips.jump.position.y + this.tutorialClips.jump.offset.y - Global.game.world.m_camera.m_y;
            this.tutorialClips.doubleJump.isActive = !0;
            Global.game.world.objectCanvas().addChild(this.tutorialClips.doubleJump.clip);
            this.tutorialClips.doubleJump.clip.position.x = this.tutorialClips.jump.clip.position.x + this.tutorialClips.doubleJump.offset.x;
            this.tutorialClips.doubleJump.clip.position.y = this.tutorialClips.jump.clip.position.y + this.tutorialClips.doubleJump.offset.y;
            break;
        case GuiPopupMessage.TUTORIAL_MOVE:
            this.canvas.addChild(this.tutorialClips.arrow.clip);
            this.tutorialClips.arrow.isActive = !0;
            this.tutorialClips.arrow.clip.position.x = .5 * Global.game.world.m_camera.fixWidthRatio - Global.game.world.m_camera.fixOffsetX +
                400;
            this.tutorialClips.arrow.clip.position.y = .5 * Global.game.world.m_camera.m_height;
            break;
        case GuiPopupMessage.TUTORIAL_ATTACK:
            Application.instance.isMobileDevice ? this.currentFinger || this.showFinger(a) : this.tutorialClips.attackKey.isActive || (this.canvas.addChild(this.tutorialClips.attackKey.clip), this.tutorialClips.attackKey.isActive = !0, this.tutorialClips.attackKey.clip.position.x = .5 * Global.game.world.m_camera.fixWidthRatio - Global.game.world.m_camera.fixOffsetX, this.tutorialClips.attackKey.clip.position.y =
                .9 * Global.game.world.m_camera.m_height)
    }
};
HudPlatform.prototype.removeTutorialDoubleJump = function() {
    this.currentFinger ? this.removeFinger() : this.tutorialClips.jumpKey.isAwaitingRemove = !0;
    this.tutorialClips.jump && (this.tutorialClips.jump.isAwaitingRemove = !0, this.tutorialClips.jump.isActive = !1);
    this.tutorialClips.doubleJump && (this.tutorialClips.doubleJump.isAwaitingRemove = !0, this.tutorialClips.doubleJump.isActive = !1)
};
HudPlatform.prototype.removeTutorialSpecial = function() {
    this.tutorialClips.specialKey && this.tutorialClips.specialKey.isActive && (this.tutorialClips.specialKey.isAwaitingRemove = !0);
    this.currentFinger && this.currentFinger.tutorialButton === GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK && this.removeFinger()
};
HudPlatform.prototype.removeTutorialAttack = function() {
    this.currentFinger && this.currentFinger.tutorialButton === GuiPopupMessage.TUTORIAL_ATTACK && this.removeFinger();
    this.tutorialClips.attackKey && this.tutorialClips.attackKey.isActive && (this.tutorialClips.attackKey.isAwaitingRemove = !0)
};
HudPlatform.prototype.doFastReplenish = function(a) {
    this.doFastEnergy = !0;
    this.fastEnergyTime = a
};
HudPlatform.prototype.onEndFastReplenish = function() {
    this.doFastEnergy = !1;
    this.setVisibilitySpecialReadyToUse(!0);
    this.doSpecialFullAnimation();
    this.specialFull.onEndAnimation(this, this.onEndBlinkingEffect)
};
HudPlatform.prototype.onEndBlinkingEffect = function() {
    0 === this.tutorialFingertimer ? this.tutorialFingertimer = 1 : (this.removeSpecialClip(), Application.instance.isMobileDevice ? this.showFinger(GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK) : this.showXKeyTutorial())
};
HudPlatform.prototype.setPowerUpFxState = function(a) {
    switch (a) {
        case 1:
            this.getControl("mcGuiPowerupFx").setClip("gui_hud_powerup_cooldown_fx");
            break;
        case 2:
            this.getControl("mcGuiPowerupFx").setClip("gui_hud_powerup_cooldown_fx2")
    }
};
HudPlatform.prototype.disableControlsForTutorial = function() {
    Application.instance.isMobileDevice && (this.clipJump.setVisible(!1), this.clipSpecial.setVisible(!1), this.clipAttack.setVisible(!1));
    this.getControl("mcGuiBarspecial").setVisible(!1)
};
HudPlatform.prototype.enableTouchControl = function(a) {
    switch (a) {
        case GuiPopupMessage.TUTORIAL_MOVE:
            PlatformGame.instance.basicStick.canvas.visible = !0;
            this.clipJump.setVisible(!0);
            this.showFinger(GuiPopupMessage.TUTORIAL_MOVE);
            break;
        case GuiPopupMessage.TUTORIAL_ATTACK:
            Application.instance.isMobileDevice && (this.clipAttack.setVisible(!0), this.showAttack = !0);
            break;
        case GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK:
            Application.instance.isMobileDevice && (this.getControl("mcGuiBarspecial").setVisible(!0), this.getControl("mcGuiBase").clip.specialBar.visible = !0, this.getControl("mcGuiSpecialBar").setVisible(!0))
    }
};
HudPlatform.prototype.removeFinger = function() {
    this.currentFinger && (this.canvas.removeChild(this.currentFinger.clip), this.currentFinger = null)
};
HudPlatform.prototype.showFinger = function(a) {
    this.specialReminderTimer = 0;
    this.currentFinger && this.removeFinger();
    GuiPopupMessage.typeMessage = a;
    switch (a) {
        case GuiPopupMessage.TUTORIAL_MOVE:
            this.currentFinger = {
                clip: PoolClips.instance.getClip("mcGuiTutorialsPressandhold"),
                tutorialButton: GuiPopupMessage.TUTORIAL_MOVE
            };
            this.currentFinger.clip.scale.x = -1;
            this.currentFinger.clip.position.x = PlatformGame.instance.basicStick.clipBaseRight.position.x;
            this.currentFinger.clip.position.y = PlatformGame.instance.basicStick.clipBaseRight.position.y;
            this.canvas.addChild(this.tutorialClips.arrow.clip);
            this.tutorialClips.arrow.clip.position.x = .5 * Global.game.world.m_camera.fixWidthRatio - Global.game.world.m_camera.fixOffsetX + 400;
            this.tutorialClips.arrow.clip.position.y = .5 * Global.game.world.m_camera.m_height;
            this.tutorialClips.arrow.isActive = !0;
            break;
        case GuiPopupMessage.TUTORIAL_JUMP:
            this.currentFinger = {
                clip: PoolClips.instance.getClip("mcGuiTutorialsTap"),
                tutorialButton: GuiPopupMessage.TUTORIAL_JUMP
            };
            this.currentFinger.clip.position.x = this.getControl("mcGuiKeyJump").canvas.position.x;
            this.currentFinger.clip.position.y = this.getControl("mcGuiKeyJump").canvas.position.y;
            break;
        case GuiPopupMessage.TUTORIAL_DOUBLE_JUMP:
            this.currentFinger = {
                clip: PoolClips.instance.getClip("mcGuiTutorialsDoubletap"),
                tutorialButton: GuiPopupMessage.TUTORIAL_DOUBLE_JUMP
            };
            this.currentFinger.clip.position.x = this.getControl("mcGuiKeyJump").canvas.position.x;
            this.currentFinger.clip.position.y = this.getControl("mcGuiKeyJump").canvas.position.y;
            break;
        case GuiPopupMessage.TUTORIAL_ATTACK:
            this.currentFinger = {
                clip: PoolClips.instance.getClip("mcGuiTutorialsTap"),
                tutorialButton: GuiPopupMessage.TUTORIAL_ATTACK
            };
            this.currentFinger.clip.position.x = this.getControl("mcGuiKeyAttack").canvas.position.x;
            this.currentFinger.clip.position.y = this.getControl("mcGuiKeyAttack").canvas.position.y;
            break;
        case GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK:
            this.currentFinger = {
                    clip: PoolClips.instance.getClip("mcGuiTutorialsTap"),
                    tutorialButton: GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK
                }, this.currentFinger.clip.position.x = this.getControl("mcGuiKeySpecial").canvas.position.x, this.currentFinger.clip.position.y =
                this.getControl("mcGuiKeySpecial").canvas.position.y
    }
    this.canvas.addChild(this.currentFinger.clip)
};
HudPlatform.prototype.hideP2Counter = function() {
    this.getControl("mcGuiFxCounter2").setVisible(!1);
    this.getControl("mcGuiFxCounter2").clip.gotoAndStop(1);
    this.getControl("mcGuiCounter2Base").setVisible(!1);
    this.getControl("mcGuiTextCollectibles_2").setTextEmpty();
    this.getControl("mcGuiTextCollectiblesPlayer").setTextEmpty()
};
HudPlatform.prototype.onJoystickPress = function(a) {};
HudPlatform.prototype.doHpHealAnimation = function() {
    this.hpBarHeal && this.removeHpClip();
    this.hpBarHeal = PoolClips.instance.getClip("gui_hud_bar_hp_increasing");
    this.hpBarHeal.onEndAnimation(this, this.removeHpClip);
    this.getControl("mcGuiHpbar").canvas.addChild(this.hpBarHeal)
};
HudPlatform.prototype.removeHpClip = function() {
    PoolClips.instance.releaseClip(this.hpBarHeal);
    this.hpBarHeal = null
};
HudPlatform.prototype.removeSpecialClip = function() {
    PoolClips.instance.releaseClip(this.specialFull);
    this.specialFull = null
};
HudPlatform.prototype.doSpecialFullAnimation = function() {
    this.specialFull && this.removeSpecialClip();
    this.specialFull = PoolClips.instance.getClip("gui_hud_bar_special_activated");
    this.specialFull.onEndAnimation(this, this.removeSpecialClip);
    this.getControl("mcGuiSpecialBar").canvas.addChild(this.specialFull)
};
HudPlatform.prototype.setInitialPos = function() {
    for (var a in this.controls) {
        var b = this.controls[a];
        switch (b.name) {
            case "mcGuiKeyAttack":
            case "mcGuiKeySpecial":
            case "mcGuiBarspecial":
            case "mcGuiKeyJump":
            case "mcGuiBg":
            case "mcGuiTransition":
                this.frozeControls[b.name] = b.canvas.position.y
        }
    }
    this.frozeControls.letterbox1 = this.clip.letterbox1.position.y;
    this.frozeControls.letterbox2 = this.clip.letterbox2.position.y;
    this.frozeControls.letterbox3 = this.clip.letterbox3.position.y;
    this.frozeControls.letterbox4 =
        this.clip.letterbox4.position.y
};
HudPlatform.prototype.reposFrozenControls = function(a) {
    for (var b in this.controls) {
        var c = this.controls[b];
        switch (c.name) {
            case "mcGuiKeyAttack":
            case "mcGuiKeySpecial":
            case "mcGuiBarspecial":
            case "mcGuiKeyJump":
            case "mcGuiBg":
            case "mcGuiTransition":
                c.canvas.position.y = this.frozeControls[c.name] + a
        }
    }
    this.clip.letterbox1.position.y = this.frozeControls.letterbox1 + a;
    this.clip.letterbox2.position.y = this.frozeControls.letterbox2 + a;
    this.clip.letterbox3.position.y = this.frozeControls.letterbox3 + a;
    this.clip.letterbox4.position.y =
        this.frozeControls.letterbox4 + a;
    Global.screenCapture && (Global.screenCapture.position.y = a)
};
HudPlatform.prototype.update = function(a) {
    SScreen.prototype.update.call(this, a);
    MissionManager.instance.isMissionTutorial() || (this.specialReminderTimer += a, this.specialReminderTimer >= HudPlatform.TUTORIAL_POPUP_TIME && this.removeTutorialSpecial());
    if (MissionManager.instance.isMissionTutorial() && Global.game && !Global.game.isIntroBlending && (GuiPopupMessage.typeMessage === GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK || GuiPopupMessage.typeMessage === GuiPopupMessage.TUTORIAL_ATTACK || GuiPopupMessage.typeMessage === GuiPopupMessage.TUTORIAL_MOVE) &&
        (this.tutorialTimer += a, this.tutorialTimer >= HudPlatform.TUTORIAL_POPUP_TIME || GuiPopupMessage.typeMessage === GuiPopupMessage.TUTORIAL_MOVE && this.tutorialTimer >= .5 * HudPlatform.TUTORIAL_POPUP_TIME) && (this.tutorialTimer = 0, GuiPopupMessage.typeMessage !== GuiPopupMessage.TUTORIAL_MOVE && Global.game.world.oocManager.setActiveOfType(OOCManager.EXTRACTION_POINT, !0), !Application.instance.isMobileDevice)) switch (GuiPopupMessage.typeMessage) {
        case GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK:
            this.popup || this.addPopup(GuiPopupMessage,
                "mcGuiPopupTutorial");
            break;
        case GuiPopupMessage.TUTORIAL_MOVE:
            1 === PlatformGame.instance.world.player().tutorialComponent.tutorials[GuiPopupMessage.TUTORIAL_MOVE] && (Application.instance.isMobileDevice ? this.showFinger(GuiPopupMessage.TUTORIAL_MOVE) : (this.canvas.addChild(this.tutorialClips.moveKey.clip), this.tutorialClips.moveKey.isActive = !0, this.tutorialClips.moveKey.clip.position.x = .5 * Global.game.world.m_camera.fixWidthRatio - Global.game.world.m_camera.fixOffsetX, this.tutorialClips.moveKey.clip.position.y =
                .9 * Global.game.world.m_camera.m_height))
    }
    this.reminderPopup && this.reminderPopup.update(a);
    0 < this.tutorialFingertimer && (this.tutorialFingertimer += a, this.tutorialFingertimer >= HudPlatform.TUTORIAL_FINGER_TIME && (this.onEndBlinkingEffect(), this.tutorialFingertimer = -1));
    for (var b in this.tutorialClips) this.tutorialClips[b].isAwaitingRemove ? (this.tutorialClips[b].isAwaitingRemove = !1, this.tutorialClips[b].isActive = !1, this.canvas.removeChild(this.tutorialClips[b].clip), Global.game.world.objectCanvas().removeChild(this.tutorialClips[b].clip),
        "specialKey" === b && this.canvas.removeChild(this.xLocalized)) : this.tutorialClips[b].isActive && ("jump" === b && (this.tutorialClips[b].clip.position.x = this.tutorialClips[b].position.x - Global.game.world.m_camera.m_x + (this.tutorialClips.doubleJump.isActive ? this.tutorialClips[b].offset.x : 0), this.tutorialClips[b].clip.position.y = this.tutorialClips[b].position.y - Global.game.world.m_camera.m_y + (this.tutorialClips.doubleJump.isActive ? this.tutorialClips[b].offset.y : 0)), "doubleJump" === b && (this.tutorialClips[b].clip.position.x =
        this.tutorialClips.jump.clip.position.x + this.tutorialClips[b].offset.x, this.tutorialClips[b].clip.position.y = this.tutorialClips.jump.clip.position.y + this.tutorialClips[b].offset.y), this.tutorialClips[b].clip.update(a), "specialKey" === b && (this.xLocalized.position.x = this.tutorialClips.specialKey.clip.position.x - .5 * this.xLocalized._texture.baseTexture.realWidth, 5 <= this.tutorialClips.specialKey.clip.currentFrame && 22 >= this.tutorialClips.specialKey.clip.currentFrame ? (this.xLocalized.alpha = 1, this.xLocalized.position.y =
        this.tutorialClips.specialKey.clip.position.y - 3 - .5 * this.xLocalized._texture.baseTexture.realHeight) : (this.xLocalized.alpha = .4, this.xLocalized.position.y = this.tutorialClips.specialKey.clip.position.y - 7 - .5 * this.xLocalized._texture.baseTexture.realHeight)));
    for (b = this.clipsByAnimation.length - 1; 0 <= b; b--) {
        var c = this.clipsByAnimation[b];
        c.clip.position.x += Common.lerp(c.clip.position.x, c.goal.x, 10, a);
        c.clip.position.y += Common.lerp(c.clip.position.y, c.goal.y, 10, a);
        c.clip.update(a);
        if (5 >= SMath.abs(c.clip.position.x -
                c.goal.x) && 5 >= SMath.abs(c.clip.position.y - c.goal.y)) {
            if (-1 !== c.type) switch (this.activatePowerup(c.type), c.type) {
                case ItemWorld.TYPE_PU_STRIKEWAVE:
                    Global.game.world.player().PP1Tooltipshown || (HudPlatform.instance.tooltip && HudPlatform.instance.tooltip.free(), GuiPopupTooltip.typeMessage = GuiPopupTooltip.PP_STRIKE_TOOLTIP, HudPlatform.instance.tooltip = new GuiPopupTooltip("mcGuiPopupPowerup", 0, 0, HudPlatform.instance), Global.game.world.player().PP1Tooltipshown = !0);
                    break;
                case ItemWorld.TYPE_PU_PERFECTDEFLECT:
                    Global.game.world.player().PP2Tooltipshown ||
                        (HudPlatform.instance.tooltip && HudPlatform.instance.tooltip.free(), GuiPopupTooltip.typeMessage = GuiPopupTooltip.PP_DEFLECT_TOOLTIP, HudPlatform.instance.tooltip = new GuiPopupTooltip("mcGuiPopupPowerup", 0, 0, HudPlatform.instance), Global.game.world.player().PP2Tooltipshown = !0);
                    break;
                case ItemWorld.TYPE_PU_MULTIBLASTER:
                    Global.game.world.player().PP4Tooltipshown || (HudPlatform.instance.tooltip && HudPlatform.instance.tooltip.free(), GuiPopupTooltip.typeMessage = GuiPopupTooltip.PP_SONIC_BLASTER_TOOLTIP, HudPlatform.instance.tooltip =
                        new GuiPopupTooltip("mcGuiPopupPowerup", 0, 0, HudPlatform.instance), Global.game.world.player().PP4Tooltipshown = !0);
                    break;
                case ItemWorld.TYPE_PU_EXPLOSIVEBLASTER:
                    Global.game.world.player().PP3Tooltipshown || (HudPlatform.instance.tooltip && HudPlatform.instance.tooltip.free(), GuiPopupTooltip.typeMessage = GuiPopupTooltip.PP_DEATH_TROOPER_BLASTER_TOOLTIP, HudPlatform.instance.tooltip = new GuiPopupTooltip("mcGuiPopupPowerup", 0, 0, HudPlatform.instance), Global.game.world.player().PP3Tooltipshown = !0)
            } else this.setCollectibles(c.found,
                c.total);
            this.canvas.removeChild(this.clipsByAnimation.splice(b, 1)[0].clip)
        }
    }
    if (this.onTransition) Global.screenCapture.texture.baseTexture.hasLoaded && (this.onTransitionEndCaller && this.onTransitionEndCallback.call(this.onTransitionEndCaller), this.onTransitionEndCallback = this.onTransitionEndCaller = null, this.transitionTimer += a, this.circleMask.setRatio(this.transitionTimer / 1E3 - .02, !0), 1E3 <= this.transitionTimer && (this.onTransition = !1, this.addPopup(GuiPopupTurn, "mcGuiMessageVsTurn"), this.canvas.removeChild(Global.screenCapture)));
    else {
        this.warningPopup && this.warningPopup.update(a);
        this.tooltip && this.tooltip.update(a);
        this.alertBkgVisible || PlayerSettings.instance.isInLiberation ? Application.instance.isPlayingSound("SND_CONQUER_ALARM") || Application.instance.playSound("SND_CONQUER_ALARM") : Application.instance.stopSound("SND_CONQUER_ALARM");
        if (this.doFastEnergy && (this.fastEnergyTimer += a, this.setSpecialBar(~~(this.fastEnergyTimer / this.fastEnergyTime * 100), !1), this.fastEnergyTimer >= this.fastEnergyTime)) this.onEndFastReplenish();
        if (this.hudIsEnabling &&
            !PlatformGame.instance.onTransition) {
            this.canvas.position.y += Common.lerp(this.canvas.position.y, 0, 10, a);
            if (-1 <= this.canvas.position.y) this.onEndHudAnimation();
            this.reposFrozenControls(-this.canvas.position.y)
        }
        this.currentFinger && this.currentFinger.clip.update(a)
    }
};
HudPlatform.prototype.onEndHudAnimation = function() {
    this.canvas.position.y = 0;
    this.hudIsEnabling = !1;
    PlayerSettings.instance.isMultiplayer()
};
HudPlatform.prototype.onKeyDown = function(a) {
    if (this.tooltip) this.tooltip.onKeyDown(a);
    if (MissionManager.instance.isMissionTutorial()) switch (this.tutorialTimer = 0, Global.game.world.oocManager.setActiveOfType(OOCManager.EXTRACTION_POINT, !1), a) {
        case PlayerControl.CMD_UP_A:
        case PlayerControl.CMD_UP_B:
            if (this.tutorialClips.doubleJump && this.tutorialClips.doubleJump.isActive) {
                PlatformGame.instance.world.player().m_state === Player.ST_PLAYER_JUMP_SPECIAL && (this.removeTutorialDoubleJump(), PlatformGame.instance.world.player().tutorialComponent.tutorials[GuiPopupMessage.TUTORIAL_DOUBLE_JUMP] =
                    3, this.removeFinger());
                break
            }
            this.tutorialClips.jump && this.tutorialClips.jump.isActive && (this.removeTutorialDoubleJump(), PlatformGame.instance.world.player().tutorialComponent.tutorials[GuiPopupMessage.TUTORIAL_JUMP] = 2, this.removeFinger());
            break;
        case PlayerPlatform.KEY_ATTACK:
            if (this.tutorialClips.attackKey && this.tutorialClips.attackKey.isActive || this.currentFinger && this.currentFinger.tutorialButton === GuiPopupMessage.TUTORIAL_ATTACK) this.removeTutorialAttack(), PlayerSettings.instance.isPlayerMelee() &&
                (Global.game.world.player().m_character.addState(PlayerPlatform.ST_PLAYER_PUNCH, Global.game.world.player().m_skinBase + "_attack" + PlayerPlatform.aniAttackId), Global.game.world.player().gotoState(PlayerPlatform.ST_PLAYER_PUNCH));
            break;
        case PlayerPlatform.KEY_BOMB:
            if (this.tutorialClips.specialKey && this.tutorialClips.specialKey.isActive || this.currentFinger && this.currentFinger.tutorialButton === GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK)
                if (this.removeTutorialSpecial(), PlatformGame.instance.world.player().disablePlayer = !1, PlatformGame.instance.world.player().waitUseSpecial = !0, this.popup && "undefined" !== typeof this.popup.isTutorial && this.popup.isTutorial()) this.popup.onResumeScreen();
                else GuiPopupMessage.typeMessage = -1, this.tutorialTimer = 0;
            break;
        case PlayerControl.CMD_LEFT_A:
        case PlayerControl.CMD_RIGHT_A:
            this.tutorialClips.arrow && this.tutorialClips.arrow.isActive && (this.tutorialClips.moveKey ? this.tutorialClips.moveKey.isAwaitingRemove = !0 : this.removeFinger(), this.tutorialClips.arrow && (this.tutorialClips.arrow.isAwaitingRemove = !0), GuiPopupMessage.typeMessage = -1, this.tutorialTimer = 0, Global.game.world.oocManager.setActiveOfType(OOCManager.EXTRACTION_POINT, !1))
    }
};

function BaseGhosting() {
    this.isAwaitingDelete = this.isPlayerRange = this.isReplaying = !1;
    this.m_canvas = null;
    this.pathX = [];
    this.pathY = [];
    this.pathKeys = [];
    this.isJumping = [];
    this.isCovering = [];
    this.flipX = [];
    this.playerStates = [];
    this.m_state = 0;
    this.standState = [];
    this.jumpUpState = [];
    this.jumpDownState = [];
    this.hitState = [];
    this.winState = [];
    this.loseState = [];
    this.landState = [];
    this.stand2State = [];
    this.walkState = [];
    this.runState = [];
    this.jumpSpecialState = [];
    this.punchState = [];
    this.shootState = [];
    this.moveShootState = [];
    this.clipStates = [];
    this.m_actor = this.m_character = null;
    this.m_skinBase = "";
    this.currentKey = this.totalTime = this.pathTimer = this.currentPathKeyIndex = this.playerType = this.dissapearTimer = 0;
    this.m_occ_skin = "";
    this.m_playerLastState = -1;
    this.m_recordInterval = BaseGhosting.RECORDING_INTERVAL
}
Application.subclass(BaseGhosting, SimpleWorldActor);
BaseGhosting.RECORDING_INTERVAL = 50;
BaseGhosting.RECORDING_INTERVAL2 = 100;
BaseGhosting.RECORDING_INTERVAL3 = 150;
BaseGhosting.RECORD_LIMIT = 3E5;
BaseGhosting.RECORD_LIMIT2 = 6E5;
BaseGhosting.RECORD_LIMIT3 = 12E5;
BaseGhosting.DELAY_BEFORE_DISSAPEAR = 0;
BaseGhosting.PLAYER_JUMP_ATTACK = "st501";
BaseGhosting.PLAYER_COVERING = "st502";
BaseGhosting.prototype.update = function(a) {
    this.isReplaying ? 10 < this.pathX.length - this.currentKey ? this.doReplay(a) : this.stopReplay() : (this.dissapearTimer += a, this.dissapearTimer >= BaseGhosting.DELAY_BEFORE_DISSAPEAR && (this.removeFromScreen(), Global.game.world.oocManager.removeThisActor(this), this.isAwaitingDelete = !0));
    SimpleWorldActor.prototype.update.call(this, a)
};
BaseGhosting.prototype.doRecord = function(a) {
    this.pathTimer >= this.m_recordInterval && (this.pathTimer = 0, this.pathX[this.totalTime] = this.m_actor.m_x, this.pathY[this.totalTime] = this.m_actor.m_y, this.m_actor.m_flipX && (this.flipX[this.totalTime] = !0), this.recordState(this.m_actor.m_state), PlatformGame.playerNearEnemy || (this.isCovering[this.totalTime] = !0), this.m_actor.m_control.isJumping() && (this.isJumping[this.totalTime] = !0), this.pathKeys.push(this.totalTime));
    this.pathTimer += a;
    this.totalTime += a;
    this.totalTime >
        BaseGhosting.RECORD_LIMIT && this.m_recordInterval < BaseGhosting.RECORDING_INTERVAL2 && (this.m_recordInterval = BaseGhosting.RECORDING_INTERVAL2);
    this.totalTime > BaseGhosting.RECORD_LIMIT2 && this.m_recordInterval < BaseGhosting.RECORDING_INTERVAL3 && (this.m_recordInterval = BaseGhosting.RECORDING_INTERVAL3);
    this.totalTime > BaseGhosting.RECORD_LIMIT3 && GhostingManager.instance.stopRecording()
};
BaseGhosting.prototype.recordState = function(a) {
    if (this.m_playerLastState !== a) switch (this.m_playerLastState = a, a) {
        case PlayerChopper.ST_IDLE:
        case Player.ST_PLAYER_STAND:
            this.standState[this.totalTime] = !0;
            break;
        case Player.ST_PLAYER_WALK:
            this.walkState[this.totalTime] = !0;
            break;
        case Player.ST_PLAYER_RUN:
            this.runState[this.totalTime] = !0;
            break;
        case Player.ST_PLAYER_LAND:
            this.landState[this.totalTime] = !0;
            break;
        case Player.ST_PLAYER_JUMP_UP:
            this.jumpUpState[this.totalTime] = !0;
            break;
        case Player.ST_PLAYER_JUMP_DOWN:
            this.jumpDownState[this.totalTime] = !0;
            break;
        case Player.ST_PLAYER_HIT:
            this.hitState[this.totalTime] = !0;
            break;
        case Player.ST_PLAYER_WIN:
            this.winState[this.totalTime] = !0;
            break;
        case Player.ST_PLAYER_LOSE:
            this.loseState[this.totalTime] = !0;
            break;
        case Player.ST_PLAYER_STAND_2:
            this.stand2State[this.totalTime] = !0;
            break;
        case Player.ST_PLAYER_JUMP_SPECIAL:
            this.jumpSpecialState[this.totalTime] = !0;
            break;
        case PlayerPlatform.ST_PLAYER_PUNCH:
            this.punchState[this.totalTime] = !0;
            break;
        case PlayerPlatform.ST_PLAYER_SHOOT:
            this.shootState[this.totalTime] = !0;
            break;
        case PlayerPlatform.ST_PLAYER_MOVE_SHOOT:
            this.moveShootState[this.totalTime] = !0
    }
};
BaseGhosting.prototype.gotoState = function(a) {
    this.m_state = a;
    var b = null;
    switch (a) {
        case PlayerPlatform.ST_PLAYER_SHOOT:
            b = "undefined" !== typeof this.isJumping[this.pathKeys[this.currentPathKeyIndex]] ? this.clipStates[BaseGhosting.PLAYER_JUMP_ATTACK] : this.clipStates[PlayerPlatform.ST_PLAYER_SHOOT];
            break;
        case PlayerPlatform.ST_PLAYER_PUNCH:
            b = "undefined" !== typeof this.isJumping[this.pathKeys[this.currentPathKeyIndex]] ? this.clipStates[BaseGhosting.PLAYER_JUMP_ATTACK] : "undefined" !== typeof this.isCovering[this.pathKeys[this.currentPathKeyIndex]] ?
                this.clipStates[BaseGhosting.PLAYER_COVERING] : this.clipStates[PlayerPlatform.ST_PLAYER_PUNCH];
            break;
        default:
            b = this.clipStates[a]
    }
    b && (this.m_clip && this.m_canvas.removeChild(this.m_clip), this.m_clip = b, this.m_clip.alpha = .5, this.m_canvas.addChild(this.m_clip), this.m_character.clip = this.m_clip);
    this.playerType === PlayerSettings.TYPE_CHOPPER && (this.m_clip.scale.x = 0 > this.m_clip.scale.x ? -.7 : .7, this.m_clip.scale.y = .7)
};
BaseGhosting.prototype.setStateClips = function() {
    this.clipStates[Player.ST_PLAYER_STAND] = PoolClips.instance.getClip(this.m_skinBase + "_stand");
    this.clipStates[Player.ST_PLAYER_STAND_2] = PoolClips.instance.getClip(this.m_skinBase + "_stand");
    this.clipStates[Player.ST_PLAYER_JUMP_UP] = PoolClips.instance.getClip(this.m_skinBase + "_jump_up");
    this.clipStates[Player.ST_PLAYER_JUMP_DOWN] = PoolClips.instance.getClip(this.m_skinBase + "_jump");
    this.clipStates[Player.ST_PLAYER_HIT] = PoolClips.instance.getClip(this.m_skinBase +
        "_hit");
    this.clipStates[Player.ST_PLAYER_WIN] = PoolClips.instance.getClip(this.m_skinBase + "_outro");
    this.clipStates[Player.ST_PLAYER_LOSE] = PoolClips.instance.getClip(this.m_skinBase + "_defeat");
    this.clipStates[Player.ST_PLAYER_LAND] = PoolClips.instance.getClip(this.m_skinBase + "_jump_ground");
    this.playerType === PlayerSettings.TYPE_KANAN || this.playerType === PlayerSettings.TYPE_EZRA ? (this.clipStates[Player.ST_PLAYER_WALK] = PoolClips.instance.getClip(this.m_skinBase + "_run"), this.clipStates[Player.ST_PLAYER_RUN] =
        PoolClips.instance.getClip(this.m_skinBase + "_run"), this.clipStates[Player.ST_PLAYER_JUMP_SPECIAL] = PoolClips.instance.getClip(this.m_skinBase + "_jump2"), this.clipStates[PlayerPlatform.ST_PLAYER_DASH] = PoolClips.instance.getClip(this.m_skinBase + "_run"), this.clipStates[PlayerPlatform.ST_PLAYER_PUNCH] = PoolClips.instance.getClip(this.m_skinBase + "_attack1"), this.clipStates[BaseGhosting.PLAYER_JUMP_ATTACK] = PoolClips.instance.getClip(this.m_skinBase + "_attack_air"), this.clipStates[BaseGhosting.PLAYER_COVERING] =
        PoolClips.instance.getClip(this.m_skinBase + "_cover1")) : (this.clipStates[Player.ST_PLAYER_WALK] = PoolClips.instance.getClip(this.m_skinBase + "_run2"), this.clipStates[Player.ST_PLAYER_RUN] = PoolClips.instance.getClip(this.m_skinBase + "_run2"), this.clipStates[PlayerPlatform.ST_PLAYER_DASH] = PoolClips.instance.getClip(this.m_skinBase + "_run2"), this.clipStates[PlayerPlatform.ST_PLAYER_SHOOT] = PoolClips.instance.getClip(this.m_skinBase + "_stand"), this.clipStates[PlayerPlatform.ST_PLAYER_MOVE_SHOOT] = PoolClips.instance.getClip(this.m_skinBase +
        "_run2"), this.clipStates[BaseGhosting.PLAYER_JUMP_ATTACK] = PoolClips.instance.getClip(this.m_skinBase + "_jump_attack"))
};
BaseGhosting.prototype.checkStates = function(a) {
    "undefined" !== typeof this.standState[a] ? this.gotoState(Player.ST_PLAYER_STAND) : "undefined" !== typeof this.jumpUpState[a] ? this.gotoState(Player.ST_PLAYER_JUMP_UP) : "undefined" !== typeof this.jumpDownState[a] ? this.gotoState(Player.ST_PLAYER_JUMP_DOWN) : "undefined" !== typeof this.hitState[a] ? this.gotoState(Player.ST_PLAYER_HIT) : "undefined" !== typeof this.winState[a] ? this.gotoState(Player.ST_PLAYER_WIN) : "undefined" !== typeof this.loseState[a] ? this.gotoState(Player.ST_PLAYER_LOSE) :
        "undefined" !== typeof this.landState[a] ? this.gotoState(Player.ST_PLAYER_LAND) : "undefined" !== typeof this.stand2State[a] ? this.gotoState(Player.ST_PLAYER_STAND_2) : "undefined" !== typeof this.walkState[a] ? this.gotoState(Player.ST_PLAYER_WALK) : "undefined" !== typeof this.runState[a] ? this.gotoState(Player.ST_PLAYER_RUN) : "undefined" !== typeof this.jumpSpecialState[a] ? this.gotoState(Player.ST_PLAYER_JUMP_SPECIAL) : "undefined" !== typeof this.punchState[a] ? this.gotoState(PlayerPlatform.ST_PLAYER_PUNCH) : "undefined" !==
        typeof this.shootState[a] ? this.gotoState(PlayerPlatform.ST_PLAYER_SHOOT) : "undefined" !== typeof this.moveShootState[a] && this.gotoState(PlayerPlatform.ST_PLAYER_MOVE_SHOOT)
};
BaseGhosting.prototype.doReplay = function(a) {
    if (this.pathKeys[this.currentPathKeyIndex + 1] <= this.currentKey) this.currentPathKeyIndex += 1, this.m_x = this.pathX[this.pathKeys[this.currentPathKeyIndex]], this.m_y = this.pathY[this.pathKeys[this.currentPathKeyIndex]], this.checkStates(this.pathKeys[this.currentPathKeyIndex]), this.m_character.clip.scale.x = "undefined" !== typeof this.flipX[this.pathKeys[this.currentPathKeyIndex]] ? this.playerType === PlayerSettings.TYPE_CHOPPER ? -.7 : -1 : this.playerType === PlayerSettings.TYPE_CHOPPER ?
        .7 : 1;
    else if ("undefined" !== typeof this.pathKeys[this.currentPathKeyIndex + 1]) {
        var b = this.pathY[this.pathKeys[this.currentPathKeyIndex + 1]];
        this.m_x += this.lerp(this.m_x, this.pathX[this.pathKeys[this.currentPathKeyIndex + 1]], a / (this.pathKeys[this.currentPathKeyIndex + 1] - this.pathKeys[this.currentPathKeyIndex]), 1E3);
        this.m_y += this.lerp(this.m_y, b, a / (this.pathKeys[this.currentPathKeyIndex + 1] - this.pathKeys[this.currentPathKeyIndex]), 1E3)
    } else this.stopReplay();
    this.currentKey += a
};
BaseGhosting.prototype.startReplay = function(a) {
    0 < this.pathX.length && (this.currentPathKeyIndex = 0, SimpleWorldActor.call(this, a.objectCanvas(), a, this.pathX[this.pathKeys[this.currentPathKeyIndex]], this.pathY[this.pathKeys[this.currentPathKeyIndex]]), this.m_canvas = Global.game.world.objectCanvas(), this.m_character = new SimpleCharacter(this.m_x, this.m_y, this.m_canvas), this.setStateClips(), this.dissapearTimer = 0, this.currentKey = this.pathKeys[this.currentPathKeyIndex], this.checkStates(this.pathKeys[this.currentPathKeyIndex]),
        this.isReplaying = !0)
};
BaseGhosting.prototype.removeFromScreen = function() {
    this.m_canvas && this.m_canvas.removeChild(this.m_clip);
    this.m_clip = null
};
BaseGhosting.prototype.stopReplay = function() {
    this.isReplaying = !1;
    this.currentKey = 0
};
BaseGhosting.prototype.startRecording = function(a) {
    PlayerSettings.instance.isPlayerRange() && (this.isPlayerRange = !0);
    this.playerType = PlayerSettings.instance.getPlayer();
    this.m_occ_skin = "gui_hud_pointer_character0" + this.playerType;
    this.m_skinBase = a.data.skinBase;
    this.m_actor = a;
    this.totalTime = this.pathTimer = this.m_recordInterval
};
BaseGhosting.prototype.lerp = function(a, b, c, d) {
    return (b - a) * c * d / 1E3
};
BaseGhosting.prototype.setClip = function(a) {
    this.m_clip && this.m_canvas.removeChild(this.m_clip);
    this.m_clip = PoolClips.instance.getClip(a);
    this.m_canvas.addChild(this.m_clip);
    this.m_character.clip = this.m_clip
};
BaseGhosting.prototype.free = function() {
    this.m_actor = this.m_character = this.clipStates = this.moveShootState = this.shootState = this.punchState = this.jumpSpecialState = this.runState = this.walkState = this.stand2State = this.landState = this.loseState = this.winState = this.hitState = this.jumpDownState = this.jumpUpState = this.standState = this.isCovering = this.playerStates = this.flipX = this.isJumping = this.pathKeys = this.pathY = this.pathX = null;
    SimpleWorldActor.prototype.free.call(this)
};

function PlayerPlatform(a, b, c, d, e) {
    d = b.getFloorCollision(c, d).y;
    this.effectCanvas = new window.PIXI.Container;
    a.addChild(this.effectCanvas);
    this.m_impulseJetpack = 0;
    this.doTeleport = this.isReadyToTeleport = this.passedCheckPoint = !1;
    this.m_tempCol = null;
    this.m_timerDie = 0;
    this.didIntroCallback = !1;
    this.sentinelDroidsKilled = 0;
    this.powerupPulseVanish = this.finishedPlaying = this.playerAttacked = this.loseByHealth = this.loseByTimeout = this.disablePlayer = !1;
    this.powerupPulseTime = 500;
    this.specialTimer = this.powerupPulseTimer =
        0;
    this.doRemovePowerupWithAlpha = !1;
    this.removeAlphaTimer = 0;
    this.gunWeapon = this.m_boundsAttack = null;
    this.fixShootWalk = !0;
    this.frameShootUpBody = 0;
    this.tutorialComponent = null;
    this.m_type = PlayerSettings.instance.getPlayer();
    PlayerSettings.instance.isFirstPlay() && MissionManager.instance.isMissionTutorial() && (this.tutorialComponent = new TutorialComponent(this));
    this.shadowClip = PoolClips.instance.getClip(this.getShadowClip());
    this.shadowClip.gotoAndStop(1);
    a.addChild(this.shadowClip);
    this.activePowerUp = -1;
    PlayerControl.CMD_LEFT_A = window.config.settings.keyLeft;
    PlayerControl.CMD_RIGHT_A = window.config.settings.keyRight;
    PlayerControl.CMD_UP_A = window.config.settings.keyJump;
    PlayerControl.CMD_UP_B = window.config.settings.keyJump2;
    PlayerPlatform.KEY_BOMB = window.config.settings.keyBomb;
    PlayerPlatform.KEY_ATTACK = window.config.settings.keyAttack;
    this.m_lastStateOfJumping = !1;
    this.m_lastPosOfJumping = 0;
    this.m_hitMove = this.m_dashMove = null;
    this.m_inGlide = !1;
    this.data = this.getDataPlayer();
    this.m_canvas = new window.PIXI.Container;
    a.addChild(this.m_canvas);
    Player.call(this, this.m_canvas, b, c, d);
    this.m_type === PlayerSettings.TYPE_CHOPPER && (this.m_scale = window.config.settings.chopper_scale_override / 100, this.m_scaleX = window.config.settings.chopper_scale_override / 100, this.m_scaleY = window.config.settings.chopper_scale_override / 100);
    this.m_skinBase_orientation = this.m_skinBase = "";
    this.clipUpBody = null;
    this.m_limitRight = this.m_limitLeft = this.m_limitUp = !0;
    this.missionActionTimer = -1;
    1 !== Global.level || MissionManager.instance.isMissionTutorial() ||
        MissionManager.instance.isMissionBossBattle() || (this.missionActionTimer = 0);
    this.m_timerDie = -1;
    this.m_health = this.data.health;
    this.m_lastPosOfJumping = this.m_y;
    this.m_lastStateOfJumping = !1;
    this.m_className = "Player";
    this.isPlaying = !1;
    this.unitSounds = null;
    this.winSound = "";
    this.meleeStrikeTimer = this.deflectQuantity = this.meeleStikeBullets = 0;
    this.frameShootFunctions = [];
    this.clipSpecialAttack = this.clipShield = this.clipIntro = this.bulletPositionJump = this.bulletPosition = null;
    this.waitUseSpecial = !1;
    this.powerup_frontFx =
        this.powerup_backFx = null;
    this.isHolding = !1;
    this.missionReminderTimer = this.specialCooldownTimer = this.hitTimer = 0;
    this.isIntroFinished = this.playedShieldWarning = this.waitingForCelebrate = this.specialOnCooldown = !1;
    this.fx = null;
    this.keyAttackTimer = this.tooltipTimer = 0;
    this.m_scaleUpper = new Vector2D;
    this.m_scaleGun = new Vector2D;
    this.isAwaitingWin = this.isAwaitingLose = !1;
    1 === PlayerSettings.instance.getCurrentTurn() ? PlayerSettings.instance.player1GotDamage = !1 : PlayerSettings.instance.player2GotDamage = !1;
    this.PP5Tooltipshown =
        this.PP4Tooltipshown = this.PP3Tooltipshown = this.PP2Tooltipshown = this.PP1Tooltipshown = !1;
    this.useSeparatedAnimations = !0
}
Application.subclass(PlayerPlatform, Player);
PlayerPlatform.HIT_TIME = 4E3;
PlayerPlatform.DIE_TIME = 500;
PlayerPlatform.POSITION_COUNTER = 5;
PlayerPlatform.ST_PLAYER_PUNCH = "st200";
PlayerPlatform.ST_PLAYER_SHOOT = "st201";
PlayerPlatform.ST_PLAYER_DASH = "st202";
PlayerPlatform.ST_PLAYER_MOVE_SHOOT = "st203";
PlayerPlatform.SHIELD_RANGE = 100;
PlayerPlatform.KEY_BOMB = 0;
PlayerPlatform.KEY_ATTACK = 0;
PlayerPlatform.prototype.playExtraction = function() {
    this.unitSounds.playState("extraction")
};
PlayerPlatform.prototype.createIntro = function() {
    PlayerSettings.instance.isInLiberation && this.m_x - this.m_world.m_camera.m_x > .5 * this.m_world.m_camera.fixWidthRatio && this.setFlipX(!0);
    this.m_clip.visible = !1;
    Application.instance.playSound("SND_PLAYER_INTRO");
    this.clipIntro = PoolClips.instance.getClip(this.m_skinBase + "_intro");
    this.clipIntro.position.x = this.m_x - this.m_world.m_camera.getX();
    MissionManager.instance.isCooperative() && PlayerSettings.instance.isLastMultiplayerPlayer() ? this.clipIntro.position.y =
        this.m_y - this.m_world.m_camera.getY() : this.clipIntro.position.y = this.m_world.getFloorCollision(this.m_x, this.m_y).y - this.m_world.m_camera.getY();
    this.clipIntro.scale.x = this.m_flipX ? -this.m_scale : this.m_scale;
    this.clipIntro.scale.y = this.m_scale;
    this.clipIntro.onEndAnimation(this, this.onRemoveIntro);
    this.m_canvas.addChild(this.clipIntro);
    this.disablePlayer = !0;
    this.m_control.reset();
    if (this.clipIntro.gunContainer) {
        var a = Application.instance.getClip("mcGun" + (this.m_type === PlayerSettings.TYPE_HERA ? "Hera" :
            "Sabine"));
        a.scale.x /= Application.DPI;
        a.scale.y /= Application.DPI;
        this.clipIntro.gunContainer.addChild(a)
    }
    this.m_world.m_game.hud.setHudAnimation()
};
PlayerPlatform.prototype.setHold = function(a) {
    this.isHolding = a;
    this.m_clip.visible = !a;
    this.disablePlayer = a;
    this.shadowClip.visible = !a;
    this.m_isInvulnerable = a
};
PlayerPlatform.prototype.onEndLock = function() {
    this.m_world.m_camera.m_lockState = Camera.LOCK_ON
};
PlayerPlatform.prototype.onRemoveIntro = function() {
    PoolClips.instance.releaseClip(this.clipIntro);
    this.clipIntro = null;
    MissionManager.instance.isMissionRequirementComplete() && (this.setHold(!1), HudPlatform.instance.enableMobileControls(!0));
    if (PlayerSettings.instance.isLastMultiplayerPlayer() && MissionManager.instance.isCooperative() && MissionManager.instance.isMissionBossBattle()) switch (Global.level) {
        case 1:
            MissionManager.instance.isMissionRequirementComplete() ? this.isAwaitingWin = !0 : this.m_world.m_camera.doBlendWithPos(1675,
                1250, this.m_world.m_camera.fixOffsetX, 0, 5, !0, this, this.onEndLock, null);
            break;
        case 2:
            MissionManager.instance.isMissionRequirementComplete() ? this.isAwaitingWin = !0 : this.m_world.m_camera.doBlendWithPos(950, 675, this.m_world.m_camera.fixOffsetX, 0, 5, !0, this, this.onEndLock, null);
            break;
        case 3:
            MissionManager.instance.isMissionRequirementComplete() && (this.isAwaitingWin = !0)
    }
};
PlayerPlatform.prototype.onIntroSequence = function() {
    if (MissionManager.instance.isMissionRequirementComplete()) MissionManager.instance.isMissionBossBattle() || (GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_RETURN_EXTRACTION, HudPlatform.instance.addPopup(GuiPopupMessage, "mcGuiMessageMissionUpdate"), Global.game.world.actorManager().toggleExtractionPoints(!0));
    else if (MissionManager.instance.isCooperative())
        if (PlayerSettings.instance.hasSabotagedAll() && PlayerSettings.instance.hasSabotagedAllCoop()) {
            GuiPopupMessage.typeMessage =
                GuiPopupMessage.MESSAGE_RETURN_IMPERIALANTENNA;
            var a = HudPlatform.instance.addPopup(GuiPopupMessage, "mcGuiMessageMissionUpdateAntenna");
            a.doTimer = !1;
            a.isDoingBlend = !0;
            PlatformGame.instance.doIntroBlend()
        } else HudPlatform.instance.addPopup(GuiPopupIntroMission, "mcGuiMessageMission");
    else PlayerSettings.instance.hasSabotagedAll() ? (GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_RETURN_IMPERIALANTENNA, a = HudPlatform.instance.addPopup(GuiPopupMessage, "mcGuiMessageMissionUpdateAntenna"), a.doTimer = !1,
        a.isDoingBlend = !0, PlatformGame.instance.doIntroBlend()) : HudPlatform.instance.addPopup(GuiPopupIntroMission, "mcGuiMessageMission")
};
PlayerPlatform.prototype.setPositionAndInvulnerable = function(a, b) {
    this.setPosition(a, b);
    this.hitTimer = PlayerPlatform.HIT_TIME
};
PlayerPlatform.prototype.onSpecialAttack = function() {
    null === this.clipSpecialAttack && (this.m_type !== PlayerSettings.TYPE_HERA && this.unitSounds.playState("special"), this.specialTimer = 0, this.setFlipX(!1), this.disablePlayer = !0, this.m_control.reset(), this.waitUseSpecial = !1, this.m_isInvulnerable = !0, this.clipSpecialAttack = PoolClips.instance.getClip(this.m_skinBase + "_special" + this.m_skinBase_orientation), this.clipSpecialAttack.position.x = this.m_x, this.clipSpecialAttack.position.y = this.m_y, this.clipSpecialAttack.scale.x =
        this.m_scale, this.clipSpecialAttack.scale.y = this.m_scale, this.m_canvas.addChild(this.clipSpecialAttack), this.m_vehicle && (this.m_vehicle.pause = !0, this.m_vehicle.m_speed.x = 0, this.m_vehicle.m_speed.y = 0))
};
PlayerPlatform.prototype.onRemoveSpecialAttack = function() {
    PoolClips.instance.releaseClip(this.clipSpecialAttack);
    this.clipSpecialAttack = null;
    this.m_isInvulnerable = this.disablePlayer = !1;
    this.m_type == PlayerSettings.TYPE_HERA && this.setFlipX(!1);
    this.m_clip.scale.x = this.m_scaleX;
    this.gotoState(Player.ST_PLAYER_STAND);
    this.m_vehicle && (this.m_vehicle.pause = !1);
    this.specialOnCooldown = !0;
    this.specialCooldownTimer = 0;
    HudPlatform.instance.setVisibilitySpecialBlink(!1)
};
PlayerPlatform.prototype.getDataPlayer = function() {
    for (var a = null, b = Application.config.players.length - 1; 0 <= b; --b)
        if (Application.config.players[b].idPlayer === this.m_type) {
            a = Application.config.players[b];
            break
        }
    return a
};
PlayerPlatform.prototype.setActorClip = function(a) {};
PlayerPlatform.prototype.free = function() {
    this.m_vehicle && (this.m_vehicle.pause = !1);
    this.m_hitMove && (this.m_hitMove.free(), this.m_hitMove = null);
    this.m_dashMove && (this.m_dashMove.free(), this.m_dashMove = null);
    this.shadowClip && this.m_canvas.removeChild(this.shadowClip);
    Player.prototype.free.call(this)
};
PlayerPlatform.prototype.integrateVerlet = function(a) {
    var b = this.m_oldX,
        c = this.m_oldY;
    this.m_oldX = this.m_x;
    this.m_oldY = this.m_y;
    b = this.m_x - b;
    b < -this.m_control.maxVerletHorizontalDisplace ? b = -this.m_control.maxVerletHorizontalDisplace : b > this.m_control.maxVerletHorizontalDisplace && (b = this.m_control.maxVerletHorizontalDisplace);
    this.m_x += b;
    this.m_control.isJumpingUp() || this.verticalVerlet(a, c)
};
PlayerPlatform.prototype.verticalVerlet = function(a, b) {
    var c = this.m_y - b + this.m_control.gravity * a * a;
    c < -this.m_control.maxVerletUpDisplace ? c = -this.m_control.maxVerletUpDisplace : c > this.m_control.maxVerletDownDisplace && (c = this.m_control.maxVerletDownDisplace);
    this.m_y = 0 < c ? this.m_y + c * (1 - window.config.settings.fallingFriction) : this.m_y + c
};
PlayerPlatform.prototype.onKeyDown = function(a) {
    if (this.disablePlayer) {
        if (MissionManager.instance.isMissionTutorial() && (HudPlatform.instance.tutorialClips.specialKey && HudPlatform.instance.tutorialClips.specialKey.isActive || HudPlatform.instance.currentFinger && HudPlatform.instance.currentFinger.tutorialButton === GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK)) HudPlatform.instance.onKeyDown(a)
    } else if (!this.isAwaitingLose && !this.isAwaitingWin) {
        Player.prototype.onKeyDown.call(this, a);
        1 === PlayerSettings.instance.getCurrentTurn() ?
            PlayerSettings.instance.player1Played = !0 : PlayerSettings.instance.player2Played = !0;
        switch (a) {
            case PlayerPlatform.KEY_ATTACK:
                this.keyAttackTimer = 0;
                this.isPlaying || this.m_state === Player.ST_PLAYER_WIN || this.m_state === Player.ST_PLAYER_LOSE || (this.isPlaying = !0, GhostingManager.instance.startGhosting(this, this.m_world));
                if (PlayerSettings.instance.isPlayerMelee()) this.onPunch();
                else if (PlayerSettings.instance.isPlayerRange()) this.onShoot();
                this.playerAttacked || (this.playerAttacked = !0, HudPlatform.instance.removeTutorialAttack());
                break;
            case PlayerControl.CMD_LEFT_A:
                this.isPlaying || this.m_state === Player.ST_PLAYER_WIN || this.m_state === Player.ST_PLAYER_LOSE || (this.isPlaying = !0, GhostingManager.instance.startGhosting(this, this.m_world));
                this.m_state !== Player.ST_PLAYER_WALK && this.m_state !== Player.ST_PLAYER_RUN && this.shadowClip.resume();
                break;
            case PlayerControl.CMD_RIGHT_A:
                this.isPlaying || this.m_state === Player.ST_PLAYER_WIN || this.m_state === Player.ST_PLAYER_LOSE || (this.isPlaying = !0, GhostingManager.instance.startGhosting(this, this.m_world));
                this.m_state !== Player.ST_PLAYER_WALK && this.m_state !== Player.ST_PLAYER_RUN && this.shadowClip.resume();
                break;
            case PlayerControl.CMD_UP_A:
            case PlayerControl.CMD_UP_B:
                if (PlayerSettings.instance.isInLiberation && this.m_vehicle) break;
                this.m_control.onJump(!0);
                break;
            case PlayerPlatform.KEY_BOMB:
                this.isPlaying || this.m_state === Player.ST_PLAYER_WIN || this.m_state === Player.ST_PLAYER_LOSE || (this.isPlaying = !0, GhostingManager.instance.startGhosting(this, this.m_world)), this.specialOnCooldown || null !== this.clipSpecialAttack ||
                    (this.waitUseSpecial = !0), HudPlatform.instance.removeTutorialSpecial()
        }
        if (MissionManager.instance.isMissionTutorial()) HudPlatform.instance.onKeyDown(a)
    }
};
PlayerPlatform.prototype.getShadowClip = function() {
    var a = "";
    switch (this.m_type) {
        case PlayerSettings.TYPE_NONE:
        case PlayerSettings.TYPE_EZRA:
            a = "_ezra";
            break;
        case PlayerSettings.TYPE_KANAN:
            a = "_kanan";
            break;
        case PlayerSettings.TYPE_SABINE:
            a = "_sabine";
            break;
        case PlayerSettings.TYPE_HERA:
            a = "_hera";
            break;
        case PlayerSettings.TYPE_ZEB:
            a = "_zeb";
            break;
        case PlayerSettings.TYPE_CHOPPER:
            a = "_chopper"
    }
    return "fxShadow" + a
};
PlayerPlatform.prototype.onKeyUp = function(a) {
    if (!this.disablePlayer && !this.isAwaitingLose && !this.isAwaitingWin) switch (Player.prototype.onKeyUp.call(this, a), a) {
        case PlayerControl.CMD_LEFT_A:
        case PlayerControl.CMD_RIGHT_A:
            if (0 === this.m_control.m_horizontalBuffer[0] && 0 === this.m_control.m_horizontalBuffer[1]) {
                this.shadowClip.gotoAndStop(1);
                break
            }
        case PlayerControl.CMD_UP_A:
        case PlayerControl.CMD_UP_B:
            this.m_control.onJump(!1)
    }
};
PlayerPlatform.prototype.world = function() {
    return this.m_world
};
PlayerPlatform.prototype.getX = function() {
    return this.m_x
};
PlayerPlatform.prototype.getY = function() {
    return this.m_y
};
PlayerPlatform.prototype.setPosition = function(a, b) {
    this.m_oldX = this.m_x = a;
    this.m_oldY = this.m_y = b
};
PlayerPlatform.prototype.isInDash = function() {
    return null !== this.m_dashMove
};
PlayerPlatform.prototype.boundsAttack = function() {
    return this.m_boundsAttack
};
PlayerPlatform.prototype.setInvulnerability = function(a) {
    this.m_isInvulnerable = a
};
PlayerPlatform.prototype.isLookingToLeft = function() {
    return 0 > this.m_clip.scale.x
};
PlayerPlatform.prototype.isJumping = function() {
    return this.m_control.isJumping()
};
PlayerPlatform.prototype.isJumpAttack = function() {
    return this.m_state === Player.ST_PLAYER_JUMP_SPECIAL
};
PlayerPlatform.prototype.toogleFreeMovement = function() {
    this.m_freeMovement = !this.m_freeMovement;
    Application.info("Player Free movement: " + this.m_freeMovement)
};
PlayerPlatform.prototype.lose = function(a) {
    a && MissionManager.instance.isCooperative() && !PlayerSettings.instance.isLastMultiplayerPlayer() && this.setRescue();
    this.isAwaitingLose = !0;
    this.loseByTimeout = a
};
PlayerPlatform.prototype.setRescue = function() {
    this.m_character.addState(Player.ST_PLAYER_LOSE, this.m_skinBase + "_rescue" + this.m_skinBase_orientation, [{
        caller: this,
        callback: this.playExtraction,
        frame: 50
    }])
};
PlayerPlatform.prototype.hasLost = function() {
    return this.m_state === Player.ST_PLAYER_LOSE
};
PlayerPlatform.prototype.onDash = function() {
    this.canChangeState() && (this.m_dashMove = new LinearMovement(this.m_x, this.m_y, .7), this.m_dashMove.setCallbacks(this, this.removeDashMove, null), this.m_dashMove.gotoPosition(this.m_x + (this.m_flipX ? -280 : 280), this.m_y), this.gotoState(PlayerPlatform.ST_PLAYER_DASH))
};
PlayerPlatform.prototype.gunShoot = function() {
    if (this.gunWeapon) {
        if (this.m_type === PlayerSettings.TYPE_CHOPPER) var a = this.m_flipX;
        else a = this.m_clip.name, a = "_b" === a.substr(a.length - 2, 2);
        var b = this.m_control.isJumping() ? this.bulletPositionJump.x : this.bulletPosition.x,
            c = this.m_control.isJumping() ? this.bulletPositionJump.y : this.bulletPosition.y,
            b = b + (0 === this.m_control.forceX() ? 0 : 50);
        this.gunWeapon.shoot(this.m_x + (a ? -b : b), this.m_y - c, a)
    }
};
PlayerPlatform.prototype.createBulletEnviroment = function() {
    var a = 200 * Math.random() + 300,
        b = 80 * Math.random() + 30,
        c = 60 * Math.random() + 50,
        d = .5 > Math.random() ? !0 : !1;
    this.m_world.m_actorManager.bulletManager.createForceBullet("mcBulletStormtrooper", this.m_x + (this.m_flipX ? a : -a), d ? this.m_world.m_camera.m_y : this.m_world.m_camera.m_y + Application.APP_HEIGHT, this.m_x + (this.m_flipX ? -b : b), this.m_y - c, 1.5, this.data.damageMelee, d ? -1 : 1)
};
PlayerPlatform.prototype.createDeflectBullet = function(a, b) {
    PlayerSettings.instance.setUsedPowerUp(0);
    PlayerSettings.instance.checkPowerUpAchievement();
    Application.instance.playSound("SND_PLAYER_SABINE_BLASTER");
    for (var c = window.config.weapons[0], d = [Common.gradToRadian(350), 0, Common.gradToRadian(10)], e = 0; e < d.length; e++) {
        var f = d[e] + (.5 < Math.random() ? .05 * Math.random() : .05 * -Math.random());
        this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_PLAYER, Bullet.NAME_SKIN_BULLET_ENEMY, a, b, c.range, f + (this.m_flipX ?
            3.14159 : 0), c.speed, c.damage, Bullet.FX_IMPACT_LASER_ENEMY, Bullet.SUB_TYPE_PLAYER_LASER)
    }
};
PlayerPlatform.prototype.createBulletStrike = function() {
    PlayerSettings.instance.setUsedPowerUp(1);
    PlayerSettings.instance.checkPowerUpAchievement();
    Application.instance.playSound("SND_PUP_STRIKEWAVE");
    var a = this.m_x + (this.m_flipX ? -30 : 30),
        b = this.m_y - 100;
    Global.game.createExplotionShader(a - this.m_world.m_camera.m_x, b - this.m_world.m_camera.m_y, 4);
    this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_PLAYER, "ani_special_fx_powerup", a, b, 800, this.m_flipX ? 3.14159 : 0, 1, this.data.damageMelee, Bullet.FX_IMPACT_LASER_PLAYER,
        Bullet.SUB_TYPE_PLAYER_WAVE)
};
PlayerPlatform.prototype.onFloor = function() {};
PlayerPlatform.prototype.setFlipX = function(a) {
    if (this.m_type !== PlayerSettings.TYPE_CHOPPER) {
        if (PlayerSettings.instance.isPlayerRange() && (PoolClips.instance.releaseClip(this.clipUpBody), this.clipUpBody = null, this.m_isActionMove = !1, this.m_state === Player.ST_PLAYER_WALK && this.m_clip.bodyContainer)) {
            this.clipUpBody = PoolClips.instance.getClip(this.m_skinBase + "_run_upbody" + this.m_skinBase_orientation);
            if (0 === this.m_scaleUpper.x || 0 === this.m_scaleUpper.y) this.m_scaleUpper.x = this.clipUpBody.scale.x, this.m_scaleUpper.y =
                this.clipUpBody.scale.y;
            this.clipUpBody.scale.x = this.m_scaleUpper.x / Application.DPI;
            this.clipUpBody.scale.y = this.m_scaleUpper.y / Application.DPI;
            this.m_clip.bodyContainer.addChild(this.clipUpBody)
        }
    } else Player.prototype.setFlipX.call(this, a)
};
PlayerPlatform.prototype.gotoState = function(a) {
    PlatformGame.playerUseExpel = !1;
    if (this.m_state !== Player.ST_PLAYER_LOSE && this.m_state !== Player.ST_PLAYER_WIN) {
        Player.prototype.gotoState.call(this, a);
        switch (this.m_state) {
            case Player.ST_PLAYER_JUMP_SPECIAL:
                (this.m_type === PlayerSettings.TYPE_CHOPPER || this.m_type === PlayerSettings.TYPE_SABINE || this.m_type === PlayerSettings.TYPE_ZEB || PlayerSettings.instance.isPlayerMelee()) && this.unitSounds.playState(a);
                break;
            case Player.ST_PLAYER_HIT:
                this.unitSounds.playState(a);
                this.m_clip.loop = !1;
                break;
            case Player.ST_PLAYER_WIN:
                this.finishedPlaying = this.m_isInvulnerable = !0;
                var b = !Application.instance.isSoundOn();
                Application.instance.soundManager.m_muted = !1;
                Application.instance.stopAllSounds();
                Application.instance.soundManager.m_muted = b;
                this.m_world.oocManager.forceToggleAll(!1);
                this.isPlaying = !1;
                PlayerSettings.instance.updatePlayerState(!0);
                MissionManager.instance.isVersus() ? Application.instance.playSound("SND_BG_VS_WINNER") : Application.instance.playSound("SND_BG_WIN");
            case Player.ST_PLAYER_LOSE:
                this.finishedPlaying = this.m_isInvulnerable = !0;
                this.hitTimer = 0;
                this.m_clip.alpha = 1;
                this.shadowClip.gotoAndStop(1);
                this.m_world.oocManager.forceToggleAll(!1);
                this.isPlaying = !1;
                this.clipSpecialAttack && (PoolClips.instance.releaseClip(this.clipSpecialAttack), this.clipSpecialAttack = null, this.m_clip.visible = !0, HudPlatform.instance.showSpecialBar = !1, HudPlatform.instance.doSpecialBlink = !1);
                this.unitSounds.playState(a);
                this.removePowerUp(this.activePowerUp);
                this.m_state !== Player.ST_PLAYER_WIN &&
                    (PlayerSettings.instance.updatePlayerState(!1), this.attachTroopers());
                break;
            default:
                this.m_state !== PlayerPlatform.ST_PLAYER_PUNCH && this.m_state !== PlayerPlatform.ST_PLAYER_SHOOT && this.unitSounds.playState(a)
        }
        if (PlayerSettings.instance.isPlayerRange() && (PoolClips.instance.releaseClip(this.clipUpBody), this.clipUpBody = null, this.m_isActionMove = !1, this.m_state === Player.ST_PLAYER_WALK && this.m_clip.bodyContainer)) {
            this.clipUpBody = PoolClips.instance.getClip(this.m_skinBase + "_run_upbody" + this.m_skinBase_orientation);
            if (0 === this.m_scaleUpper.x || 0 === this.m_scaleUpper.y) this.m_scaleUpper.x = this.clipUpBody.scale.x, this.m_scaleUpper.y = this.clipUpBody.scale.y;
            this.clipUpBody.scale.x = this.m_scaleUpper.x / Application.DPI;
            this.clipUpBody.scale.y = this.m_scaleUpper.y / Application.DPI;
            this.m_clip.bodyContainer.addChild(this.clipUpBody)
        }
        this.updateBounds();
        this.updateGunClip()
    }
};
PlayerPlatform.prototype.attachTroopers = function() {
    if (this.m_clip["container-e2"]) {
        var a = PoolClips.instance.getClip("chr_mandalorian_stand");
        a.scale.x /= Application.DPI;
        a.scale.y /= Application.DPI;
        this.m_clip["container-e2"].addChild(a)
    }
    this.m_clip["container-e1"] && (a = PoolClips.instance.getClip("chr_mandalorian_stand"), a.scale.x /= Application.DPI, a.scale.y /= Application.DPI, this.m_clip["container-e1"].addChild(a))
};
PlayerPlatform.prototype.onEndShootWalking = function() {
    0 !== this.m_control.forceX() ? this.gotoState(Player.ST_PLAYER_WALK) : this.gotoState(Player.ST_PLAYER_STAND);
    this.m_isActionMove = !1;
    this.fixShootWalk = !0
};
PlayerPlatform.prototype.onEnemyCollision = function(a, b) {
    return !this.m_isInvulnerable && this.onHit(this.m_x > a.m_x ? 30 : -30) ? (1 === PlayerSettings.instance.getCurrentTurn() ? PlayerSettings.instance.player1GotDamage = !0 : PlayerSettings.instance.player2GotDamage = !0, this.m_health -= b, 0 >= this.m_health && (this.m_health = 0, this.isAwaitingLose = !0), HudPlatform.instance.setEnergyBar(Math.floor(this.m_health)), !0) : !1
};
PlayerPlatform.prototype.onBulletCollision = function(a, b) {
    return !this.m_isInvulnerable && this.onHit(this.m_x > a.x ? 30 : -30) ? (1 === PlayerSettings.instance.getCurrentTurn() ? PlayerSettings.instance.player1GotDamage = !0 : PlayerSettings.instance.player2GotDamage = !0, Global.game.onShake(4, 10, 200), this.m_health -= b, 0 >= this.m_health && (this.m_health = 0, this.isAwaitingLose = !0), HudPlatform.instance.setEnergyBar(Math.floor(this.m_health)), !0) : !1
};
PlayerPlatform.prototype.onHit = function(a) {
    if (0 < this.hitTimer || this.m_hitMove || this.m_state === Player.ST_PLAYER_HIT || this.m_state === Player.ST_PLAYER_LOSE || this.m_state === Player.ST_PLAYER_CELEBRATE || this.clipShield || this.disablePlayer) return !1;
    this.removeDashMove(null);
    this.gotoState(Player.ST_PLAYER_HIT);
    0 !== a && (this.m_hitMove = new ParametricParabolicMovement(Math.floor(this.m_x), Math.floor(this.m_y), Math.floor(this.m_x + a), Math.floor(this.m_y - 10), .04, .13), this.m_hitMove.onComplete(this, this.removeHit),
        this.m_hitMove.target = this);
    return !0
};
PlayerPlatform.prototype.removeHit = function(a) {
    this.m_hitMove && (this.m_hitMove.free(), this.m_hitMove = null);
    this.m_control.isJumping() ? this.gotoState(Player.ST_PLAYER_JUMP_DOWN) : this.gotoState(Player.ST_PLAYER_STAND);
    this.m_state !== Player.ST_PLAYER_WIN && this.m_state !== Player.ST_PLAYER_LOSE && (this.hitTimer = PlayerPlatform.HIT_TIME)
};
PlayerPlatform.prototype.onEnterZone = function(a) {
    Player.prototype.onEnterZone.call(this, a)
};
PlayerPlatform.prototype.onEndAnimation = function(a) {
    Player.prototype.onEndAnimation.call(this, a);
    if (a === Player.ST_PLAYER_LOSE || a === Player.ST_PLAYER_WIN) switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            MissionManager.instance.isCooperative() ? PlayerSettings.instance.updateCollectedItemsCoop(PlatformGame.instance.totalTimerRound()) : PlayerSettings.instance.updateCollectedItems(PlatformGame.instance.totalTimerRound());
            break;
        case MissionManager.MISSION_LIBERATION:
            MissionManager.instance.isCooperative() ?
                PlayerSettings.instance.updateLiberatedBasesCoop(PlatformGame.instance.totalTimerRound()) : PlayerSettings.instance.updateLiberatedBases(PlatformGame.instance.totalTimerRound());
            break;
        case MissionManager.MISSION_SABOTAGE:
            MissionManager.instance.isCooperative() ? PlayerSettings.instance.updateSabotagesCoop(PlatformGame.instance.totalTimerRound()) : PlayerSettings.instance.updateSabotages(PlatformGame.instance.totalTimerRound());
            break;
        case MissionManager.MISSION_BOSS_BATTLE:
            PlayerSettings.instance.updateBossTime(PlatformGame.instance.totalTimerRound())
    }
    switch (a) {
        case Player.ST_PLAYER_WIN:
            if (MissionManager.instance.isMissionTutorial()) {
                GuiPopupMissionCompleted.typeMessage =
                    GuiPopupMissionCompleted.TUTORIAL_COMPLETE;
                GuiGame.instance.addPopup(GuiPopupMissionCompleted, "mcGuiMessageMissionComplete", 0, 0);
                break
            }
        case Player.ST_PLAYER_LOSE:
            this.m_clip.stop();
            this.setHold(!0);
            this.isPlaying = !1;
            if (this.hasLost())
                if (a = !Application.instance.isSoundOn(), Application.instance.soundManager.m_muted = !1, Application.instance.stopAllSounds(), Application.instance.soundManager.m_muted = a, MissionManager.instance.isCooperative() && !PlayerSettings.instance.isLastMultiplayerPlayer()) {
                    a = !1;
                    switch (MissionManager.instance.m_missionType) {
                        case MissionManager.MISSION_COLLECTION:
                            PlayerSettings.instance.m_itemsRemaining <=
                                .4 * PlayerSettings.instance.getTotalItems() && (a = !0);
                            break;
                        case MissionManager.MISSION_LIBERATION:
                            PlayerSettings.instance.m_basesLiberated <= .4 * PlayerSettings.instance.getTotalBases() && (a = !0);
                            break;
                        case MissionManager.MISSION_SABOTAGE:
                            PlayerSettings.instance.m_sabotagesRemaining <= .4 * PlayerSettings.instance.getTotalSabotages() && (a = !0);
                            break;
                        case MissionManager.MISSION_BOSS_BATTLE:
                            var b = 0;
                            switch (Global.level) {
                                case 1:
                                    b = Application.config.atdp.initHealthCoop;
                                    break;
                                case 2:
                                    b = Application.config.atat.initHealthCoop;
                                    break;
                                case 3:
                                    b = Application.config.tie_fighter.initHealthCoop
                            }
                            PlayerSettings.instance.damageToBossP1 >= .4 * b && (a = !0)
                    }
                    a ? Application.instance.playSound("SND_BG_COOP_40") : Application.instance.playSound("SND_BG_LOSE")
                } else Application.instance.playSound("SND_BG_LOSE");
            PlayerSettings.instance.isMultiplayer() && (PlayerSettings.instance.isLastMultiplayerPlayer() ? (GhostingManager.instance.clear(), this.hasLost() && (PlayerSettings.instance.player2LoseByHealth = !this.loseByTimeout)) : (GhostingManager.instance.stopRecording(),
                PlatformGame.instance.onGameReset(!0), this.hasLost() && (PlayerSettings.instance.player1LoseByHealth = !this.loseByTimeout)));
            MissionManager.instance.isSinglePlayer() && (this.hasLost() ? (GuiPopupEndTurn.typeMessage = this.loseByTimeout ? GuiPopupEndTurn.TIMEOUT : GuiPopupEndTurn.CAPTURED, GuiGame.instance.addPopup(GuiPopupEndTurn, "mcGuiMessageTurnEnd")) : (GuiPopupMissionCompleted.typeMessage = GuiPopupMissionCompleted.MISSION_COMPLETE, GuiGame.instance.addPopup(GuiPopupMissionCompleted, "mcGuiMessageMissionComplete")),
                PlatformGame.instance.onGameEnd(!0));
            PlayerSettings.instance.isMultiplayer() && (this.hasLost() ? PlayerSettings.instance.isLastMultiplayerPlayer() ? (GuiPopupEndTurn.typeMessage = this.loseByTimeout ? GuiPopupEndTurn.TIMEOUT : GuiPopupEndTurn.CAPTURED, GuiGame.instance.addPopup(GuiPopupEndTurn, "mcGuiMessageTurnEnd")) : this.loseByTimeout ? (GuiPopupMissionCompleted.typeMessage = GuiPopupMissionCompleted.END_TURN, GuiGame.instance.addPopup(GuiPopupMissionCompleted, "mcGuiMessageMissionComplete")) : (GuiPopupEndTurn.typeMessage =
                GuiPopupEndTurn.CAPTURED, GuiGame.instance.addPopup(GuiPopupEndTurn, "mcGuiMessageTurnEnd")) : (GuiPopupMissionCompleted.typeMessage = GuiPopupMissionCompleted.MISSION_COMPLETE, GuiGame.instance.addPopup(GuiPopupMissionCompleted, "mcGuiMessageMissionComplete")));
            break;
        case PlayerPlatform.ST_PLAYER_PUNCH:
        case PlayerPlatform.ST_PLAYER_SHOOT:
            this.m_control.isJumping() ? this.gotoState(Player.ST_PLAYER_JUMP_DOWN) : this.gotoState(Player.ST_PLAYER_STAND);
            break;
        case Player.ST_PLAYER_HIT:
            this.m_control.isJumping() &&
                this.gotoState(Player.ST_PLAYER_JUMP_DOWN);
            break;
        case Player.ST_PLAYER_CELEBRATE:
            this.gotoState(Player.ST_PLAYER_STAND)
    }
};
PlayerPlatform.prototype.onPlayerFellOutOfWorld = function() {
    this.m_isDead || (this.m_timerDie = PlayerPlatform.DIE_TIME, this.m_isDead = !0)
};
PlayerPlatform.prototype.onWin = function(a) {
    this.m_state !== Player.ST_PLAYER_WIN && (this.isAwaitingWin = !0, HudPlatform.instance.enableHud(!1), a && this.m_character.addState(Player.ST_PLAYER_WIN, this.m_skinBase + "_rescue" + this.m_skinBase_orientation))
};
PlayerPlatform.prototype.onGlide = function(a) {
    this.m_inGlide != a && (this.m_inGlide = a, this.m_character.addState(Player.ST_PLAYER_JUMP_DOWN, this.m_skinBase + "_jump" + this.m_skinBase_orientation), this.m_state === Player.ST_PLAYER_JUMP_DOWN && (this.m_state = -1, this.gotoState(Player.ST_PLAYER_JUMP_DOWN)))
};
PlayerPlatform.prototype.removeDashMove = function(a) {
    null !== this.m_dashMove && (this.m_dashMove.free(), this.m_dashMove = null, this.m_tempCol && this.gotoState(Player.ST_PLAYER_STAND))
};
PlayerPlatform.aniCoverId = 1;
PlayerPlatform.aniAttackId = 1;
PlayerPlatform.prototype.onPunch = function() {
    if (this.canChangeState()) {
        var a = [],
            b = "";
        if (this.m_control.isJumping()) b = PlayerPlatform.ST_PLAYER_PUNCH, 0 < this.meleeStrikeTimer ? (PlayerPlatform.aniAttackId = Common.randomInt(4, 6), a = [{
            caller: this,
            callback: this.createBulletStrike,
            frame: 4
        }], this.m_character.addState(b, this.m_skinBase + "_attack_air2" + this.m_skinBase_orientation, a)) : (this.m_character.addState(b, this.m_skinBase + "_attack_air" + this.m_skinBase_orientation), this.unitSounds.playState(PlayerPlatform.ST_PLAYER_PUNCH));
        else if (b =
            PlayerPlatform.ST_PLAYER_PUNCH, 0 < this.meleeStrikeTimer && (PlatformGame.playerNearEnemy = !0, PlatformGame.playerCanUseForce = !1), PlatformGame.playerNearEnemy || this.clipShield) {
            3 > PlayerPlatform.aniAttackId && (a = [{
                caller: this,
                callback: this.enableRepeatState,
                frame: 9
            }]);
            0 < this.meleeStrikeTimer && (PlayerPlatform.aniAttackId = Common.randomInt(4, 6), a.push({
                caller: this,
                callback: this.createBulletStrike,
                frame: 4
            }));
            if (PlatformGame.playerCanUseForce && !MissionManager.instance.isMissionBossBattle()) {
                var c = 1 < PlayerPlatform.aniAttackId &&
                    .45 > Math.random() ? "4" : PlayerPlatform.aniAttackId;
                this.m_character.addState(b, this.m_skinBase + "_attack" + c + this.m_skinBase_orientation, a);
                "4" === c ? this.unitSounds.playState("forceAttack") : this.unitSounds.playState(PlayerPlatform.ST_PLAYER_PUNCH)
            } else this.m_character.addState(b, this.m_skinBase + "_attack" + PlayerPlatform.aniAttackId + this.m_skinBase_orientation, a), 0 >= this.meleeStrikeTimer && this.unitSounds.playState(PlayerPlatform.ST_PLAYER_PUNCH);
            PlayerPlatform.aniAttackId++;
            3 < PlayerPlatform.aniAttackId &&
                (PlayerPlatform.aniAttackId = 1)
        } else PlayerPlatform.aniCoverId = 1 === PlayerPlatform.aniCoverId ? 2 : 1, c = PlayerPlatform.aniCoverId, a = [{
            caller: this,
            callback: this.enableRepeatState,
            frame: 5
        }], this.unitSounds.playState(PlayerPlatform.ST_PLAYER_PUNCH), this.m_character.addState(b, this.m_skinBase + "_cover" + c + this.m_skinBase_orientation, a), PlayerPlatform.aniAttackId = 1;
        this.gotoState(b);
        if (b === PlayerPlatform.ST_PLAYER_PUNCH) this.m_control.onAction(!0)
    }
};
PlayerPlatform.prototype.enableRepeatState = function() {
    this.canRepeatState = !0
};
PlayerPlatform.prototype.updateGunClip = function() {
    if (this.gunWeapon) {
        this.gunWeapon.clearGunClips();
        if (0 === this.m_scaleGun.x || 0 === this.m_scaleGun.y) this.m_scaleGun.x = this.gunWeapon.clip.scale.x, this.m_scaleGun.y = this.gunWeapon.clip.scale.y;
        0 < this.m_scaleGun.x && (this.gunWeapon.clip.scale.x = this.m_scaleGun.x / Application.DPI, this.gunWeapon.clip.scale.y = this.m_scaleGun.y / Application.DPI);
        this.m_clip.gunContainer ? this.m_clip.gunContainer.addChild(this.gunWeapon.clip) : this.clipUpBody && this.clipUpBody.gunContainer &&
            this.clipUpBody.gunContainer.addChild(this.gunWeapon.clip)
    }
};
PlayerPlatform.prototype.onShoot = function() {
    if (this.canChangeState() && this.m_state !== Player.ST_PLAYER_LAND) {
        var a = "";
        this.m_control.isJumping() ? (a = PlayerPlatform.ST_PLAYER_SHOOT, this.m_character.addState(a, this.m_skinBase + "_jump_attack" + this.m_skinBase_orientation, this.frameShootFunctions), this.gotoState(a), this.m_control.onAction(!0)) : 0 !== this.m_control.forceX() ? this.m_isActionMove || (PoolClips.instance.releaseClip(this.clipUpBody), this.clipUpBody = PoolClips.instance.getClip(this.m_skinBase + "_run_upbody_attack" +
            this.m_skinBase_orientation), this.clipUpBody.onEndAnimation(this, this.onEndShootWalking), this.m_clip.bodyContainer && (this.clipUpBody.scale.x = this.m_scaleUpper.x / Application.DPI, this.clipUpBody.scale.y = this.m_scaleUpper.y / Application.DPI, this.m_clip.bodyContainer.addChild(this.clipUpBody), -1 === this.m_clip.bodyContainer.scale.x && (this.m_clip.bodyContainer.scale.x = 1)), this.updateGunClip(), this.m_isActionMove = !0) : (a = PlayerPlatform.ST_PLAYER_SHOOT, this.m_character.addState(a, this.m_skinBase + "_attack" +
            this.m_skinBase_orientation, this.frameShootFunctions), this.gotoState(a), this.m_control.onAction(!0))
    }
};
PlayerPlatform.prototype.canChangeState = function() {
    return this.canRepeatState ? !0 : this.m_state === Player.ST_PLAYER_HIT || this.m_state === Player.ST_PLAYER_LOSE || this.m_dashMove || this.m_hitMove || this.m_control.isInAction() ? !1 : !0
};
PlayerPlatform.prototype.showInCamera = function(a) {
    this.m_character.setPosition(this.m_x - a.getX(), this.m_y - a.getY())
};
PlayerPlatform.prototype.checkTimer = function(a) {
    if (!PlayerSettings.instance.isInLiberation && -1 !== this.missionActionTimer && (this.missionActionTimer += a, this.missionActionTimer >= Application.config.settings["timeIntervalToShowHintsPlanet" + Global.level])) switch (this.missionActionTimer = -1, MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            Global.game.world.oocManager.activatePlanetHints(3);
            break;
        case MissionManager.MISSION_LIBERATION:
            Global.game.world.oocManager.activatePlanetHints(3);
            break;
        case MissionManager.MISSION_SABOTAGE:
            Global.game.world.oocManager.activatePlanetHints(3)
    }
};
PlayerPlatform.prototype.resetMissionActionTimer = function() {
    this.missionActionTimer = -1;
    switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            Global.game.world.oocManager.setActiveOfType(ActorManagerPlatform.ITEM_COLLECTIBLE, !1);
            break;
        case MissionManager.MISSION_LIBERATION:
            Global.game.world.oocManager.setActiveOfType(ActorManagerPlatform.CONQUER_BASE_SP, !1);
            break;
        case MissionManager.MISSION_SABOTAGE:
            Global.game.world.oocManager.setActiveOfType(ActorManagerPlatform.IMPERIAL_MACHINE, !1)
    }
};
PlayerPlatform.prototype.onActiveShield = function(a) {
    this.clipShield && (PoolClips.instance.releaseClip(this.clipShield), this.clipShield = null);
    this.clipShield = PoolClips.instance.getClip("aniFxPoweruoPlasmaShield");
    this.clipShield.timer = a;
    this.m_world.canvasEffects.addChild(this.clipShield)
};
PlayerPlatform.prototype.onActiveStrikeWave = function(a) {
    this.meleeStrikeTimer = a
};
PlayerPlatform.prototype.createPowerupEffects = function(a) {
    var b = "";
    switch (a) {
        case ItemWorld.TYPE_SHIELD:
            return;
        case ItemWorld.TYPE_PU_STRIKEWAVE:
            b = "force_powerup_wave_";
            break;
        case ItemWorld.TYPE_PU_PERFECTDEFLECT:
            b = "force_powerup_deflect_";
            break;
        case ItemWorld.TYPE_PU_MULTIBLASTER:
            b = "force_powerup_sonic_blaster_";
            break;
        case ItemWorld.TYPE_PU_EXPLOSIVEBLASTER:
            b = "force_powerup_explosive_blaster_"
    }
    this.powerup_backFx = PoolClips.instance.getClip(b + "back");
    this.powerup_frontFx = PoolClips.instance.getClip(b +
        "front");
    this.m_world.canvasEffects.addChild(this.powerup_frontFx);
    this.effectCanvas.addChild(this.powerup_backFx);
    this.fx = this.m_world.createEffect("aniFxParticleForce", this.m_x, this.m_y)
};
PlayerPlatform.prototype.checkCollisionShield = function(a, b) {
    return this.clipShield && a > this.clipShield.position.x - PlayerPlatform.SHIELD_RANGE && a < this.clipShield.position.x + PlayerPlatform.SHIELD_RANGE && b > this.clipShield.position.y - PlayerPlatform.SHIELD_RANGE && b < this.clipShield.position.y + PlayerPlatform.SHIELD_RANGE ? !0 : !1
};
PlayerPlatform.prototype.activatePowerUp = function(a, b) {
    this.removePowerUp(this.activePowerUp);
    this.createPowerupEffects(a);
    this.activePowerUp = a;
    switch (a) {
        case ItemWorld.TYPE_SHIELD:
            this.onActiveShield(b);
            this.playedShieldWarning = !1;
            break;
        case ItemWorld.TYPE_PU_STRIKEWAVE:
            this.onActiveStrikeWave(b);
            break;
        case ItemWorld.TYPE_PU_PERFECTDEFLECT:
            this.deflectQuantity = b;
            break;
        case ItemWorld.TYPE_PU_MULTIBLASTER:
            this.gunWeapon.setGun(GunWeapon.GUN_MULTI, b);
            break;
        case ItemWorld.TYPE_PU_EXPLOSIVEBLASTER:
            this.gunWeapon.setGun(GunWeapon.GUN_EXPLOSIVE,
                b)
    }
};
PlayerPlatform.prototype.removePowerUp = function(a, b) {
    this.powerupPulseVanish = !1;
    if (b) this.doRemovePowerupWithAlpha = !0;
    else {
        this.doRemovePowerupWithAlpha = !1;
        this.fx && (this.fx.isAwaitingDelete = !0, this.fx = null);
        this.powerup_backFx && (PoolClips.instance.releaseClip(this.powerup_backFx), this.effectCanvas.removeChild(this.powerup_backFx), this.powerup_backFx = null);
        this.powerup_frontFx && (PoolClips.instance.releaseClip(this.powerup_frontFx), this.m_world.canvasEffects.removeChild(this.powerup_frontFx), this.powerup_frontFx =
            null);
        switch (a) {
            case ItemWorld.TYPE_SHIELD:
                PoolClips.instance.releaseClip(this.clipShield);
                this.m_world.canvasEffects.removeChild(this.clipShield);
                this.m_world.createEffect("aniFxPoweruoShieldDesapear", this.m_x, this.m_y - 70);
                this.clipShield = null;
                Application.instance.playSound("SND_PUP_SHIELD_OFF");
                break;
            case ItemWorld.TYPE_PU_STRIKEWAVE:
                this.meleeStrikeTimer = 0;
                break;
            case ItemWorld.TYPE_PU_MULTIBLASTER:
                this.gunWeapon.setGun(GunWeapon.GUN_BASIC);
                break;
            case ItemWorld.TYPE_PU_EXPLOSIVEBLASTER:
                this.gunWeapon.setGun(GunWeapon.GUN_BASIC)
        }
        this.activePowerUp = -1
    }
    HudPlatform.instance.removePowerUp(a)
};
PlayerPlatform.prototype.update = function(a) {
    if (!this.isHolding) {
        if (this.isGrounded) {
            if (this.isAwaitingLose && this.m_state !== Player.ST_PLAYER_LOSE && this.m_state !== Player.ST_PLAYER_HIT && !this.clipSpecialAttack) {
                this.gotoState(Player.ST_PLAYER_LOSE);
                return
            }
            if (this.isAwaitingWin && this.m_state !== Player.ST_PLAYER_WIN && this.m_state !== Player.ST_PLAYER_HIT && !this.clipSpecialAttack) {
                this.gotoState(Player.ST_PLAYER_WIN);
                return
            }
        }
        this.doRemovePowerupWithAlpha && (this.removeAlphaTimer += a, this.powerup_backFx && (this.powerup_backFx.alpha =
            1 - this.removeAlphaTimer / 1E3), this.powerup_frontFx && (this.powerup_backFx.alpha = 1 - this.removeAlphaTimer / 1E3), 1E3 <= this.removeAlphaTimer && (this.removePowerUp(this.activePowerUp), this.removeAlphaTimer = 0, this.doRemovePowerupWithAlpha = !1));
        this.updateShadow(a);
        this.tutorialComponent && this.tutorialComponent.update(a);
        this.isPlaying && this.checkTimer(a);
        this.specialOnCooldown && (this.specialCooldownTimer += a, HudPlatform.instance.setSpecialBar(~~(this.specialCooldownTimer / this.data.specialCooldown * 100), !1), this.specialCooldownTimer >=
            this.data.specialCooldown && (this.specialOnCooldown = !1, HudPlatform.instance.setVisibilitySpecialReadyToUse(!0)));
        0 < this.m_timerDie && (this.m_timerDie -= a, 0 >= this.m_timerDie && this.gotoState(Player.ST_PLAYER_LOSE));
        this.powerup_backFx && (this.powerup_backFx.update(a), this.powerup_backFx.position.x = this.m_x - this.m_world.m_camera.m_x, this.powerup_backFx.position.y = this.m_y - 70 - this.m_world.m_camera.m_y);
        this.powerup_frontFx && (this.powerup_frontFx.update(a), this.powerup_frontFx.position.x = this.m_x, this.powerup_frontFx.position.y =
            this.m_y - 70);
        this.fx && (this.fx.x = this.m_x, this.fx.y = this.m_y);
        switch (this.activePowerUp) {
            case ItemWorld.TYPE_SHIELD:
                this.clipShield && (this.clipShield.update(a), this.clipShield.position.x = this.m_x, this.clipShield.position.y = this.m_y - 70, this.reducePowerUpAmount(a, ItemWorld.TYPE_SHIELD));
                break;
            case ItemWorld.TYPE_PU_EXPLOSIVEBLASTER:
            case ItemWorld.TYPE_PU_MULTIBLASTER:
            case ItemWorld.TYPE_PU_STRIKEWAVE:
            case ItemWorld.TYPE_PU_PERFECTDEFLECT:
                this.reducePowerUpAmount(a, this.activePowerUp)
        }
        if (this.m_dashMove) {
            this.m_oldX =
                this.m_x;
            this.m_oldY = this.m_y;
            var b = new Vector2D(this.m_x, this.m_y),
                c = this.m_dashMove.simulateUpdate(a),
                d = c.clone();
            d.stretch(.9 * this.m_world.tileWidth());
            for (this.m_tempCol = null; null == this.m_tempCol;)
                if (c.length() > d.length()) {
                    if (b.add(d), c.subtract(d), this.m_x = b.x, this.m_y = b.y, this.m_tempCol = this.m_world.checkCollision(this)) this.m_x += this.m_tempCol.x, this.m_y += this.m_tempCol.y, this.removeDashMove(null)
                } else {
                    b.add(c);
                    this.m_x = b.x;
                    this.m_y = b.y;
                    if (this.m_tempCol = this.m_world.checkCollision(this)) this.m_x +=
                        this.m_tempCol.x, this.m_y += this.m_tempCol.y, this.removeDashMove(null);
                    break
                }
            null == this.m_tempCol && this.m_dashMove.update(a);
            this.m_character.update(a)
        } else if (this.isReadyToTeleport ? HudPlatform.instance.showTeleportButton(!0) : HudPlatform.instance.showTeleportButton(!1), 0 < this.hitTimer && (this.hitTimer -= a, this.m_clip.alpha = 50 < this.hitTimer % 100 ? .4 : .7, 0 >= this.hitTimer && (this.m_clip.alpha = 1)), this.m_hitMove) {
            this.m_oldX = this.m_x;
            this.m_oldY = this.m_y;
            this.m_x = this.m_hitMove.getX();
            this.m_y = this.m_hitMove.getY();
            this.m_hitMove.update(a);
            if (this.m_tempCol = this.m_world.checkCollision(this)) this.m_x += this.m_tempCol.x, this.m_y += this.m_tempCol.y, this.removeHit(null);
            this.m_character.update(a)
        } else {
            this.clipUpBody && this.m_isActionMove && this.fixShootWalk && this.clipUpBody.currentFrame === this.frameShootUpBody && (this.gunShoot(), this.fixShootWalk = !1);
            Player.prototype.update.call(this, a);
            this.m_clip.visible = !0;
            if (this.clipSpecialAttack)
                if (this.clipSpecialAttack.position.x = this.m_x - this.m_world.m_camera.getX(), this.clipSpecialAttack.position.y =
                    this.m_y - this.m_world.m_camera.getY(), this.clipSpecialAttack.update(a), HudPlatform.instance.setSpecialBar(~~(100 * (1 - this.clipSpecialAttack.currentFrame / this.clipSpecialAttack.totalFrames)), !0), 1 >= this.clipSpecialAttack.totalFrames - this.clipSpecialAttack.currentFrame || !this.clipSpecialAttack) {
                    this.onRemoveSpecialAttack();
                    this.m_clip.visible = !0;
                    if (this.tutorialComponent) this.tutorialComponent.onEndSpecial();
                    this.onEndSpecial()
                } else this.m_clip.visible = !1;
            this.waitUseSpecial && this.isGrounded && 0 < this.m_health &&
                this.m_state !== Player.ST_PLAYER_JUMP_DOWN && (this.onSpecialAttack(), PlayerSettings.instance.specialTooltipshown = !0, HudPlatform.instance.setVisibilitySpecialReadyToUse(!1), HudPlatform.instance.setVisibilitySpecialBlink(!0));
            this.waitingForCelebrate && this.isGrounded && this.m_state !== Player.ST_PLAYER_JUMP_DOWN && (this.waitingForCelebrate = !1, this.gotoState(Player.ST_PLAYER_CELEBRATE), this.unitSounds.playState(Player.ST_PLAYER_WIN));
            this.clipIntro && (this.m_clip && (this.m_clip.visible = 79 < this.clipIntro.currentFrame,
                79 < this.clipIntro.currentFrame && !this.isIntroFinished && (this.didIntroCallback = this.isIntroFinished = !0, this.onIntroSequence())), this.clipIntro.update(a));
            PlayerSettings.instance.specialTooltipshown || (this.tooltipTimer += a, 1E3 <= this.tooltipTimer && !MissionManager.instance.isMissionTutorial() && 4 <= this.closeEnemies(this.m_x, this.m_y, 200) && (PlayerSettings.instance.specialTooltipshown = !0, Application.instance.isMobileDevice ? HudPlatform.instance.showFinger(GuiPopupMessage.TUTORIAL_SPECIAL_ATTACK) : HudPlatform.instance.showXKeyTutorial()));
            this.playerAttacked || (this.keyAttackTimer += a, this.keyAttackTimer >= window.config.settings.timeToShowAttackToolTip && 1 === Global.level && !MissionManager.instance.isMissionTutorial() && HudPlatform.instance.tutorialClips.specialKey && !HudPlatform.instance.tutorialClips.specialKey.isActive && (HudPlatform.instance.showTutorial(GuiPopupMessage.TUTORIAL_ATTACK), this.keyAttackTimer = 0))
        }
    }
};
PlayerPlatform.prototype.onEndSpecial = function() {};
PlayerPlatform.prototype.closeEnemies = function(a, b, c) {
    for (var d = 0, e = 0; e < this.m_world.m_actorManager.m_actors.length; e++) {
        var f = this.m_world.m_actorManager.m_actors[e];
        if (!f.isIdle && !f.isAwaitingDelete && "hazard" !== f.className) {
            var g = f.m_x - a,
                f = f.m_y - b;
            Math.sqrt(g * g + f * f) <= c && (d += 1)
        }
    }
    return d
};
PlayerPlatform.prototype.collectAllItems = function() {
    if (MissionManager.instance.isMissionCollection()) {
        PlayerSettings.instance.obtainItem(100);
        HudPlatform.instance.setCollectibles(PlayerSettings.instance.getCollectedItems(), PlayerSettings.instance.getTotalItems());
        for (var a = this.m_world.m_actorManager.m_actors, b = 0, b = 0; b < a.length; b++) {
            var c = a[b];
            "ItemCollectible" !== c.m_className || c.isAwaitingDelete || (c.isAwaitingDelete = !0)
        }
        GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_RETURN_EXTRACTION;
        HudPlatform.instance.addPopup(GuiPopupMessage,
            "mcGuiPopupDialogue")
    }
    MissionManager.instance.isMissionLiberation() && (PlayerSettings.instance.doLiberation(100), HudPlatform.instance.setCollectibles(PlayerSettings.instance.getBasesLiberated(), PlayerSettings.instance.getTotalBases()), PlayerSettings.instance.updateLiberatedBases(PlatformGame.instance.totalTimerRound()), this.m_world.m_player.onWin(!1));
    MissionManager.instance.isMissionSabotage() && (PlayerSettings.instance.doSabotage(100), HudPlatform.instance.setCollectibles(PlayerSettings.instance.getSabotagesDone(),
        PlayerSettings.instance.getTotalSabotages()), GuiPopupMessage.typeMessage = GuiPopupMessage.MESSAGE_RETURN_EXTRACTION, HudPlatform.instance.addPopup(GuiPopupMessage, "mcGuiPopupDialogue"));
    MissionManager.instance.isMissionBossBattle() && Atdp.instance && Atdp.instance.defeat()
};
PlayerPlatform.prototype.onSpringCollision = function(a, b, c, d) {
    this.m_state !== Player.ST_PLAYER_JUMP_UP && Application.externalTrack("Spring Activated", "x: " + d.getX() + " y: " + d.getY());
    Player.prototype.onSpringCollision.call(this, a, b, c, d)
};
PlayerPlatform.prototype.updateShadow = function(a) {
    if (Application.isLowDevice) this.clipIntro || !this.isGrounded ? this.shadowClip.visible = !1 : (this.shadowClip.visible = !0, this.shadowClip.position.x = this.m_x - this.m_world.m_camera.m_x, this.shadowClip.position.y = this.m_y - this.m_world.m_camera.m_y);
    else if (this.clipIntro) 55 <= this.clipIntro.currentFrame ? (this.shadowClip.visible = !0, this.shadowClip.scale.x = this.shadowClip.scale.y = this.shadowClip.alpha = SMath.setRange((this.clipIntro.currentFrame - 55) / 6, 1, 0), this.shadowClip.position.x =
        this.m_x - this.m_world.m_camera.m_x, this.shadowClip.position.y = this.m_y - this.m_world.m_camera.m_y, this.shadowClip.update(a)) : this.shadowClip.visible = !1;
    else if (this.m_state === Player.ST_PLAYER_WIN && 50 <= this.m_clip.currentFrame) this.shadowClip.scale.x = this.shadowClip.scale.y = this.shadowClip.alpha = SMath.setRange(1 - (this.m_clip.currentFrame - 50) / 6, 1, 0), this.shadowClip.position.x = this.m_x - this.m_world.m_camera.m_x, this.shadowClip.position.y = this.m_y - this.m_world.m_camera.m_y, this.shadowClip.update(a);
    else {
        var b =
            this.m_world.getFloorCollision(this.m_x, this.m_y);
        b ? (this.shadowClip.visible = !0, this.shadowClip.position.x = this.m_x - this.m_world.m_camera.m_x, this.shadowClip.position.y = b.y - this.m_world.m_camera.m_y, this.shadowClip.scale.x = this.shadowClip.scale.y = SMath.setRange(1 - (b.y - this.m_y) / 300, 1, .5), this.shadowClip.alpha = SMath.setRange(1 - (b.y - this.m_y) / 300, 1, .25), this.shadowClip.update(a)) : this.shadowClip.visible = !1
    }
};
PlayerPlatform.prototype.getOriginalAmount = function(a) {
    return Application.config.items[a].amount
};
PlayerPlatform.prototype.reducePowerUpAmount = function(a, b) {
    switch (b) {
        case ItemWorld.TYPE_PU_PERFECTDEFLECT:
            this.deflectQuantity - a <= ~~(.25 * this.getOriginalAmount(b)) && this.deflectQuantity >= ~~(.25 * this.getOriginalAmount(b)) && (HudPlatform.instance.setPowerUpFxState(2), this.powerupPulseVanish = !0);
            this.deflectQuantity -= a;
            0 >= this.deflectQuantity && this.removePowerUp(b, !0);
            break;
        case ItemWorld.TYPE_SHIELD:
            this.clipShield.timer - a <= ~~(.25 * this.getOriginalAmount(b)) && this.clipShield.timer >= ~~(.25 * this.getOriginalAmount(b)) &&
                (HudPlatform.instance.setPowerUpFxState(2), Application.instance.playSound("SND_PUP_SHIELD_WARNING"));
            this.clipShield.timer -= a;
            0 >= this.clipShield.timer && this.removePowerUp(b, !0);
            break;
        case ItemWorld.TYPE_PU_STRIKEWAVE:
            this.meleeStrikeTimer - a <= ~~(.25 * this.getOriginalAmount(b)) && this.meleeStrikeTimer >= ~~(.25 * this.getOriginalAmount(b)) && (HudPlatform.instance.setPowerUpFxState(2), this.powerupPulseVanish = !0);
            this.meleeStrikeTimer -= a;
            0 >= this.meleeStrikeTimer && this.removePowerUp(b, !0);
            break;
        case ItemWorld.TYPE_PU_MULTIBLASTER:
            PlayerSettings.instance.setUsedPowerUp(2);
            PlayerSettings.instance.checkPowerUpAchievement();
            this.gunWeapon.useCounter - a <= ~~(.25 * this.getOriginalAmount(b)) && this.gunWeapon.useCounter >= ~~(.25 * this.getOriginalAmount(b)) && (HudPlatform.instance.setPowerUpFxState(2), this.powerupPulseVanish = !0);
            this.gunWeapon.useCounter -= a;
            0 >= this.gunWeapon.useCounter && (this.gunWeapon.setGun(GunWeapon.GUN_BASIC), this.removePowerUp(b, !0));
            break;
        case ItemWorld.TYPE_PU_EXPLOSIVEBLASTER:
            PlayerSettings.instance.setUsedPowerUp(3), PlayerSettings.instance.checkPowerUpAchievement(),
                this.gunWeapon.useCounter - a <= ~~(.25 * this.getOriginalAmount(b)) && this.gunWeapon.useCounter >= ~~(.25 * this.getOriginalAmount(b)) && (HudPlatform.instance.setPowerUpFxState(2), this.powerupPulseVanish = !0), this.gunWeapon.useCounter -= a, 0 >= this.gunWeapon.useCounter && (this.gunWeapon.setGun(GunWeapon.GUN_BASIC), this.removePowerUp(b, !0))
    }
};
PlayerPlatform.prototype.setScaleX = function(a) {
    this.m_scaleX != a && (this.useSeparatedAnimations || null === this.m_clip || (this.m_clip.scale.x = this.m_flipX ? -a : a), this.m_scaleX = a, this.createCorners())
};

function BasicJoystick(a, b, c, d) {
    this.m_initPosX = c;
    BasicJoystick.NONE = -100;
    this.maxForce = "undefined" === typeof b ? 0 : b;
    this.x = "undefined" === typeof c ? 0 : c;
    this.y = "undefined" === typeof d ? 0 : d;
    this.identifier = BasicJoystick.NONE;
    this.forceX = 0;
    this.canvas = a;
    this.clipBaseLeft = Application.instance.getClip("mcGuiButtonControlLeft");
    this.clipBaseLeft.scale.x = 1.2;
    this.clipBaseLeft.scale.y = 1.2;
    this.clipBaseLeft.alpha = 1;
    this.clipBaseRight = Application.instance.getClip("mcGuiButtonControlRight");
    this.clipBaseRight.scale.x =
        1.2;
    this.clipBaseRight.scale.y = 1.2;
    this.clipBaseRight.alpha = 1;
    this.canvas.addChild(this.clipBaseLeft);
    this.canvas.addChild(this.clipBaseRight);
    this.baseDistance = 100;
    this.clipBaseLeft.setPosition(c - this.baseDistance, d);
    this.clipBaseRight.setPosition(c + this.baseDistance, d);
    this.m_rectangleCollision = new Rectangle(c - 2 * this.baseDistance, d - 65, 4 * this.baseDistance, 130);
    this.m_callbackChangeFunction = this.m_callbackChangeObject = this.m_callbackReleaseFunction = this.m_callbackReleaseObject = this.m_callbackPressFunction =
        this.m_callbackPressObject = null
}
BasicJoystick.prototype.free = function() {
    this.m_callbackChangeFunction = this.m_callbackChangeObject = this.m_callbackReleaseFunction = this.m_callbackReleaseObject = this.m_callbackPressFunction = this.m_callbackPressObject = null;
    this.canvas.removeChild(this.clipBaseLeft);
    this.canvas.removeChild(this.clipBaseRight);
    this.clipBaseLeft.free();
    this.clipBaseLeft = null;
    this.clipBaseRight.free();
    this.canvas = this.m_rectangleCollision = this.clipBaseRight = null
};
BasicJoystick.prototype.addPressListener = function(a, b) {
    this.m_callbackPressObject = a;
    this.m_callbackPressFunction = b
};
BasicJoystick.prototype.addReleaseListener = function(a, b) {
    this.m_callbackReleaseObject = a;
    this.m_callbackReleaseFunction = b
};
BasicJoystick.prototype.addChangeListener = function(a, b) {
    this.m_callbackChangeObject = a;
    this.m_callbackChangeFunction = b
};
BasicJoystick.prototype.updatePosition = function(a) {
    this.clipBaseLeft.position.x = this.m_initPosX + a - this.baseDistance;
    this.clipBaseRight.position.x = this.m_initPosX + a + this.baseDistance;
    this.m_rectangleCollision.x = this.m_initPosX + a - 2 * this.baseDistance
};
BasicJoystick.prototype.onPointerPress = function(a) {
    var b = a.data.global.x,
        c = a.data.global.y;
    this.identifier === BasicJoystick.NONE && this.m_rectangleCollision.intersectPoint(b, c) && (this.identifier = this.getIdentifier(a), a = this.m_rectangleCollision.left() + this.m_rectangleCollision.w / 2, this.forceX = b <= a ? -1 : 1, HudPlatform.instance.onJoystickPress(b <= a), null !== this.m_callbackPressObject && null !== this.m_callbackPressFunction && this.m_callbackPressFunction.call(this.m_callbackPressObject, this))
};
BasicJoystick.prototype.onPointerRelease = function(a) {
    this.identifier === this.getIdentifier(a) && this.doReleaseJoystick()
};
BasicJoystick.prototype.doReleaseJoystick = function() {
    this.identifier = BasicJoystick.NONE;
    this.forceX = 0;
    null !== this.m_callbackReleaseObject && null !== this.m_callbackReleaseFunction && this.m_callbackReleaseFunction.call(this.m_callbackReleaseObject, this)
};
BasicJoystick.prototype.onPointerMove = function(a) {
    var b = a.data.global.x,
        c = a.data.global.y;
    this.identifier === this.getIdentifier(a) && (this.m_rectangleCollision.intersectPoint(b, c) ? (a = this.m_rectangleCollision.left() + this.m_rectangleCollision.w / 2, this.forceX = b <= a ? -1 : 1) : this.forceX = 0, null !== this.m_callbackChangeObject && null !== this.m_callbackChangeFunction && this.m_callbackChangeFunction.call(this.m_callbackChangeObject, this))
};
BasicJoystick.prototype.getIdentifier = function(a) {
    return "undefined" !== typeof a.data.identifier ? a.data.identifier : a.data.originalEvent.which
};

function NavFloor(a, b, c, d, e, f, g) {
    this.distance = g || NavFloor.SCAN_INTERVAL;
    this.m_actor = b;
    this.m_world = a;
    this.points = [];
    this.setUpNavPoints(c, d, e, f);
    this.currentNavPointKey = this.getClosestNavKey(c);
    this.jumpDirection = this.maxNavPoint = this.minNavPoint = 0;
    this.setMinMax()
}
NavFloor.SCAN_INTERVAL = 24;
NavFloor.JUMP_DOWN = -1;
NavFloor.JUMP_UP = 1;
NavFloor.NO_JUMP = 0;
NavFloor.prototype.setMinMax = function() {
    this.minNavPoint = parseInt(Object.keys(this.points)[0], 10);
    this.maxNavPoint = parseInt(this.points.length, 10) - 1
};
NavFloor.prototype.setUpNavPoints = function(a, b, c, d) {
    d = a;
    var e = 0;
    for (d = a + this.distance; d < a + .5 * c;) {
        e = this.m_world.getCellInPosition(d, b);
        if (e !== WorldCollisionLayer.CELL_EMPTY)
            if (e = this.m_world.getCellInPosition(d, b - this.distance), e === WorldCollisionLayer.CELL_EMPTY) this.points[d] = b;
            else break;
        else break;
        d += this.distance
    }
    for (d = a - this.distance; d > a - .5 * c;) {
        e = this.m_world.getCellInPosition(d, b);
        if (e !== WorldCollisionLayer.CELL_EMPTY)
            if (e = this.m_world.getCellInPosition(d, b - this.distance), e === WorldCollisionLayer.CELL_EMPTY) this.points[d] =
                b;
            else break;
        else break;
        d -= this.distance
    }
};
NavFloor.prototype.getY = function(a) {
    return this.points[this.getClosestNavKey(a)]
};
NavFloor.prototype.getClosestNavKey = function(a) {
    if (this.m_actor.m_toLeft)
        for (var b = 1; b < Object.keys(this.points).length - 1; b++) {
            var c = parseInt(Object.keys(this.points)[b], 10);
            if (c >= a) return parseInt(Object.keys(this.points)[b - 1], 10)
        } else
            for (b = Object.keys(this.points).length - 2; 0 <= b; b--)
                if (c = parseInt(Object.keys(this.points)[b], 10), c <= a) return parseInt(Object.keys(this.points)[b + 1], 10);
    return a < this.minNavPoint ? this.minNavPoint : this.maxNavPoint
};
NavFloor.prototype.shouldJump = function(a, b, c, d) {
    var e = this.points[this.getClosestNavKey(a + (c ? -this.distance : this.distance))] - b,
        e = 0 > e ? -e : e;
    if (0 !== e && e > 2 * this.distance && e <= d) return this.jumpDirection = this.points[this.getClosestNavKey(a + (c ? -this.distance : this.distance))] > b ? NavFloor.JUMP_DOWN : NavFloor.JUMP_UP, !0;
    this.jumpDirection = NavFloor.NO_JUMP;
    return !1
};
NavFloor.prototype.isDiagonalWalk = function(a, b) {
    return 0 !== this.points[this.getClosestNavKey(a)] - b
};
NavFloor.prototype.updateCurrentNavKey = function(a) {
    this.currentNavPointKey = this.getClosestNavKey(a)
};
NavFloor.prototype.getCurrentNavYPos = function() {
    return this.points[this.currentNavPointKey]
};
NavFloor.prototype.clamp = function(a, b, c) {
    return Math.min(Math.max(a, b), c)
};
NavFloor.prototype.getRandomPoint = function() {
    var a = this.points || [],
        b = Object.keys(a).length,
        b = Common.randomInt(0, b - 1),
        c = parseInt(Object.keys(a)[b], 10);
    return {
        x: parseInt(c, 10),
        y: this.points[Object.keys(a)[b]]
    }
};
NavFloor.prototype.free = function() {
    this.m_world = this.points = null
};

function Stormtrooper(a, b, c, d, e, f) {
    this.shadowClip = this.bodyClip = this.bodyContainer = null;
    this.isSkyGenerated = f;
    this.isConquerGenerated = e;
    this.questionContainer = this.config = this.unitSounds = null;
    this.questionClip = PoolClips.instance.getClip("mark_interrogation");
    this.functions = [];
    this.classname = d;
    c.limitLeft = "undefined" === typeof c.limitLeft ? 200 : c.limitLeft;
    c.limitRight = "undefined" === typeof c.limitRight ? 200 : c.limitRight;
    this.config = this.getConfig(this.classname);
    BaseEnemy.call(this, a, b, c, null, 0);
    this.setDefaultViewLeft(!1);
    this.lastFrame = this.cooldownTimer = this.m_bulletsInARowCount = this.m_timerWalkBack = this.walkbackLimitX = this.m_betweenBulletsTimer = this.m_timer = this.m_attackTimer = 0;
    this.currentDetection = Stormtrooper.PLAYER_OUT_OF_SIGHT;
    this.currentPhase = 1;
    this.isWalkingBack = this.didWalkBackFlip = this.onAttackCooldown = !1;
    this.canBePushed = this.hasDropPool = !0;
    this.freezePos = this.dropsEnabled = !1;
    this.navFloor = this.m_move = null;
    c.useNavFloor && (this.navFloor = new NavFloor(b, this, this.m_x, this.m_y, c.limitLeft + c.limitRight, 400));
    this.isJumpResetting = this.isJumpOnCooldown = this.onWarningCooldown = !1;
    if ("Stormtrooper" === this.classname || "Shocktrooper" === this.classname) this.isConquerGenerated ? (this.gotoState(Stormtrooper.ST_APPEAR), this.setLookAtLeft(.5 < Math.random())) : this.isSkyGenerated ? (this.gotoState(Stormtrooper.ST_APPEAR_SKY), this.setLookAtLeft(this.m_world.m_player.m_x < this.m_x)) : (this.gotoState(Stormtrooper.ST_STAND), this.setLookAtLeft(this.freezePos ? !1 : .5 < Math.random()));
    this.waveDoor = null;
    this.unitSounds = new UnitSounds(this.classname)
}
Application.subclass(Stormtrooper, BaseEnemy);
Stormtrooper.DELAY_AFTER_LOS = 500;
Stormtrooper.PLUS_AFTER_LOS = 1E3;
Stormtrooper.WALKBACK_DELAY = 200;
Stormtrooper.ST_STAND = "st100";
Stormtrooper.ST_PATROL = "st101";
Stormtrooper.ST_ATTACK = "st102";
Stormtrooper.ST_WARNING = "st105";
Stormtrooper.ST_ATTACKIDLE = "st106";
Stormtrooper.ST_APPEAR = "st107";
Stormtrooper.ST_STAND_PATROL = "st108";
Stormtrooper.ST_WALKBACK = "st109";
Stormtrooper.ST_JUMP = "st110";
Stormtrooper.ST_APPEAR_SKY = "st111";
Stormtrooper.PLAYER_ON_FIRERANGE = 1;
Stormtrooper.PLAYER_ON_SIGHT = 0;
Stormtrooper.PLAYER_OUT_OF_SIGHT = -1;
Stormtrooper.prototype.onEndAnimation = function(a) {
    this.m_isInvulnerable = !1;
    switch (a) {
        case Stormtrooper.ST_APPEAR:
            a = this.m_clip.finalPos;
            this.m_x += this.m_toLeft ? -a.x : a.x;
            this.gotoState(Stormtrooper.ST_PATROL);
            this.waveDoor && this.waveDoor.startTimer();
            break;
        case Stormtrooper.ST_APPEAR_SKY:
            this.gotoState(Stormtrooper.ST_PATROL);
            break;
        case BaseEnemy.ST_DIE:
            this.wave && (this.wave.notifyKill(), this.wave = null);
            this.makeDrop();
            this.isAwaitingDelete = !0;
            this.m_character.clip.stop();
            break;
        case BaseEnemy.ST_HIT:
            this.gotoState(this.m_oldState);
            break;
        case Stormtrooper.ST_ATTACK:
            this.m_bulletsInARowCount += 1;
            this.m_bulletsInARowCount >= this.config.bulletsInARow && (this.m_bulletsInARowCount = 0, this.isWalkingBack ? this.gotoState(Stormtrooper.ST_WALKBACK) : this.canWalkBehindAfterAttack() ? (this.gotoState(Stormtrooper.ST_WALKBACK), this.isWalkingBack = !0) : Math.random() <= this.config.chanceForCooldown && (this.onAttackCooldown = !0, this.cooldownTimer = 0, this.gotoState(Stormtrooper.ST_ATTACKIDLE)));
            break;
        case Stormtrooper.ST_WARNING:
            this.onWarningCooldown = !0,
                this.m_betweenBulletsTimer = this.config.timeBetweenBullets, this.setState(Stormtrooper.ST_ATTACKIDLE, this.m_x > this.m_world.m_player.m_x)
    }
};
Stormtrooper.prototype.onIdle = function(a) {
    BaseEnemy.prototype.onIdle.call(this, a);
    this.wave && a && this.gotoState(BaseEnemy.ST_DIE)
};
Stormtrooper.prototype.updateStates = function(a) {
    switch (this.m_state) {
        case Stormtrooper.ST_STAND:
        case Stormtrooper.ST_STAND_PATROL:
            this.freezePos || (this.m_timer -= a, 0 >= this.m_timer && (this.currentDetection === Stormtrooper.PLAYER_ON_FIRERANGE ? (this.m_bulletsInARowCount = 0, this.setState(Stormtrooper.ST_WARNING, this.m_x > this.m_world.m_player.m_x)) : this.m_state === Stormtrooper.ST_STAND_PATROL ? this.setState(Stormtrooper.ST_PATROL, !this.m_toLeft) : this.gotoState(Stormtrooper.ST_PATROL)));
            break;
        case Stormtrooper.ST_PATROL:
            if (this.currentDetection ===
                Stormtrooper.PLAYER_ON_FIRERANGE)
                if (this.onWarningCooldown) this.onWarningCooldown = !1, this.m_betweenBulletsTimer = this.config.timeBetweenBullets, this.setState(Stormtrooper.ST_ATTACKIDLE, this.m_x > this.m_world.m_player.m_x);
                else {
                    this.setState(Stormtrooper.ST_WARNING, this.m_x > this.m_world.m_player.m_x);
                    break
                }
            this.regularWalk(a, this.m_toLeft) && (this.m_timer = this.config.timeRest, this.gotoState(Stormtrooper.ST_STAND_PATROL));
            break;
        case Stormtrooper.ST_WALKBACK:
            this.currentDetection !== Stormtrooper.PLAYER_ON_FIRERANGE &&
                (this.gotoState(Stormtrooper.ST_STAND), this.isWalkingBack = !1);
            break;
        case Stormtrooper.ST_ATTACKIDLE:
            if (this.currentDetection !== Stormtrooper.PLAYER_ON_FIRERANGE) {
                this.gotoState(Stormtrooper.ST_STAND);
                this.m_betweenBulletsTimer = 0;
                break
            }
            this.onAttackCooldown ? (this.cooldownTimer += a, this.cooldownTimer >= this.config.attackCooldown && (this.onAttackCooldown = !1)) : (this.m_betweenBulletsTimer += a, this.m_betweenBulletsTimer >= this.config.timeBetweenBullets && (this.setState(Stormtrooper.ST_ATTACK, this.m_x > this.m_world.m_player.m_x),
                this.m_betweenBulletsTimer = 0))
    }
};
Stormtrooper.prototype.update = function(a) {
    (this.freezePos = this.m_world.m_player.disablePlayer) ? this.gotoState(Stormtrooper.ST_STAND_PATROL): this.m_move ? (this.m_move.update(a), this.m_move.m_finish ? this.m_move = null : (this.m_x = this.m_move.getX(), this.m_y = this.m_move.getY())) : (this.isWalkingBack && (this.updateCustomListeners(this.bodyClip), this.m_toLeft && this.m_x < this.walkbackLimitX || !this.m_toLeft && this.m_x > this.walkbackLimitX ? this.m_x += this.m_toLeft ? this.config.speed * a : -this.config.speed * a : (this.gotoState(Stormtrooper.ST_ATTACKIDLE),
        this.m_betweenBulletsTimer = 0, this.isWalkingBack = !1)), this.currentDetection = this.getDetectionType(), this.updateStates(a));
    BaseEnemy.prototype.update.call(this, a)
};
Stormtrooper.prototype.canWalkBehindAfterAttack = function() {
    if (Math.random() <= this.config.chanceToWalkBack) {
        var a = this.m_world.player().getX() - this.m_x;
        if ((0 > a ? -a : a) < this.config.minDistanceToWalkBack && (this.walkbackLimitX = this.m_toLeft ? this.m_limits.right() - 15 : this.m_limits.left() + 15, 20 <= (this.m_x > this.walkbackLimitX ? this.m_x - this.walkbackLimitX : this.walkbackLimitX - this.m_x))) return !0
    }
    return !1
};
Stormtrooper.prototype.regularWalk = function(a, b) {
    if (this.freezePos) return !1;
    if (this.navFloor)
        if (this.navFloor.shouldJump(this.m_x, this.m_y, this.m_toLeft, 200)) this.navFloor.updateCurrentNavKey(this.m_x), this.gotoState(Stormtrooper.ST_JUMP);
        else if (this.navFloor.isDiagonalWalk(this.m_x, this.m_y)) {
        this.navFloor.updateCurrentNavKey(this.m_x);
        var c = this.navFloor.getCurrentNavYPos() - this.m_y,
            d = this.navFloor.currentNavPointKey - this.m_x;
        0 !== d && 0 !== c && (this.m_y += c / ((0 > d ? -d : d) / this.config.speed) * a)
    }
    if (b)
        if (this.m_x -=
            this.config.speed * a, this.navFloor) {
            if (this.m_x - 30 <= this.navFloor.minNavPoint) return this.m_x = this.navFloor.minNavPoint + 30, !0
        } else {
            if (this.m_x - 15 <= this.m_limits.left()) return this.setPosition(this.m_limits.left() + 15, this.m_y), !0
        } else if (this.m_x += this.config.speed * a, this.navFloor) {
        if (this.m_x + 30 >= this.navFloor.maxNavPoint) return this.m_x = this.navFloor.maxNavPoint - 30, !0
    } else if (this.m_x + 15 >= this.m_limits.right()) return this.setPosition(this.m_limits.right() - 15, this.m_y), !0;
    return !1
};
Stormtrooper.prototype.doJump = function() {
    this.m_move || (this.m_move = new ParametricParabolicMovement(this.m_x, this.m_y, this.navFloor.currentNavPointKey, this.navFloor.getCurrentNavYPos()), this.m_move.onComplete(this, this.setPatrol))
};
Stormtrooper.prototype.setPatrol = function() {
    this.gotoState(Stormtrooper.ST_PATROL);
    this.navFloor && (this.navFloor.updateCurrentNavKey(this.m_x), this.m_y = this.navFloor.getCurrentNavYPos());
    this.resetAttack()
};
Stormtrooper.prototype.resetAttack = function() {
    this.onAttackCooldown = !1
};
Stormtrooper.prototype.insideOfLimits = function(a, b) {
    return (new Rectangle(this.m_limits.x, this.m_limits.y, this.m_limits.w, 200)).contains(a, b)
};
Stormtrooper.prototype.updateMark = function() {
    !this.onWarningCooldown && this.m_clip && ((this.questionContainer = this.m_clip.questionContainer) && 0 === this.questionContainer.children.length ? this.currentDetection === Stormtrooper.PLAYER_ON_SIGHT ? this.questionContainer.addChild(this.questionClip) : this.questionContainer.removeChild(this.questionClip) : this.questionContainer = null);
    this.questionClip.scale.x = this.m_clip.scale.x
};
Stormtrooper.prototype.setState = function(a, b) {
    this.setLookAtLeft("undefined" !== typeof b ? b : !1);
    this.gotoState(a)
};
Stormtrooper.prototype.gotoState = function(a) {
    if (this.m_state === BaseEnemy.ST_DIE) this.isWalkingBack = !1;
    else if (!this.m_isInvulnerable) {
        this.bodyContainer && this.bodyContainer.removeChild(this.bodyClip);
        if (this.unitSounds) switch (a) {
            case BaseEnemy.ST_HIT:
            case BaseEnemy.ST_DIE:
                this.unitSounds.playState(a)
        }
        this.m_clip && (this.questionContainer = this.m_clip.questionContainer) && this.questionContainer.removeChild(this.questionClip);
        BaseEnemy.prototype.gotoState.call(this, a);
        a === Stormtrooper.ST_WALKBACK && (this.bodyContainer =
            this.m_clip.bodyContainer, this.bodyContainer.addChild(this.bodyClip), this.bodyClip.gotoAndPlay(1))
    }
};
Stormtrooper.prototype.shootAtPlayer = function() {
    this.m_attackTimer >= this.config.shootFreq && (this.m_attackTimer = 0, this.setState(Stormtrooper.ST_ATTACK, this.m_toLeft))
};
Stormtrooper.prototype.makeDrop = function() {
    var a = [],
        b = "dropChancePhase" + (PlayerSettings.instance.isMultiplayer() ? "MP" : "SP") + this.currentPhase;
    if ("undefined" !== typeof this.config[b]) {
        for (var c = 0; c < this.config[b].length; c++) 0 != this.config[b][c] && Math.random() <= this.config[b][c] * (this.wave ? .25 : 1) && a.push(this.config.drops[c]);
        1 < a.length ? (b = ~~(Math.random() * a.length), b === a.length && --b, this.m_world.m_actorManager.addDrop(this.m_x, this.m_y, a[b])) : 1 === a.length && this.m_world.m_actorManager.addDrop(this.m_x,
            this.m_y, a[0])
    }
};
Stormtrooper.prototype.onHit = function(a) {
    if (this.m_isInvulnerable || this.m_state === BaseEnemy.ST_DIE) return !1;
    this.freezePos = !1;
    if (this.m_state === BaseEnemy.ST_HIT && 0 !== this.m_clip.currentFrame % BaseEnemy.FRAME_CAN_HIT) return !1;
    this.m_state !== BaseEnemy.ST_HIT && (this.m_oldState = this.isWalkingBack ? Stormtrooper.ST_STAND : this.m_state);
    this.isWalkingBack = !1;
    this.m_health -= a;
    0 >= this.m_health ? (PoolClips.instance.releaseClip(this.shadowClip), this.m_health = 0, "EwebRepeaterBlaster" !== this.classname ? this.setState(BaseEnemy.ST_DIE,
        this.m_world.m_player.m_x < this.m_x) : this.gotoState(BaseEnemy.ST_DIE)) : "EwebRepeaterBlaster" !== this.classname ? this.setState(BaseEnemy.ST_HIT, this.m_world.m_player.m_x < this.m_x) : this.gotoState(BaseEnemy.ST_HIT);
    return !0
};
Stormtrooper.prototype.createBullet = function() {
    this.unitSounds && this.unitSounds.playState(Stormtrooper.ST_ATTACK);
    var a = this.m_x + 62 * (this.m_toLeft ? -1 : 1),
        b = this.m_y - 89;
    this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_ENEMY, Bullet.NAME_SKIN_BULLET_ENEMY, a, b, this.config.bulletMaxDistance, this.m_toLeft ? Common.gradToRadian(180) : 0, this.config.bulletSpeed, this.config.bulletDamage);
    this.m_world.createEffect("aniFxShootEnemy", a, b)
};
Stormtrooper.prototype.getDetectionType = function() {
    if (!this.m_world.m_player.isPlaying || this.m_world.m_player.m_state === Player.ST_PLAYER_CELEBRATE || this.m_world.m_player.waitingForCelebrate || this.m_world.m_player.disablePlayer) return Stormtrooper.PLAYER_OUT_OF_SIGHT;
    if (this.isConquerGenerated) return Stormtrooper.PLAYER_ON_FIRERANGE;
    var a = this.m_world.m_player.m_x - this.m_x,
        a = 0 > a ? -a : a,
        b = this.m_world.m_player.m_y - this.m_y,
        b = 0 > b ? -b : b;
    if (50 > b)
        if (this.isPlayerInfront()) {
            if (a <= this.config.fireRange) return Stormtrooper.PLAYER_ON_FIRERANGE
        } else if (a <=
        .3 * this.config.fireRange) return Stormtrooper.PLAYER_ON_FIRERANGE;
    return a <= this.config.fireRange && 200 > b ? Stormtrooper.PLAYER_ON_SIGHT : Stormtrooper.PLAYER_OUT_OF_SIGHT
};
Stormtrooper.prototype.lerp = function(a, b, c, d) {
    return d / 1E3 * c * (b - a)
};
Stormtrooper.prototype.isPlayerInfront = function() {
    return this.m_toLeft ? this.m_x > this.m_world.m_player.m_x : this.m_x < this.m_world.m_player.m_x
};
Stormtrooper.prototype.canFlip = function() {
    return !1
};
Stormtrooper.prototype.flipX = function() {};
Stormtrooper.prototype.free = function() {
    PoolClips.instance.releaseClip(this.questionClip);
    this.questionClip = null;
    BaseEnemy.prototype.free.call(this)
};
Stormtrooper.prototype.getConfig = function(a) {
    for (var b = Application.config.groundEnemies, c = 0; c < b.length; c++)
        if (b[c].type === a) return b[c];
    return b[0]
};
Stormtrooper.prototype.settings = function(a, b, c, d, e, f) {
    BaseEnemy.prototype.settings.call(this, a, b, c, d, e, f);
    this.m_limits = b.getMaxFloorRange(c, d, Math.floor(this.m_npc.limitLeft + this.m_npc.limitRight))
};
Stormtrooper.prototype.init = function() {
    this.m_health = this.config.health;
    this.m_probRespawn = this.config.probRespawn;
    this.m_timeToRespawn = this.config.timeToRespawn;
    this.skin = "Stormtrooper" === this.classname ? "chr_storm" : "chr_shock";
    this.m_character = new SimpleCharacter(this.m_npc.x, this.m_npc.y, this.m_canvas);
    this.m_character.addState(BaseEnemy.ST_HIT, this.skin + "_hit_1");
    this.m_character.addState(BaseEnemy.ST_DIE, this.skin + "_die_floor");
    this.m_character.addState(Stormtrooper.ST_STAND, this.skin + "_stand_1");
    this.m_character.addState(Stormtrooper.ST_STAND_PATROL, this.skin + "_stand_walk");
    this.m_character.addState(Stormtrooper.ST_PATROL, this.skin + "_walk");
    this.m_character.addState(Stormtrooper.ST_WALKBACK, this.skin + "_run");
    this.m_character.addState(Stormtrooper.ST_ATTACK, this.skin + "_attack_1", [{
        caller: this,
        callback: this.createBullet,
        frame: 14
    }]);
    this.m_character.addState(Stormtrooper.ST_WARNING, this.skin + "_warning");
    this.m_character.addState(Stormtrooper.ST_ATTACKIDLE, this.skin + "_attackidle");
    this.m_character.addState(Stormtrooper.ST_APPEAR,
        this.skin + "_appear");
    this.m_character.addState(Stormtrooper.ST_APPEAR_SKY, this.skin + "_genSky");
    this.m_character.addState(Stormtrooper.ST_JUMP, this.skin + "_jump", [{
        caller: this,
        callback: this.doJump,
        frame: 4
    }]);
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.bodyClip = Application.instance.getClip(this.skin + "_shoot");
    this.bodyClip.scale.x /= Application.DPI;
    this.bodyClip.scale.y /= Application.DPI;
    this.addCustomListener(Stormtrooper.ST_WALKBACK, [{
        caller: this,
        callback: this.createBullet,
        frame: 14
    }])
};
Stormtrooper.prototype.addCustomListener = function(a, b) {
    for (var c = 0; c < b.length; c++) this.functions[a + "_" + b[c].frame] = b[c]
};
Stormtrooper.prototype.onExpel = function() {
    this.isAwaitingDelete || (this.makeDrop(), this.wave && (this.wave.notifyKill(), this.wave = null), BaseEnemy.prototype.onExpel.call(this))
};
Stormtrooper.prototype.updateCustomListeners = function(a) {
    this.lastFrame !== a.currentFrame && (this.lastFrame = a.currentFrame, this.functions[this.m_state + "_" + a.currentFrame] && (a = this.functions[this.m_state + "_" + a.currentFrame], a.callback.call(a.caller)))
};

function Atdp(a, b, c) {
    SimpleWorldActor.call(this, a, b, c.x, c.y);
    Atdp.instance = this;
    this.isEnemy = !0;
    this.completeHit = !1;
    this.skin = "mcBoss1";
    this.isBoss = !0;
    this.m_initialHealth = 100;
    switch (MissionManager.instance.getGameMode()) {
        case MissionManager.GAME_SINGLEPLAYER:
            this.m_initialHealth = Application.config.atdp.initHealth;
            break;
        case MissionManager.GAME_COOPERATIVE:
            this.m_initialHealth = Application.config.atdp.initHealthCoop;
            break;
        case MissionManager.GAME_VERSUS:
            this.m_initialHealth = Application.config.atdp.initHealthVS
    }
    this.health =
        this.m_initialHealth;
    this.m_behavior = Atdp.BEHAVIOR_WITH_CANNON;
    this.m_bossState = Atdp.STATE_IDLE;
    this.m_timerToNextState = Application.config.atdp.timeStateStand;
    this.m_timerBurst = 0;
    this.scale = 1.2;
    this.m_clipWeaponDestroyed = this.m_clipWeapon = null;
    this.m_angleWeapon = 0;
    this.m_speedWeaponAngle = .001 * Math.PI;
    this.m_speedMovement = -Application.config.atdp.speedWalk;
    this.m_damage = 0;
    this.m_initX = this.m_x;
    this.m_canAppear = this.isRangeControlled = !1;
    this.m_playerRef = this.m_world.player();
    this.m_timerToHit = 0;
    this.m_effectChargeHoming =
        this.m_world.createEffect("aniFxBossCharge", this.m_x, this.m_y);
    this.m_effectChargeHoming.setPause(!0);
    this.m_effectSmoke = this.m_world.createEffect("aniFxcooldownatdp", this.m_x - 96, this.m_y - 300);
    this.m_effectSmoke.setPause(!0);
    this.unitSounds = new UnitSounds("ATDP");
    this.m_timerTotalExplosion = this.m_timerPerExplosion = 0;
    this.m_door = new DoorAtdp(this.m_world.objectCanvas(), this.m_world, 2392, 1514);
    this.m_world.actorManager().add(this.m_door);
    this.effectTimer = this.m_tint = this.m_countTint = this.m_timerTint =
        0;
    this.m_scaleWeapon = new Vector2D;
    this.init()
}
Application.subclass(Atdp, SimpleWorldActor);
Atdp.instance = null;
Atdp.TIME_PER_TINT = 80;
Atdp.COUNT_TINTS = 4;
Atdp.TIME_PER_EXPLOSION = 200;
Atdp.TIME_TOTAL_EXPLOSION = 5E3;
Atdp.TIME_FOR_NEXT_HIT = 400;
Atdp.NO_BEHAVIOR = 0;
Atdp.BEHAVIOR_WITH_CANNON = 1;
Atdp.BEHAVIOR_NO_CANNON = 2;
Atdp.STATE_IDLE = 0;
Atdp.STATE_STAND = 100;
Atdp.STATE_HOMING = 101;
Atdp.STATE_BULLET_BURST = 102;
Atdp.STATE_DASH = 103;
Atdp.STATE_JUMP_ATTACK = 104;
Atdp.STATE_GRENADE = 105;
Atdp.STATE_VULNERABLE = 106;
Atdp.VULNERABLE_EFFECT_DELAY = 1E3;
Atdp.ST_STAND = "st1";
Atdp.ST_WALK = "st20";
Atdp.ST_WALK_FRONT = "st2";
Atdp.ST_WALK_BACK = "st3";
Atdp.ST_ATTACK_HOMING = "st4";
Atdp.ST_ATTACK_BURST_PRE = "st5";
Atdp.ST_ATTACK_BURST = "st6";
Atdp.ST_ATTACK_BURST_END = "st7";
Atdp.ST_HIT = "st8";
Atdp.ST_DIE = "st9";
Atdp.ST_WARNING = "st10";
Atdp.ST_APPEAR = "st11";
Atdp.ST_VULNERABLE = "st12";
Atdp.ST_ATTACK_JUMP = "st13";
Atdp.ST_ATTACK_GRENADE = "st14";
Atdp.ST_VULNERABLE_JUMP = "st15";
Atdp.ST_VULNERABLE_JUMP_END = "st16";
Atdp.DISTANCE_TO_APPEAR = 450;
Atdp.prototype.free = function() {
    this.m_door = Atdp.instance = null;
    this.m_effectChargeHoming && (this.m_effectChargeHoming.isAwaitingDelete = !0, this.m_effectChargeHoming = null);
    this.m_effectSmoke && (this.m_effectSmoke.isAwaitingDelete = !0, this.m_effectSmoke = null);
    SimpleWorldActor.prototype.free.call(this)
};
Atdp.prototype.init = function() {
    this.m_character = new SimpleCharacter(0, 0, this.m_canvas);
    this.m_character.addState(Atdp.ST_STAND, this.skin + "_stand");
    this.m_character.addState(Atdp.ST_HIT, this.skin + "_hit");
    var a = [{
        caller: this,
        callback: this.doStepSound,
        frame: 15
    }, {
        caller: this,
        callback: this.doStepSound,
        frame: 44
    }];
    this.m_character.addState(Atdp.ST_WALK_FRONT, this.skin + "_walkFront", a);
    a = [{
        caller: this,
        callback: this.doStepSound,
        frame: 23
    }, {
        caller: this,
        callback: this.doStepSound,
        frame: 52
    }];
    this.m_character.addState(Atdp.ST_WALK_BACK,
        this.skin + "_walkBack", a);
    a = [{
        caller: this,
        callback: this.doStepSound,
        frame: 11
    }, {
        caller: this,
        callback: this.doStepSound,
        frame: 36
    }, {
        caller: this,
        callback: this.doStepSound,
        frame: 57
    }, {
        caller: this,
        callback: this.doStepSound,
        frame: 100
    }, {
        caller: this,
        callback: this.doStepSound,
        frame: 132
    }, {
        caller: this,
        callback: this.doStepSound,
        frame: 157
    }];
    this.m_character.addState(Atdp.ST_WALK, this.skin + "_walk", a);
    a = [{
        caller: this,
        callback: this.doDieSound,
        frame: 60
    }, {
        caller: this,
        callback: this.doBigExplosion,
        frame: 164
    }];
    this.m_character.addState(Atdp.ST_DIE,
        this.skin + "_defeat", a);
    this.m_character.addState(Atdp.ST_VULNERABLE, this.skin + "_vulnerable");
    this.m_character.addState(Atdp.ST_ATTACK_BURST_PRE, this.skin + "_attack1_start");
    this.m_character.addState(Atdp.ST_ATTACK_BURST, this.skin + "_attack1_stand");
    this.m_character.addState(Atdp.ST_ATTACK_BURST_END, this.skin + "_attack1_end");
    a = [{
        caller: this,
        callback: this.createHoming,
        frame: 59
    }];
    this.m_character.addState(Atdp.ST_ATTACK_HOMING, this.skin + "_attack2", a);
    a = [{
        caller: this,
        callback: this.doShake,
        frame: 46
    }, {
        caller: this,
        callback: this.doJumpSound,
        frame: 45
    }];
    this.m_character.addState(Atdp.ST_ATTACK_JUMP, this.skin + "_jump", a);
    a = [{
        caller: this,
        callback: this.createGrenades,
        frame: 53
    }];
    this.m_character.addState(Atdp.ST_ATTACK_GRENADE, this.skin + "_attack3", a);
    this.m_character.addState(Atdp.ST_WARNING, this.skin + "_alert");
    a = [{
        caller: this,
        callback: this.doShake,
        frame: 71
    }, {
        caller: this,
        callback: this.doBreakObstacleSound,
        frame: 72
    }];
    this.m_character.addState(Atdp.ST_APPEAR, this.skin + "_appear", a);
    this.m_character.onEndAnimation(this,
        this.onEndAnimation);
    this.m_character.addState(Atdp.ST_VULNERABLE_JUMP, this.skin + "_vulnerable2_stand");
    this.m_character.addState(Atdp.ST_VULNERABLE_JUMP_END, this.skin + "_vulnerable2_end");
    HudPlatform.instance.setEnergyBoss(1E3)
};
Atdp.prototype.doBreakObstacleSound = function() {
    Application.instance.playSound("SND_BOSS_OBSTACLE_DESTROY")
};
Atdp.prototype.doShake = function() {
    this.m_state !== Atdp.ST_APPEAR && this.unitSounds.playState(this.m_state);
    Global.game.onShake(10, 15, 300);
    this.m_state === Atdp.ST_ATTACK_JUMP && this.m_world.createEffect("aniFxatdpstomp", this.m_x, this.m_y)
};
Atdp.prototype.doBigExplosion = function() {
    this.m_world.createContainerEffect("aniFxEnemyExplote", this.m_x, this.m_y, 3.5);
    Application.instance.playSound("SND_BOSS_OBSTACLE_DESTROY")
};
Atdp.prototype.updatePlayerCoop = function() {
    this.m_playerRef = this.m_world.player();
    HudPlatform.instance.stopTimingOut()
};
Atdp.prototype.createBullet = function() {
    this.unitSounds.playState(Atdp.ST_ATTACK_BURST);
    var a = this.m_angleWeapon - Math.PI,
        b = this.m_clip.mcWeapon ? this.m_clip.mcWeapon.position.x * this.scale : 0,
        c = this.m_clip.mcWeapon ? this.m_clip.mcWeapon.position.y * this.scale : 0,
        b = b + 88 * Math.cos(a),
        c = c + 88 * Math.sin(a);
    this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_ENEMY, "aniFxBoss01Bullet01", this.m_x + b, this.m_y + c, 1200, a, Application.config.atdp.speedBurstBullet, Application.config.atdp.damageBurstBullet, Bullet.FX_IMPACT_BOSS);
    this.m_world.createEffect("aniFxBoss01Shoot", this.m_x + b, this.m_y + c)
};
Atdp.prototype.createHoming = function() {
    this.unitSounds.playState(Atdp.ST_ATTACK_HOMING);
    var a = this.m_clip.mcWeapon ? this.m_clip.mcWeapon.rotation - Math.PI : 0,
        b = this.m_clip.mcWeapon ? this.m_clip.mcWeapon.position.x * this.scale : 0,
        c = this.m_clip.mcWeapon ? this.m_clip.mcWeapon.position.y * this.scale : 0,
        b = b + 88 * Math.cos(a),
        c = c + 88 * Math.sin(a);
    this.m_world.m_actorManager.bulletManager.createAtdpMissile(this.m_x + b, this.m_y + c, Application.config.atdp.damageHoming, Bullet.NAME_SKIN_BULLET_ENEMY, Application.config.atdp.speedHoming, -135, !1, Bullet.FX_IMPACT_GRENADE);
    this.m_world.createEffect("aniFxBoss01Shoot", this.m_x + b, this.m_y + c);
    this.m_effectChargeHoming.setPause(!0)
};
Atdp.prototype.createGrenades = function() {
    this.unitSounds.playState(Atdp.ST_ATTACK_GRENADE);
    Application.info("throw grenades");
    for (var a = -90 + Common.randomInt(-65, 30), b = this.m_x + 10, c = this.m_y - 350 * this.scale, d = 0, d = 0; d < Application.config.atdp.maxGrenades; d++) a = -90 + Common.randomInt(-65, 0), this.m_world.m_actorManager.bulletManager.createAtdpMissile(b, c, Application.config.atdp.damageGrenades, "aniFxThermalGranade", Application.config.atdp.speedGrenades, a, !0, Bullet.FX_IMPACT_GRENADE)
};
Atdp.prototype.onEndAppear = function() {
    this.m_world.m_camera.m_lockState = Camera.LOCK_ON
};
Atdp.prototype.onEndAnimation = function(a) {
    switch (a) {
        case Atdp.ST_APPEAR:
            this.setStateBoss(Atdp.STATE_STAND);
            this.m_world.m_camera.doBlendWithPos(1675, 1250, this.m_world.m_camera.fixOffsetX, 0, 5, !0, this, this.onEndAppear, null);
            break;
        case Atdp.ST_WARNING:
            switch (this.m_bossState) {
                case Atdp.STATE_HOMING:
                    this.gotoState(Atdp.ST_ATTACK_HOMING);
                    this.m_effectChargeHoming.setPause(!1);
                    break;
                case Atdp.STATE_BULLET_BURST:
                    this.gotoState(Atdp.ST_ATTACK_BURST_PRE);
                    break;
                case Atdp.STATE_DASH:
                    this.gotoState(Atdp.ST_WALK);
                    this.m_speedMovement = -Application.config.atdp.speedWalk;
                    break;
                case Atdp.STATE_JUMP_ATTACK:
                    this.gotoState(Atdp.ST_ATTACK_JUMP)
            }
            break;
        case Atdp.ST_ATTACK_BURST_PRE:
            this.gotoState(Atdp.ST_ATTACK_BURST);
            this.m_timerBurst = Application.config.atdp.timePerBurst;
            break;
        case Atdp.ST_ATTACK_BURST_END:
            this.setStateBoss(Atdp.STATE_VULNERABLE);
            break;
        case Atdp.ST_ATTACK_HOMING:
            this.gotoState(Atdp.ST_STAND);
            break;
        case Atdp.ST_WALK:
            this.setStateBoss(Atdp.STATE_JUMP_ATTACK);
            break;
        case Atdp.ST_ATTACK_JUMP:
            this.setStateBoss(Atdp.STATE_VULNERABLE);
            break;
        case Atdp.ST_VULNERABLE_JUMP_END:
            this.setStateBoss(Atdp.STATE_STAND);
            break;
        case Atdp.ST_HIT:
            this.m_bossState === Atdp.STATE_VULNERABLE ? this.m_behavior === Atdp.BEHAVIOR_WITH_CANNON ? this.gotoState(Atdp.ST_VULNERABLE) : this.gotoState(Atdp.ST_VULNERABLE_JUMP) : this.gotoState(Atdp.ST_STAND);
            break;
        case Atdp.ST_DIE:
            this.m_world.m_camera.doBlendWithTarget(this.m_world.m_player, 60, -150, 5, !0, null, null, null), this.m_playerRef.onWin(!1)
    }
};
Atdp.prototype.onHit = function(a) {
    if (this.m_state === Atdp.ST_DIE || this.m_state === Atdp.ST_HIT) return !1;
    this.completeHit = !0;
    this.m_timerToHit = Atdp.TIME_FOR_NEXT_HIT;
    a = a > this.health ? this.health : a;
    this.health -= a;
    PlayerSettings.instance.updatePlayerBossDamage(a, this.m_initialHealth);
    Application.info("boss health: " + this.health);
    if (100 * this.health / this.m_initialHealth <= Application.config.atdp.healthThreshold && this.m_behavior === Atdp.BEHAVIOR_WITH_CANNON) return this.m_behavior = Atdp.BEHAVIOR_NO_CANNON, this.setStateBoss(Atdp.STATE_STAND),
        this.m_effectChargeHoming.setPause(!0), Application.instance.playSound("SND_TURRET_DIE"), this.m_world.createEffect("aniFxBulletExplotion", this.m_x + (this.m_clip.mcWeapon ? this.m_clip.mcWeapon.position.x * this.scale : 0), this.m_y + (this.m_clip.mcWeapon ? this.m_clip.mcWeapon.position.y * this.scale : 0)), !0;
    0 >= this.health ? (this.health = 0, this.gotoState(Atdp.ST_DIE), this.m_timerPerExplosion = 10, this.m_timerTotalExplosion = Atdp.TIME_TOTAL_EXPLOSION, HudPlatform.instance.setEnergyBoss(1)) : (a = Math.ceil(this.health / this.m_initialHealth *
        999) + 1, HudPlatform.instance.setEnergyBoss(a), this.unitSounds.playState(Atdp.ST_HIT), this.m_bossState === HeadAtat.STATE_STAND && this.gotoState(HeadAtat.ST_HIT), this.onTint(16728642), this.m_timerTint = Atdp.TIME_PER_TINT, this.m_countTint = Atdp.COUNT_TINTS);
    return !0
};
Atdp.prototype.onTint = function(a) {
    this.m_clip.setTint(a);
    this.m_tint = a;
    this.m_clipWeapon && this.m_clipWeapon.setTint(a)
};
Atdp.prototype.gotoStand = function() {
    this.gotoState(Atdp.ST_STAND)
};
Atdp.prototype.defeat = function() {
    this.health = 0;
    this.gotoState(Atdp.ST_DIE);
    HudPlatform.instance.setEnergyBoss(1);
    this.m_timerPerExplosion = 10;
    this.m_timerTotalExplosion = Atdp.TIME_TOTAL_EXPLOSION
};
Atdp.prototype.gotoState = function(a) {
    SimpleWorldActor.prototype.gotoState.call(this, a);
    a !== Atdp.ST_ATTACK_BURST && a !== Atdp.ST_ATTACK_HOMING && a !== Atdp.ST_ATTACK_GRENADE && a !== Atdp.ST_ATTACK_JUMP && a !== Atdp.ST_WALK_BACK && a !== Atdp.ST_WALK_FRONT && a !== Atdp.ST_DIE && this.unitSounds.playState(a);
    a === Atdp.ST_DIE && (this.m_clip.loop = !1);
    PoolClips.instance.releaseClip(this.m_clipWeapon);
    this.m_clipWeapon = null;
    if (this.m_clip && this.m_clip.mcWeapon) {
        this.m_clipWeapon = PoolClips.instance.getClip(this.skin + (this.m_behavior ===
            Atdp.BEHAVIOR_NO_CANNON ? "_weapon2" : "_weapon"));
        this.m_clip.mcWeapon.addChild(this.m_clipWeapon);
        if (0 === this.m_scaleWeapon.x || 0 === this.m_scaleWeapon.y) this.m_scaleWeapon.x = this.m_clipWeapon.scale.x, this.m_scaleWeapon.y = this.m_clipWeapon.scale.y;
        this.m_clipWeapon.scale.x = this.m_scaleWeapon.x / Application.DPI;
        this.m_clipWeapon.scale.y = this.m_scaleWeapon.y / Application.DPI;
        this.m_angleWeapon = 0;
        this.m_clipWeapon.rotation = this.m_angleWeapon
    }
    this.m_state === Atdp.ST_VULNERABLE ? this.m_effectSmoke.setPause(!1) :
        this.m_effectSmoke.setPause(!0)
};
Atdp.prototype.onEndLock = function() {
    this.m_canAppear = !0;
    this.gotoState(Atdp.ST_APPEAR);
    this.m_door.doBreak()
};
Atdp.prototype.update = function(a) {
    if (this.m_canAppear) {
        if (0 < this.m_timerTint && (this.m_timerTint -= a, 0 >= this.m_timerTint))
            if (--this.m_countTint, 0 < this.m_countTint) {
                var b = this.m_tint === (this.completeHit ? 16728642 : 16711937) ? 16777215 : this.completeHit ? 16728642 : 16711937;
                this.m_clip.alpha = this.completeHit ? 1 : .7;
                this.onTint(b);
                this.m_timerTint = Atdp.TIME_PER_TINT
            } else this.m_clip.alpha = 1, this.onTint(16777215), this.m_timerTint = 0;
        SimpleWorldActor.prototype.update.call(this, a);
        0 < this.m_timerToHit && (this.m_timerToHit -=
            a, this.m_timerToHit = 0 > this.m_timerToHit ? 0 : this.m_timerToHit);
        if (0 >= this.m_timerToHit)
            if (this.m_world.m_player.clipSpecialAttack) {
                if (SDisplayObjectContainer.hitTestByBounds(this.m_clip, this.m_clip.getCollision(SimpleWorldActor.COLLISION), this.m_world.m_player.clipSpecialAttack, this.m_world.m_player.clipSpecialAttack.getCollision(SimpleWorldActor.COLLISION_SPECIAL))) this.onHit(this.m_playerRef.data.specialDamagetoBoss)
            } else this.hitCollisions(SimpleWorldActor.COLLISION, this.m_world.m_player, SimpleWorldActor.COLLISION_ATTACK) &&
                this.onHit(this.m_playerRef.data.regularDamageToBoss) && (this.m_clip.mcHead ? (b = this.m_clip.mcHead.position.x * this.scale, this.m_world.createEffect("aniFxPlayerHit", this.m_x + b, this.m_playerRef.m_y - 80)) : this.m_world.createEffect("aniFxPlayerHit", this.m_x, this.m_playerRef.m_y - 80), Global.game.onShake(4, 10, 200));
        if (this.m_effectChargeHoming && this.m_state === Atdp.ST_ATTACK_HOMING) {
            var c = this.m_clip.mcWeapon ? this.m_clip.mcWeapon.rotation - Math.PI : 0,
                b = this.m_clip.mcWeapon ? this.m_clip.mcWeapon.position.x * this.scale :
                0,
                d = this.m_clip.mcWeapon ? this.m_clip.mcWeapon.position.y * this.scale : 0,
                b = b + 88 * Math.cos(c),
                d = d + 88 * Math.sin(c);
            this.m_effectChargeHoming.fix(this.m_x + b, this.m_y + d)
        }
        this.updateStates(a);
        this.checkPlayerNearby()
    } else 1400 <= this.m_world.m_player.m_x && this.m_world.m_camera.m_lockState === Camera.LOCK_OFF && this.m_world.m_camera.doBlendWithPos(1940, 1250, this.m_world.m_camera.fixOffsetX, 0, 5, !0, this, this.onEndLock, null)
};
Atdp.prototype.updateStates = function(a) {
    if (this.m_state === Atdp.ST_DIE) {
        if (0 < this.m_timerTotalExplosion) {
            if (0 < this.m_timerPerExplosion && (this.m_timerPerExplosion -= a, 0 >= this.m_timerPerExplosion)) {
                this.m_timerPerExplosion = Atdp.TIME_PER_EXPLOSION;
                var b = 0,
                    c = 0;
                this.m_clip.mcHead && (b = this.m_clip.mcHead.position.x * this.scale, c = this.m_clip.mcHead.position.y * this.scale);
                var b = Common.randomInt(this.m_x + b - 80, this.m_x + b + 80),
                    c = Common.randomInt(this.m_y + c - 80, this.m_y + c + 80),
                    d = Common.randomInt(50, 100);
                this.m_world.createContainerEffect("aniFxEnemyExplote",
                    b, c, d / 100);
                Application.instance.playSound("SND_BOSS_DEFEAT_EXPLOSION");
                Global.game.createExplotionShader(b - this.m_world.m_camera.m_x, c - this.m_world.m_camera.m_y - 60, 8)
            }
            this.m_timerTotalExplosion -= a;
            0 >= this.m_timerTotalExplosion && (this.m_timerTotalExplosion = this.m_timerPerExplosion = 0)
        }
    } else switch (this.m_behavior) {
        case Atdp.BEHAVIOR_WITH_CANNON:
            switch (this.m_bossState) {
                case Atdp.STATE_STAND:
                    0 < this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(Atdp.STATE_HOMING));
                    break;
                case Atdp.STATE_HOMING:
                    0 < this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(Atdp.STATE_BULLET_BURST));
                    break;
                case Atdp.STATE_BULLET_BURST:
                    if (this.m_state === Atdp.ST_ATTACK_BURST) {
                        if (this.m_clipWeapon) {
                            this.m_angleWeapon += this.m_speedWeaponAngle * a;
                            if (0 < this.m_speedWeaponAngle && this.m_angleWeapon > Math.PI / 3 || 0 > this.m_speedWeaponAngle && this.m_angleWeapon < .7 * -Math.PI) this.m_speedWeaponAngle *= -1;
                            this.m_clipWeapon.rotation = this.m_angleWeapon;
                            0 < this.m_timerBurst &&
                                (this.m_timerBurst -= a, 0 >= this.m_timerBurst && (this.createBullet(), this.m_timerBurst = Application.config.atdp.timePerBurst))
                        }
                        0 < this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.gotoState(Atdp.ST_ATTACK_BURST_END))
                    }
                    break;
                case Atdp.STATE_VULNERABLE:
                    0 < this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(Atdp.STATE_STAND)), this.doVulnerableEffect(a)
            }
            break;
        case Atdp.BEHAVIOR_NO_CANNON:
            switch (this.m_bossState) {
                case Atdp.STATE_STAND:
                    0 <
                        this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(Atdp.STATE_DASH));
                    break;
                case Atdp.STATE_DASH:
                    if (this.hitCollisions(SimpleWorldActor.COLLISION_ATTACK, this.m_playerRef, SimpleWorldActor.COLLISION)) this.m_playerRef.onEnemyCollision(this, this.m_damage);
                    break;
                case Atdp.STATE_JUMP_ATTACK:
                    if (this.hitCollisions(SimpleWorldActor.COLLISION_ATTACK, this.m_playerRef, SimpleWorldActor.COLLISION)) this.m_playerRef.onEnemyCollision(this, this.m_damage);
                    break;
                case Atdp.STATE_GRENADE:
                    0 <
                        this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.gotoState(Atdp.ST_VULNERABLE_JUMP_END));
                    break;
                case Atdp.STATE_VULNERABLE:
                    0 < this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(Atdp.STATE_GRENADE)), this.doVulnerableEffect(a)
            }
    }
};
Atdp.prototype.doVulnerableEffect = function(a) {
    this.effectTimer += a;
    this.effectTimer > Atdp.VULNERABLE_EFFECT_DELAY && (this.effectTimer = 0, a = this.m_clip.getCollision("mcCollision"), this.m_world.createEffect("aniFxBoss01Damage", this.m_x + a.x + .5 * a.w, this.m_y + a.y + .5 * a.w))
};
Atdp.prototype.checkPlayerNearby = function() {
    var a = this.m_x - this.m_playerRef.m_x;
    200 > (0 > a ? -a : a) && (PlatformGame.playerNearEnemy = !0, this.m_world.m_player.m_clip.hitTest(this.m_clip) && (this.m_world.m_player.m_x += -5))
};
Atdp.prototype.setStateBoss = function(a) {
    this.m_bossState = a;
    switch (a) {
        case Atdp.STATE_STAND:
            this.m_timerToNextState = Application.config.atdp.timeStateStand;
            this.gotoState(Atdp.ST_STAND);
            break;
        case Atdp.STATE_HOMING:
            this.gotoState(Atdp.ST_WARNING);
            this.m_timerToNextState = Application.config.atdp.timeHoming;
            break;
        case Atdp.STATE_BULLET_BURST:
            this.gotoState(Atdp.ST_WARNING);
            this.m_timerToNextState = Application.config.atdp.timeBurst;
            break;
        case Atdp.STATE_VULNERABLE:
            this.m_behavior === Atdp.BEHAVIOR_WITH_CANNON ?
                this.gotoState(Atdp.ST_VULNERABLE) : this.gotoState(Atdp.ST_VULNERABLE_JUMP);
            this.m_timerToNextState = Application.config.atdp.timeVulnerable;
            break;
        case Atdp.STATE_DASH:
            this.gotoState(Atdp.ST_WARNING);
            this.m_speedMovement = -Application.config.atdp.speedWalk;
            this.m_damage = Application.config.atdp.damageDash;
            break;
        case Atdp.STATE_JUMP_ATTACK:
            this.gotoState(Atdp.ST_WARNING);
            this.m_damage = Application.config.atdp.damageJump;
            break;
        case Atdp.STATE_GRENADE:
            this.gotoState(Atdp.ST_ATTACK_GRENADE), this.m_timerToNextState =
                Application.config.atdp.timeGrenade
    }
};
Atdp.prototype.doJumpSound = function() {
    this.unitSounds.playState(Atdp.ST_ATTACK_JUMP)
};
Atdp.prototype.doStepSound = function() {
    this.unitSounds.playState(Atdp.ST_WALK_FRONT)
};
Atdp.prototype.doDieSound = function() {
    this.unitSounds.playState(Atdp.ST_DIE)
};

function DoorAtdp(a, b, c, d) {
    SimpleWorldActor.call(this, a, b, c, d);
    DoorAtdp.instance = this;
    this.skin = "mcBoss1_door";
    this.init()
}
Application.subclass(DoorAtdp, SimpleWorldActor);
DoorAtdp.ST_STAND = "st1";
DoorAtdp.ST_BREAK = "st2";
DoorAtdp.prototype.free = function() {
    DoorAtdp.instance = null;
    SimpleWorldActor.prototype.free.call(this)
};
DoorAtdp.prototype.init = function() {
    this.m_character = new SimpleCharacter(0, 0, this.m_canvas);
    this.m_character.addState(DoorAtdp.ST_STAND, this.skin + "_stand");
    this.m_character.addState(DoorAtdp.ST_BREAK, this.skin + "_break", [{
        caller: this,
        callback: this.doShake,
        frame: 3
    }, {
        caller: this,
        callback: this.doShake,
        frame: 39
    }, {
        caller: this,
        callback: this.doShake,
        frame: 56
    }]);
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.gotoState(DoorAtdp.ST_STAND)
};
DoorAtdp.prototype.doShake = function() {
    Global.game.onShake(6, 9, 150)
};
DoorAtdp.prototype.onEndAnimation = function(a) {
    switch (a) {
        case DoorAtdp.ST_BREAK:
            this.isAwaitingDelete = !0
    }
};
DoorAtdp.prototype.doBreak = function() {
    this.gotoState(DoorAtdp.ST_BREAK)
};
DoorAtdp.prototype.gotoState = function(a) {
    SimpleWorldActor.prototype.gotoState.call(this, a)
};
DoorAtdp.prototype.update = function(a) {
    SimpleWorldActor.prototype.update.call(this, a)
};

function AtdpMissile(a) {
    this.m_world = a;
    this.m_clip = this.m_playerRef = null;
    this.m_damage = 0;
    this.m_impactFx = this.m_skin = "";
    this.m_absoluteSpeed = 0;
    this.m_speed = new Vector2D;
    this.isAlive = !1;
    this.m_timerToExplode = this.m_angle = 0;
    this.m_isFreeFall = !1;
    this.m_timerFreeMovement = 0;
    this.fx = null
}
AtdpMissile.TIME_FREE_MOVEMENT = 500;
AtdpMissile.GRAVITY = 6E-4;
AtdpMissile.prototype.setParams = function(a, b, c, d, e, f, g, h) {
    this.m_isFreeFall = g;
    this.m_playerRef = this.m_world.player();
    this.isAlive = !0;
    this.m_angle = SMath.toRadians(f);
    this.m_damage = c;
    this.m_absoluteSpeed = e;
    this.m_speed.x = Math.cos(this.m_angle) * e;
    this.m_speed.y = Math.sin(this.m_angle) * e;
    this.m_timerToExplode = Application.config.atdp.timeForHomingToExplode;
    this.m_x = a;
    this.m_y = b;
    this.m_skin = d;
    this.m_impactFx = h;
    this.m_clip = PoolClips.instance.getClip(d);
    this.m_world.objectCanvas().addChild(this.m_clip);
    this.m_isFreeFall ||
        (this.m_clip.visible = !1, this.fx = this.m_world.createEffect("aniFxBoss01Bullet02", this.m_x, this.m_y), this.m_timerFreeMovement = AtdpMissile.TIME_FREE_MOVEMENT)
};
AtdpMissile.prototype.explode = function() {
    this.m_world.createEffect(this.m_impactFx, this.m_x, this.m_y);
    Global.game.onShake(3, 10, 300);
    this.deactivate();
    this.fx && (this.fx.isAwaitingDelete = !0, this.fx = null);
    this.m_isFreeFall && Application.instance.playSound("SND_BOSS_ATDP_GRENADE_EXPLOSION")
};
AtdpMissile.prototype.doMovement = function(a) {
    if (this.m_isFreeFall) this.m_speed.y += AtdpMissile.GRAVITY * a;
    else if (0 >= this.m_timerFreeMovement) {
        var b = this.m_playerRef.m_x - this.m_x,
            c = this.m_playerRef.m_y - 60 - this.m_y,
            d = Math.sqrt(b * b + c * c);
        this.m_angle = Math.acos(b / d);
        this.m_speed.x = Math.cos(this.m_angle) * this.m_absoluteSpeed;
        this.m_speed.y = Math.sin(0 > c ? -this.m_angle : this.m_angle) * this.m_absoluteSpeed
    } else this.m_timerFreeMovement -= a, 0 >= this.m_timerFreeMovement && (this.m_timerFreeMovement = 0);
    this.m_x += this.m_speed.x *
        a;
    this.m_y += this.m_speed.y * a;
    this.fx && (this.fx.x = this.m_x, this.fx.y = this.m_y)
};
AtdpMissile.prototype.updateClip = function(a) {
    this.m_clip.position.x = this.m_x - this.m_world.m_camera.m_x;
    this.m_clip.position.y = this.m_y - this.m_world.m_camera.m_y;
    var b = Math.sqrt(this.m_speed.x * this.m_speed.x + this.m_speed.y * this.m_speed.y),
        b = Math.acos(this.m_speed.x / b),
        b = 0 > this.m_speed.y ? -b : b;
    this.m_clip.rotation = b;
    this.m_clip.update(a)
};
AtdpMissile.prototype.checkPlayerCollision = function() {
    this.m_world.m_player.clipSpecialAttack ? SDisplayObjectContainer.hitTestByBounds(this.m_clip, this.m_clip.getCollision(SimpleWorldActor.COLLISION), this.m_world.m_player.clipSpecialAttack, this.m_world.m_player.clipSpecialAttack.getCollision(SimpleWorldActor.COLLISION_SPECIAL)) && this.explode() : this.m_clip.hitTest(this.m_world.m_player.m_clip) && (this.m_world.m_player.onBulletCollision(this, this.m_damage), this.explode())
};
AtdpMissile.prototype.checkWorldCollision = function() {
    0 != this.m_world.getCellInPosition(this.m_x, this.m_y) && this.explode()
};
AtdpMissile.prototype.update = function(a) {
    if (this.isAlive) {
        if (0 < this.m_timerToExplode && (this.m_timerToExplode -= a, 0 >= this.m_timerToExplode)) {
            this.m_timerToExplode = 0;
            this.explode();
            return
        }
        this.doMovement(a);
        this.updateClip(a);
        this.checkPlayerCollision();
        this.m_isFreeFall && this.checkWorldCollision()
    }
};
AtdpMissile.prototype.deactivate = function() {
    PoolClips.instance.releaseClip(this.m_clip);
    this.isAlive = !1;
    this.m_clip.visible = !1
};
AtdpMissile.prototype.free = function() {
    this.m_clip && PoolClips.instance.releaseClip(this.m_clip);
    this.fx && (this.fx.isAwaitingDelete = !0, this.fx = null);
    this.speed = this.goalPos = this.iniPos = this.m_world = null
};

function HeadAtat(a, b, c) {
    SimpleWorldActor.call(this, a, b, c.x, c.y);
    HeadAtat.instance = this;
    this.isEnemy = !0;
    this.isAwaitingLose = this.completeHit = !1;
    this.skin = "mcBoss3";
    this.isBoss = !0;
    this.m_initialHealth = 100;
    this.unitSounds = new UnitSounds("ATAT");
    switch (MissionManager.instance.getGameMode()) {
        case MissionManager.GAME_SINGLEPLAYER:
            this.m_initialHealth = Application.config.atat.initHealth;
            break;
        case MissionManager.GAME_COOPERATIVE:
            this.m_initialHealth = Application.config.atat.initHealthCoop;
            break;
        case MissionManager.GAME_VERSUS:
            this.m_initialHealth =
                Application.config.atat.initHealthVS
    }
    this.health = this.m_initialHealth;
    this.m_behavior = HeadAtat.BEHAVIOR_WITH_CANNON;
    this.m_bossState = HeadAtat.STATE_IDLE;
    this.m_timerToNextState = Application.config.atat.timeStateStand;
    this.fallSpeed = this.m_timerStandAfterDash = this.m_timerBurst = 0;
    this.scale = 1;
    this.m_clipRightCannon = this.m_clipLeftCannon = this.m_clipRightWeapon = this.m_clipLeftWeapon = null;
    this.m_angleWeaponRight = this.m_angleWeaponLeft = this.m_initAngleWeaponRight = this.m_initAngleWeaponLeft = 0;
    this.m_speedWeaponAngleLeft =
        2E-4 * Math.PI;
    this.m_speedWeaponAngleRight = 2E-4 * Math.PI;
    a = new Vector2D(668, 400);
    b = new Vector2D(668, 625);
    c = new Vector2D(668, 850);
    this.m_positionsAttack = [a, b, c];
    this.m_countBulletsBurst = this.m_currentIdAttack = 0;
    this.m_speedMovement = -Application.config.atat.speedWalk;
    this.m_dashAttacks = this.m_damage = 0;
    this.m_speedMoveToAttack = Application.config.atat.speedMoveToAttack;
    this.m_offsetPositionsY = [200, 100, 0, -100];
    this.m_initX = this.m_x;
    this.m_initY = this.m_y;
    this.m_canAppear = this.isRangeControlled = !1;
    this.m_playerRef =
        this.m_world.player();
    this.m_timerTotalExplosion = this.m_timerPerExplosion = this.m_timerToHit = 0;
    this.m_effectChargeLeftCannon = this.m_world.createContainerEffect("aniFxBossCharge", this.m_x, this.m_y, 1.5);
    this.m_effectChargeLeftCannon.setPause(!0);
    this.m_effectChargeRightCannon = this.m_world.createContainerEffect("aniFxBossCharge", this.m_x, this.m_y, 1.5);
    this.m_effectChargeRightCannon.setPause(!0);
    this.m_effectDash = this.m_world.createEffect("aniFxBoss02Dash", this.m_x, this.m_y);
    this.m_effectDash.setPause(!0);
    this.effectTimer = this.m_tint = this.m_countTint = this.m_timerTint = 0;
    this.m_scaleWeapon = new Vector2D;
    this.init()
}
Application.subclass(HeadAtat, SimpleWorldActor);
HeadAtat.instance = null;
HeadAtat.TIME_PER_TINT = 80;
HeadAtat.COUNT_TINTS = 4;
HeadAtat.TIME_PER_EXPLOSION = 150;
HeadAtat.TIME_TOTAL_EXPLOSION = 4E3;
HeadAtat.TIME_STAND_AFTER_DASH = 500;
HeadAtat.TIME_FOR_NEXT_HIT = 400;
HeadAtat.NO_BEHAVIOR = 0;
HeadAtat.BEHAVIOR_WITH_CANNON = 1;
HeadAtat.BEHAVIOR_NO_CANNON = 2;
HeadAtat.STATE_IDLE = 0;
HeadAtat.STATE_STAND = 100;
HeadAtat.STATE_CANNON = 101;
HeadAtat.STATE_BULLET_BURST = 102;
HeadAtat.STATE_DASH = 103;
HeadAtat.STATE_MOVE_TO_ATTACK = 104;
HeadAtat.STATE_VULNERABLE = 106;
HeadAtat.NUMBER_DASH_ATTACKS = 2;
HeadAtat.LIMIT_Y_UP = 300;
HeadAtat.LIMIT_Y_DOWN = 150;
HeadAtat.VULNERABLE_EFFECT_DELAY = 500;
HeadAtat.ST_STAND = "st1";
HeadAtat.ST_DASH_PRE = "st2";
HeadAtat.ST_DASH_FRONT = "st3";
HeadAtat.ST_DASH_BACK = "st4";
HeadAtat.ST_DASH_POST = "st5";
HeadAtat.ST_ATTACK_CANNON = "st6";
HeadAtat.ST_ATTACK_BURST_PRE = "st7";
HeadAtat.ST_ATTACK_BURST = "st8";
HeadAtat.ST_ATTACK_BURST_END = "st9";
HeadAtat.ST_HIT = "st10";
HeadAtat.ST_DEFEAT = "st11";
HeadAtat.ST_WARNING = "st12";
HeadAtat.ST_APPEAR = "st13";
HeadAtat.ST_VULNERABLE = "st14";
HeadAtat.ST_APPEAR_PRE = "st15";
HeadAtat.DISTANCE_TO_APPEAR = 450;
HeadAtat.GRAVITY = .0035;
HeadAtat.prototype.free = function() {
    HeadAtat.instance = null;
    this.m_effectChargeLeftCannon && (this.m_effectChargeLeftCannon.isAwaitingDelete = !0, this.m_effectChargeLeftCannon = null);
    this.m_effectChargeRightCannon && (this.m_effectChargeRightCannon.isAwaitingDelete = !0, this.m_effectChargeRightCannon = null);
    this.m_effectDash && (this.m_effectDash.isAwaitingDelete = !0, this.m_effectDash = null);
    SimpleWorldActor.prototype.free.call(this)
};
HeadAtat.prototype.init = function() {
    this.m_character = new SimpleCharacter(0, 0, this.m_canvas);
    this.m_character.addState(HeadAtat.ST_STAND, this.skin + "_stand");
    this.m_character.addState(HeadAtat.ST_HIT, this.skin + "_hit");
    this.m_character.addState(HeadAtat.ST_DASH_PRE, this.skin + "_dashStart");
    this.m_character.addState(HeadAtat.ST_DASH_FRONT, this.skin + "_dashStand");
    this.m_character.addState(HeadAtat.ST_DASH_BACK, this.skin + "_dashStand");
    this.m_character.addState(HeadAtat.ST_DASH_POST, this.skin + "_dashEnd");
    this.m_character.addState(HeadAtat.ST_DEFEAT, this.skin + "_defeat");
    this.m_character.addState(HeadAtat.ST_VULNERABLE, this.skin + "_stand");
    this.m_character.addState(HeadAtat.ST_ATTACK_BURST_PRE, this.skin + "_attack1_start");
    this.m_character.addState(HeadAtat.ST_ATTACK_BURST, this.skin + "_attack1_stand");
    this.m_character.addState(HeadAtat.ST_ATTACK_BURST_END, this.skin + "_attack1_end");
    var a = [{
        caller: this,
        callback: this.createCannonLeft,
        frame: 48
    }, {
        caller: this,
        callback: this.createCannonRight,
        frame: 53
    }];
    this.m_character.addState(HeadAtat.ST_ATTACK_CANNON,
        this.skin + "_attack2", a);
    this.m_character.addState(HeadAtat.ST_WARNING, this.skin + "_alert");
    a = [{
        caller: this,
        callback: this.doCratesExplosion,
        frame: 29
    }, {
        caller: this,
        callback: this.doBreakObstacleSound,
        frame: 30
    }, {
        caller: this,
        callback: this.doStepSound,
        frame: 31
    }, {
        caller: this,
        callback: this.doShake,
        frame: 34
    }, {
        caller: this,
        callback: this.doBreakObstacleSound,
        frame: 35
    }, {
        caller: this,
        callback: this.doStepSound,
        frame: 36
    }, {
        caller: this,
        callback: this.doShake,
        frame: 67
    }, {
        caller: this,
        callback: this.doBreakObstacleSound,
        frame: 68
    }, {
        caller: this,
        callback: this.doStepSound,
        frame: 69
    }, {
        caller: this,
        callback: this.doShake,
        frame: 98
    }, {
        caller: this,
        callback: this.doStepSound,
        frame: 99
    }];
    this.m_character.addState(HeadAtat.ST_APPEAR, this.skin + "_appear", a);
    this.m_character.addState(HeadAtat.ST_APPEAR_PRE, this.skin + "_appear_pre");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.gotoState(HeadAtat.ST_APPEAR_PRE);
    HudPlatform.instance.setEnergyBoss(1E3)
};
HeadAtat.prototype.doBreakObstacleSound = function() {
    Application.instance.playSound("SND_BOSS_OBSTACLE_DESTROY")
};
HeadAtat.prototype.doStepSound = function() {
    this.unitSounds.playState("walk")
};
HeadAtat.prototype.doShake = function() {
    Global.game.onShake(10, 15, 300)
};
HeadAtat.prototype.doCratesExplosion = function() {
    this.m_world.createContainerEffect("aniFxEnemyExplote", this.m_x - 120, this.m_y - 150, 2)
};
HeadAtat.prototype.updatePlayerCoop = function() {
    this.m_playerRef = this.m_world.player();
    HudPlatform.instance.stopTimingOut()
};
HeadAtat.prototype.createCannonLeft = function() {
    this.unitSounds.playState(HeadAtat.ST_ATTACK_CANNON);
    var a = -Math.PI,
        b = this.m_clip.mcCanionL ? this.m_clip.mcCanionL.position.x * this.scale : 0,
        c = this.m_clip.mcCanionL ? this.m_clip.mcCanionL.position.y * this.scale : 0,
        b = b + 600 * Math.cos(a),
        c = c + 600 * Math.sin(a);
    this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_ENEMY_NO_DEFLECT, "aniFxBoss03Bullet01", this.m_x + b + 200, this.m_y + c, 1200, a, Application.config.atat.speedCannon, Application.config.atat.damageCannon,
        Bullet.FX_IMPACT_BOSS);
    this.m_world.createEffect("aniFxBoss03Shoot", this.m_x + b, this.m_y + c);
    this.m_effectChargeLeftCannon.setPause(!0)
};
HeadAtat.prototype.createCannonRight = function() {
    this.unitSounds.playState(HeadAtat.ST_ATTACK_CANNON);
    var a = -Math.PI,
        b = this.m_clip.mcCanionR ? this.m_clip.mcCanionR.position.x * this.scale : 0,
        c = this.m_clip.mcCanionR ? this.m_clip.mcCanionR.position.y * this.scale : 0,
        b = b + 600 * Math.cos(a),
        c = c + 600 * Math.sin(a);
    this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_ENEMY_NO_DEFLECT, "aniFxBoss03Bullet01", this.m_x + b + 200, this.m_y + c, 1200, a, Application.config.atat.speedCannon, Application.config.atat.damageCannon,
        Bullet.FX_IMPACT_BOSS);
    this.m_world.createEffect("aniFxBoss03Shoot", this.m_x + b, this.m_y + c);
    this.m_effectChargeRightCannon.setPause(!0)
};
HeadAtat.prototype.createBulletLeft = function() {
    this.unitSounds.playState(HeadAtat.ST_ATTACK_BURST);
    var a = this.m_angleWeaponLeft,
        b = this.m_clip.mcWeaponL ? this.m_clip.mcWeaponL.position.x * this.scale : 0,
        c = this.m_clip.mcWeaponL ? this.m_clip.mcWeaponL.position.y * this.scale : 0,
        b = b + 390 * Math.cos(a),
        c = c + 390 * Math.sin(a);
    this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_ENEMY, "aniFxBoss01Bullet01", this.m_x + b, this.m_y + c, 1200, a, Application.config.atat.speedBurstBullet, Application.config.atat.damageBurstBullet,
        Bullet.FX_IMPACT_BOSS);
    this.m_world.createEffect("aniFxBoss01Shoot", this.m_x + b, this.m_y + c)
};
HeadAtat.prototype.createBulletRight = function() {
    this.unitSounds.playState(HeadAtat.ST_ATTACK_BURST);
    var a = this.m_angleWeaponRight,
        b = this.m_clip.mcWeaponR ? this.m_clip.mcWeaponR.position.x * this.scale : 0,
        c = this.m_clip.mcWeaponR ? this.m_clip.mcWeaponR.position.y * this.scale : 0,
        b = b + 390 * Math.cos(a),
        c = c + 390 * Math.sin(a);
    this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_ENEMY, "aniFxBoss01Bullet01", this.m_x + b, this.m_y + c, 1200, a, Application.config.atat.speedBurstBullet, Application.config.atat.damageBurstBullet,
        Bullet.FX_IMPACT_BOSS);
    this.m_world.createEffect("aniFxBoss01Shoot", this.m_x + b, this.m_y + c)
};
HeadAtat.prototype.onEndAnimation = function(a) {
    switch (a) {
        case HeadAtat.ST_APPEAR:
            this.setStateBoss(HeadAtat.STATE_STAND);
            break;
        case HeadAtat.ST_WARNING:
            switch (this.m_bossState) {
                case HeadAtat.STATE_CANNON:
                    this.gotoState(HeadAtat.ST_ATTACK_CANNON);
                    break;
                case HeadAtat.STATE_BULLET_BURST:
                    this.gotoState(HeadAtat.ST_ATTACK_BURST_PRE)
            }
            break;
        case HeadAtat.ST_DASH_PRE:
            this.gotoState(HeadAtat.ST_DASH_FRONT);
            this.m_effectDash.setPause(!1);
            break;
        case HeadAtat.ST_ATTACK_BURST_PRE:
            this.gotoState(HeadAtat.ST_ATTACK_BURST);
            this.m_timerBurst = Application.config.atat.timePerBurst;
            a = this.m_clip.mcWeaponL ? this.m_clip.mcWeaponL.position.x * this.scale : 0;
            var b = this.m_clip.mcWeaponL ? this.m_clip.mcWeaponL.position.y * this.scale : 0;
            a = this.m_positionsAttack[this.m_currentIdAttack].x - (this.m_x + a);
            var b = this.m_positionsAttack[this.m_currentIdAttack].y - (this.m_y + b),
                c = Math.sqrt(a * a + b * b);
            a = Math.acos(a / c);
            this.m_initAngleWeaponLeft = this.m_angleWeaponLeft = 0 > b ? -a : a;
            a = this.m_clip.mcWeaponR ? this.m_clip.mcWeaponR.position.x * this.scale : 0;
            b = this.m_clip.mcWeaponR ?
                this.m_clip.mcWeaponR.position.y * this.scale : 0;
            a = this.m_positionsAttack[this.m_currentIdAttack].x - (this.m_x + a);
            b = this.m_positionsAttack[this.m_currentIdAttack].y - (this.m_y + b);
            c = Math.sqrt(a * a + b * b);
            a = Math.acos(a / c);
            this.m_initAngleWeaponRight = this.m_angleWeaponRight = 0 > b ? -a : a;
            this.m_clipLeftWeapon.rotation = this.m_angleWeaponLeft - Math.PI;
            this.m_clipRightWeapon.rotation = this.m_angleWeaponRight - Math.PI;
            break;
        case HeadAtat.ST_ATTACK_BURST_END:
            this.m_currentIdAttack = this.m_currentIdAttack + 1 >= this.m_positionsAttack.length ?
                0 : this.m_currentIdAttack + 1;
            0 === this.m_currentIdAttack ? this.setStateBoss(HeadAtat.STATE_VULNERABLE) : this.setStateBoss(HeadAtat.STATE_BULLET_BURST);
            break;
        case HeadAtat.ST_ATTACK_CANNON:
            this.gotoState(HeadAtat.ST_STAND);
            this.checkSpeedForOriginalPos();
            break;
        case HeadAtat.ST_HIT:
            this.m_bossState === HeadAtat.STATE_VULNERABLE ? this.gotoState(HeadAtat.ST_VULNERABLE) : this.gotoState(HeadAtat.ST_STAND);
            break;
        case HeadAtat.ST_DEFEAT:
            this.m_world.m_camera.doBlendWithTarget(this.m_world.m_player, 60, -150, 5, !0, null,
                null, null), this.m_playerRef.onWin(!1)
    }
};
HeadAtat.prototype.checkSpeedForOriginalPos = function() {
    this.m_initY >= this.m_y ? this.m_speedMoveToAttack = Application.config.atat.speedMoveToAttack : this.m_initY < this.m_y && (this.m_speedMoveToAttack = -Application.config.atat.speedMoveToAttack)
};
HeadAtat.prototype.onHit = function(a) {
    if (this.m_state === HeadAtat.ST_DEFEAT || this.m_state === HeadAtat.ST_HIT || this.m_state === HeadAtat.ST_APPEAR || this.m_state === HeadAtat.ST_APPEAR_PRE) return !1;
    this.completeHit = !0;
    this.m_timerToHit = HeadAtat.TIME_FOR_NEXT_HIT;
    a = a > this.health ? this.health : a;
    this.health -= a;
    PlayerSettings.instance.updatePlayerBossDamage(a, this.m_initialHealth);
    Application.info("boss health: " + this.health);
    if (100 * this.health / this.m_initialHealth <= Application.config.atat.healthThreshold && this.m_behavior ===
        HeadAtat.BEHAVIOR_WITH_CANNON) {
        this.m_behavior = HeadAtat.BEHAVIOR_NO_CANNON;
        this.setStateBoss(HeadAtat.STATE_STAND);
        a = this.m_clip.mcCanionL ? this.m_clip.mcCanionL.position.x * this.scale : 0;
        var b = this.m_clip.mcCanionL ? this.m_clip.mcCanionL.position.y * this.scale : 0;
        this.m_world.createEffect("aniFxBulletExplotion", this.m_x + a - 300, this.m_y + b);
        a = this.m_clip.mcCanionR ? this.m_clip.mcCanionR.position.x * this.scale : -300;
        b = this.m_clip.mcCanionR ? this.m_clip.mcCanionR.position.y * this.scale : 0;
        this.m_world.createEffect("aniFxBulletExplotion",
            this.m_x + a - 300, this.m_y + b);
        return !0
    }
    0 >= this.health ? (this.health = 0, this.isAwaitingLose = !0, HudPlatform.instance.setEnergyBoss(1), this.m_timerPerExplosion = 10, this.m_timerTotalExplosion = HeadAtat.TIME_TOTAL_EXPLOSION) : (this.unitSounds.playState(HeadAtat.ST_HIT), a = Math.ceil(this.health / this.m_initialHealth * 999) + 1, HudPlatform.instance.setEnergyBoss(a), this.m_bossState === HeadAtat.STATE_STAND && this.gotoState(HeadAtat.ST_HIT), this.onTint(16728642), this.m_timerTint = HeadAtat.TIME_PER_TINT, this.m_countTint = HeadAtat.COUNT_TINTS);
    return !0
};
HeadAtat.prototype.onTint = function(a) {
    this.m_clip.setTint(a);
    this.m_tint = a;
    this.m_clipLeftWeapon && this.m_clipLeftWeapon.setTint(a);
    this.m_clipRightWeapon && this.m_clipRightWeapon.setTint(a);
    this.m_clipLeftCannon && this.m_clipLeftCannon.setTint(a);
    this.m_clipRightCannon && this.m_clipRightCannon.setTint(a)
};
HeadAtat.prototype.gotoStand = function() {
    this.gotoState(HeadAtat.ST_STAND)
};
HeadAtat.prototype.gotoState = function(a) {
    SimpleWorldActor.prototype.gotoState.call(this, a);
    switch (a) {
        case HeadAtat.ST_APPEAR:
        case HeadAtat.ST_DEFEAT:
            this.unitSounds.playState(a)
    }
    a === HeadAtat.ST_ATTACK_CANNON ? (this.m_effectChargeLeftCannon.setPause(!1), this.m_effectChargeRightCannon.setPause(!1)) : (this.m_effectChargeLeftCannon.setPause(!0), this.m_effectChargeRightCannon.setPause(!0));
    PoolClips.instance.releaseClip(this.m_clipLeftWeapon);
    this.m_clipLeftWeapon = null;
    PoolClips.instance.releaseClip(this.m_clipRightWeapon);
    this.m_clipRightWeapon = null;
    PoolClips.instance.releaseClip(this.m_clipLeftCannon);
    this.m_clipLeftCannon = null;
    PoolClips.instance.releaseClip(this.m_clipRightCannon);
    this.m_clipRightCannon = null;
    if (this.m_clip) {
        a = "";
        if (this.m_clip.mcWeaponL) {
            this.m_clipLeftWeapon = PoolClips.instance.getClip(this.skin + "_weapon1");
            this.m_clip.mcWeaponL.addChild(this.m_clipLeftWeapon);
            if (0 === this.m_scaleWeapon.x || 0 === this.m_scaleWeapon.y) this.m_scaleWeapon.x = this.m_clipLeftWeapon.scale.x, this.m_scaleWeapon.y = this.m_clipLeftWeapon.scale.y;
            this.m_clipLeftWeapon.scale.x = this.m_scaleWeapon.x / Application.DPI;
            this.m_clipLeftWeapon.scale.y = this.m_scaleWeapon.y / Application.DPI;
            this.m_angleWeaponLeft = 0;
            this.m_clipLeftWeapon.rotation = this.m_angleWeaponLeft
        }
        if (this.m_clip.mcWeaponR) {
            this.m_clipRightWeapon = PoolClips.instance.getClip(this.skin + "_weapon1");
            this.m_clip.mcWeaponR.addChild(this.m_clipRightWeapon);
            if (0 === this.m_scaleWeapon.x || 0 === this.m_scaleWeapon.y) this.m_scaleWeapon.x = this.m_clipRightWeapon.scale.x, this.m_scaleWeapon.y = this.m_clipRightWeapon.scale.y;
            this.m_clipRightWeapon.scale.x = this.m_scaleWeapon.x / Application.DPI;
            this.m_clipRightWeapon.scale.y = this.m_scaleWeapon.y / Application.DPI;
            this.m_angleWeaponRight = 0;
            this.m_clipRightWeapon.rotation = this.m_angleWeaponRight
        }
        if (this.m_clip.mcCanionL) {
            a = this.m_behavior === HeadAtat.BEHAVIOR_NO_CANNON ? "_canion2" : "_canion1";
            this.m_clipLeftCannon = PoolClips.instance.getClip(this.skin + a);
            this.m_clip.mcCanionL.addChild(this.m_clipLeftCannon);
            if (0 === this.m_scaleWeapon.x || 0 === this.m_scaleWeapon.y) this.m_scaleWeapon.x =
                this.m_clipLeftCannon.scale.x, this.m_scaleWeapon.y = this.m_clipLeftCannon.scale.y;
            this.m_clipLeftCannon.scale.x = this.m_scaleWeapon.x / Application.DPI;
            this.m_clipLeftCannon.scale.y = this.m_scaleWeapon.y / Application.DPI;
            this.m_clipLeftCannon.rotation = 0
        }
        if (this.m_clip.mcCanionR) {
            a = this.m_behavior === HeadAtat.BEHAVIOR_NO_CANNON ? "_canion2" : "_canion1";
            this.m_clipRightCannon = PoolClips.instance.getClip(this.skin + a);
            this.m_clip.mcCanionR.addChild(this.m_clipRightCannon);
            if (0 === this.m_scaleWeapon.x || 0 === this.m_scaleWeapon.y) this.m_scaleWeapon.x =
                this.m_clipRightCannon.scale.x, this.m_scaleWeapon.y = this.m_clipRightCannon.scale.y;
            this.m_clipRightCannon.scale.x = this.m_scaleWeapon.x / Application.DPI;
            this.m_clipRightCannon.scale.y = this.m_scaleWeapon.y / Application.DPI;
            this.m_clipRightCannon.rotation = 0
        }
    }
    if (0 < this.m_timerTint) this.onTint(this.m_tint)
};
HeadAtat.prototype.onEndLock = function() {
    this.m_canAppear = !0;
    this.gotoState(HeadAtat.ST_APPEAR);
    this.m_world.m_camera.m_lockState = Camera.LOCK_ON
};
HeadAtat.prototype.update = function(a) {
    this.checkPlayerNearby();
    if (0 < this.m_timerTint && (this.m_timerTint -= a, 0 >= this.m_timerTint))
        if (--this.m_countTint, 0 < this.m_countTint) {
            var b = this.m_tint === (this.completeHit ? 16728642 : 16711937) ? 16777215 : this.completeHit ? 16728642 : 16711937;
            this.m_clip.alpha = this.completeHit ? 1 : .7;
            this.onTint(b);
            this.m_timerTint = HeadAtat.TIME_PER_TINT
        } else this.m_clip.alpha = 1, this.onTint(16777215), this.m_timerTint = 0;
    SimpleWorldActor.prototype.update.call(this, a);
    if (this.isAwaitingLose) {
        this.m_bossState !==
            HeadAtat.STATE_DASH && this.m_state !== HeadAtat.ST_DEFEAT && (this.gotoState(HeadAtat.ST_DEFEAT), this.m_clip.loop = !1);
        if (0 < this.m_timerTotalExplosion) {
            if (0 < this.m_timerPerExplosion && (this.m_timerPerExplosion -= a, 0 >= this.m_timerPerExplosion)) {
                this.m_timerPerExplosion = HeadAtat.TIME_PER_EXPLOSION;
                var c = b = 0;
                this.m_clip.mcHead && (b = this.m_clip.mcHead.position.x * this.scale, c = this.m_clip.mcHead.position.y * this.scale);
                var b = Common.randomInt(this.m_x + b - 150, this.m_x + b + 150),
                    c = Common.randomInt(this.m_y + c - 100, this.m_y +
                        c + 100),
                    d = Common.randomInt(100, 150);
                this.m_world.createContainerEffect("aniFxEnemyExplote", b, c, d / 100);
                Application.instance.playSound("SND_BOSS_DEFEAT_EXPLOSION")
            }
            this.m_timerTotalExplosion -= a;
            0 >= this.m_timerTotalExplosion && (c = b = this.m_timerTotalExplosion = this.m_timerPerExplosion = 0, this.m_clip.mcHead && (b = this.m_clip.mcHead.position.x * this.scale, c = this.m_clip.mcHead.position.y * this.scale), this.m_world.createContainerEffect("aniFxcooldownatdp", this.m_x + b - 140, this.m_y + c, 2))
        }
        if (this.m_state === HeadAtat.ST_DEFEAT) {
            this.m_y +
                150 <= this.m_initY && (this.m_y += Application.config.atat.speedMoveToAttack * a);
            return
        }
    }
    if (this.m_canAppear) {
        0 < this.m_timerToHit && (this.m_timerToHit -= a, this.m_timerToHit = 0 > this.m_timerToHit ? 0 : this.m_timerToHit);
        if (0 >= this.m_timerToHit)
            if (this.m_world.m_player.clipSpecialAttack) {
                if (SDisplayObjectContainer.hitTestByBounds(this.m_clip, this.m_clip.getCollision(SimpleWorldActor.COLLISION), this.m_world.m_player.clipSpecialAttack, this.m_world.m_player.clipSpecialAttack.getCollision(SimpleWorldActor.COLLISION_SPECIAL))) this.onHit(this.m_playerRef.data.specialDamagetoBoss)
            } else this.hitCollisions(SimpleWorldActor.COLLISION,
                this.m_world.m_player, SimpleWorldActor.COLLISION_ATTACK) && this.onHit(this.m_playerRef.data.regularDamageToBoss) && (this.m_world.createEffect("aniFxPlayerHit", this.m_playerRef.m_x + 60, this.m_playerRef.m_y - 80), Global.game.onShake(4, 10, 200));
        this.m_effectChargeLeftCannon && this.m_state === HeadAtat.ST_ATTACK_CANNON && (b = this.m_clip.mcCanionL ? this.m_clip.mcCanionL.position.x : 0, c = this.m_clip.mcCanionL ? this.m_clip.mcCanionL.position.y : 0, this.m_effectChargeLeftCannon.canvas.position.x = this.m_x + (b - 600), this.m_effectChargeLeftCannon.canvas.position.y =
            this.m_y + c);
        this.m_effectChargeRightCannon && this.m_state === HeadAtat.ST_ATTACK_CANNON && (b = this.m_clip.mcCanionR ? this.m_clip.mcCanionR.position.x : 0, c = this.m_clip.mcCanionR ? this.m_clip.mcCanionR.position.y : 0, b -= 600, this.m_effectChargeRightCannon.canvas.position.x = this.m_x + b, this.m_effectChargeRightCannon.canvas.position.y = this.m_y + c);
        this.m_effectDash && this.m_state === HeadAtat.ST_DASH_FRONT && (this.m_effectDash.x = this.m_x - 300, this.m_effectDash.y = this.m_y - 200);
        this.updateStates(a)
    } else 600 <= this.m_world.m_player.m_x &&
        this.m_world.m_camera.m_lockState === Camera.LOCK_OFF && this.m_world.m_camera.doBlendWithPos(950, 675, this.m_world.m_camera.fixOffsetX, 0, 5, !0, this, this.onEndLock, null)
};
HeadAtat.prototype.updateStates = function(a) {
    switch (this.m_behavior) {
        case HeadAtat.BEHAVIOR_WITH_CANNON:
            switch (this.m_bossState) {
                case HeadAtat.STATE_STAND:
                    0 < this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(HeadAtat.STATE_MOVE_TO_ATTACK));
                    break;
                case HeadAtat.STATE_MOVE_TO_ATTACK:
                    if (0 < this.m_timerToNextState) {
                        if (this.m_playerRef.m_y - 50 > this.m_y) this.m_speedMoveToAttack = Application.config.atat.speedMoveToAttack;
                        else if (this.m_playerRef.m_y + 50 < this.m_y) this.m_speedMoveToAttack = -Application.config.atat.speedMoveToAttack;
                        else {
                            var b = this.m_playerRef.m_y - this.m_y,
                                c = 0 > b ? -1 : 1;
                            this.m_speedMoveToAttack = (0 > b ? -b : b) / 50 * Application.config.atat.speedMoveToAttack * c * .5
                        }
                        this.m_y += this.m_speedMoveToAttack * a;
                        this.m_y < this.m_initY - HeadAtat.LIMIT_Y_UP ? this.m_y = this.m_initY - HeadAtat.LIMIT_Y_UP : this.m_y > this.m_initY + HeadAtat.LIMIT_Y_DOWN && (this.m_y = this.m_initY + HeadAtat.LIMIT_Y_DOWN);
                        this.m_timerToNextState -= a;
                        0 >= this.m_timerToNextState && this.setStateBoss(HeadAtat.STATE_CANNON)
                    }
                    break;
                case HeadAtat.STATE_CANNON:
                    0 <
                        this.m_timerToNextState && (0 !== this.m_speedMoveToAttack && this.m_state === HeadAtat.ST_STAND && (this.m_y += this.m_speedMoveToAttack * a, 0 < this.m_speedMoveToAttack ? this.m_y >= this.m_initY && (this.m_y = this.m_initY, this.m_speedMoveToAttack = 0) : this.m_y <= this.m_initY && (this.m_y = this.m_initY, this.m_speedMoveToAttack = 0)), this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(HeadAtat.STATE_BULLET_BURST));
                    break;
                case HeadAtat.STATE_BULLET_BURST:
                    this.onBulletBurst(a);
                    break;
                case HeadAtat.STATE_VULNERABLE:
                    0 <
                        this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(HeadAtat.STATE_STAND)), this.doVulnerableEffect(a)
            }
            break;
        case HeadAtat.BEHAVIOR_NO_CANNON:
            switch (this.m_bossState) {
                case HeadAtat.STATE_STAND:
                    0 < this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(HeadAtat.STATE_MOVE_TO_ATTACK));
                    break;
                case HeadAtat.STATE_MOVE_TO_ATTACK:
                    0 < this.m_timerToNextState && (this.m_speedMoveToAttack = this.m_playerRef.m_y - 5 > this.m_y ? Application.config.atat.speedMoveToAttack :
                        this.m_playerRef.m_y + 5 < this.m_y ? -Application.config.atat.speedMoveToAttack : 0, this.m_y += this.m_speedMoveToAttack * a, this.m_y < this.m_initY - HeadAtat.LIMIT_Y_UP ? this.m_y = this.m_initY - HeadAtat.LIMIT_Y_UP : this.m_y > this.m_initY + HeadAtat.LIMIT_Y_DOWN && (this.m_y = this.m_initY + HeadAtat.LIMIT_Y_DOWN), this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(HeadAtat.STATE_DASH));
                    break;
                case HeadAtat.STATE_DASH:
                    if (this.hitCollisions(SimpleWorldActor.COLLISION_ATTACK, this.m_playerRef, SimpleWorldActor.COLLISION)) this.m_playerRef.onEnemyCollision(this,
                        this.m_damage);
                    this.m_state !== HeadAtat.ST_DASH_PRE && (0 > this.m_speedMovement ? this.m_x > this.m_initX - Application.config.atat.distanceWalk && (this.m_x += this.m_speedMovement * a, this.m_x <= this.m_initX - Application.config.atat.distanceWalk && (this.m_x = this.m_initX - Application.config.atat.distanceWalk, this.m_speedMovement *= -1, this.m_timerStandAfterDash = HeadAtat.TIME_STAND_AFTER_DASH, this.m_effectDash.setPause(!0))) : this.m_state === HeadAtat.ST_STAND ? 0 < this.m_timerStandAfterDash && (this.m_timerStandAfterDash -= a,
                        0 >= this.m_timerStandAfterDash && this.gotoState(HeadAtat.ST_DASH_BACK)) : this.m_x < this.m_initX && (this.m_x += this.m_speedMovement * a, this.m_x >= this.m_initX && (this.m_x = this.m_initX, this.m_dashAttacks >= HeadAtat.NUMBER_DASH_ATTACKS ? (this.m_dashAttacks = 0, this.setStateBoss(HeadAtat.STATE_BULLET_BURST), this.checkSpeedForOriginalPos()) : this.setStateBoss(HeadAtat.STATE_MOVE_TO_ATTACK))));
                    break;
                case HeadAtat.STATE_BULLET_BURST:
                    0 !== this.m_speedMoveToAttack && (this.m_y += this.m_speedMoveToAttack * a, 0 < this.m_speedMoveToAttack ?
                        this.m_y >= this.m_initY && (this.m_y = this.m_initY, this.m_speedMoveToAttack = 0) : this.m_y <= this.m_initY && (this.m_y = this.m_initY, this.m_speedMoveToAttack = 0));
                    this.onBulletBurst(a);
                    break;
                case HeadAtat.STATE_VULNERABLE:
                    0 < this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(HeadAtat.STATE_STAND)), this.doVulnerableEffect(a)
            }
    }
};
HeadAtat.prototype.doVulnerableEffect = function(a) {
    this.effectTimer += a;
    this.effectTimer > HeadAtat.VULNERABLE_EFFECT_DELAY && (this.effectTimer = 0, a = this.m_clip.getCollision("mcCollision"), this.m_world.createEffect("aniFxBoss02Damage", this.m_x + a.x + 300 + Math.random() * (.5 * a.w - 300), this.m_y + .8 * a.y + .25 * Math.random() * a.h))
};
HeadAtat.prototype.onBulletBurst = function(a) {
    if (this.m_state === HeadAtat.ST_ATTACK_BURST) {
        this.m_angleWeaponLeft += this.m_speedWeaponAngleLeft * a;
        this.m_angleWeaponRight += this.m_speedWeaponAngleRight * a;
        if (0 < this.m_speedWeaponAngleLeft && this.m_angleWeaponLeft > this.m_initAngleWeaponLeft + .05 * Math.PI || 0 > this.m_speedWeaponAngleLeft && this.m_angleWeaponLeft < this.m_initAngleWeaponLeft - .05 * Math.PI) this.m_speedWeaponAngleLeft *= -1;
        if (0 < this.m_speedWeaponAngleRight && this.m_angleWeaponRight > this.m_initAngleWeaponRight +
            .05 * Math.PI || 0 > this.m_speedWeaponAngleRight && this.m_angleWeaponRight < this.m_initAngleWeaponRight - .05 * Math.PI) this.m_speedWeaponAngleRight *= -1;
        this.m_clipLeftWeapon.rotation = this.m_angleWeaponLeft - Math.PI;
        this.m_clipRightWeapon.rotation = this.m_angleWeaponRight - Math.PI;
        0 < this.m_timerBurst && (this.m_timerBurst -= a, 0 >= this.m_timerBurst && (this.createBulletLeft(), this.createBulletRight(), this.m_timerBurst = Application.config.atat.timePerBurst, this.m_countBulletsBurst--, 0 >= this.m_countBulletsBurst && this.gotoState(HeadAtat.ST_ATTACK_BURST_END)))
    }
};
HeadAtat.prototype.checkPlayerNearby = function() {
    var a = this.m_x - 500 - this.m_playerRef.m_x;
    200 > (0 > a ? -a : a) && (PlatformGame.playerNearEnemy = !0);
    this.m_world.m_player.m_clip.hitTest(this.m_clip) && (this.m_world.m_player.m_x += -5)
};
HeadAtat.prototype.setStateBoss = function(a) {
    this.m_bossState = a;
    switch (a) {
        case HeadAtat.STATE_STAND:
            this.m_timerToNextState = Application.config.atat.timeStateStand;
            this.gotoState(HeadAtat.ST_STAND);
            break;
        case HeadAtat.STATE_MOVE_TO_ATTACK:
            this.m_timerToNextState = Application.config.atat.timeStateMoveToAttack;
            this.gotoState(HeadAtat.ST_STAND);
            break;
        case HeadAtat.STATE_CANNON:
            this.gotoState(HeadAtat.ST_ATTACK_CANNON);
            this.m_timerToNextState = Application.config.atat.timeCannon;
            break;
        case HeadAtat.STATE_BULLET_BURST:
            0 <
                this.m_currentIdAttack ? this.gotoState(HeadAtat.ST_ATTACK_BURST_PRE) : this.gotoState(HeadAtat.ST_WARNING);
            this.m_countBulletsBurst = Application.config.atat.numberOfBullets;
            break;
        case HeadAtat.STATE_VULNERABLE:
            this.gotoState(HeadAtat.ST_VULNERABLE);
            this.m_timerToNextState = Application.config.atat.timeVulnerable;
            break;
        case HeadAtat.STATE_DASH:
            this.gotoState(HeadAtat.ST_DASH_PRE), this.m_speedMovement = -Application.config.atat.speedWalk, this.m_damage = Application.config.atat.damageDash, this.m_dashAttacks++
    }
};

function TIEFighter(a, b, c) {
    SimpleWorldActor.call(this, a, b, c.x, c.y);
    TIEFighter.instance = this;
    this.isEnemy = !0;
    this.completeHit = !1;
    this.skin = "mcBoss4";
    this.isBoss = !0;
    this.m_initialHealth = 100;
    switch (MissionManager.instance.getGameMode()) {
        case MissionManager.GAME_SINGLEPLAYER:
            this.m_initialHealth = Application.config.tie_fighter.initHealth;
            break;
        case MissionManager.GAME_COOPERATIVE:
            this.m_initialHealth = Application.config.tie_fighter.initHealthCoop;
            break;
        case MissionManager.GAME_VERSUS:
            this.m_initialHealth =
                Application.config.tie_fighter.initHealthVS
    }
    this.health = this.m_initialHealth;
    this.m_behavior = TIEFighter.BEHAVIOR_WITH_CANNON;
    this.m_bossState = TIEFighter.STATE_IDLE;
    this.m_timerToNextState = Application.config.tie_fighter.timeStateStand;
    this.m_timerBurst = 0;
    this.scale = 1;
    this.m_angleWeapon = 0;
    this.m_speedWeaponAngle = .001 * Math.PI;
    this.m_speedMovement = Application.config.tie_fighter.speedMovement;
    this.m_speed = new Vector2D(0, 0);
    this.m_moveAnimFinished = this.m_isFinishedMoves = !1;
    this.m_damage = this.m_countBulletsBurst =
        0;
    this.m_initX = this.m_x;
    this.m_initY = this.m_y;
    this.m_canAppear = this.isRangeControlled = !1;
    this.m_playerRef = this.m_world.player();
    this.m_timerToHit = 0;
    this.m_effectChargeHomingLeft = this.m_world.createEffect("aniFxBossCharge", this.m_x, this.m_y);
    this.m_effectChargeHomingLeft.setPause(!0);
    this.m_effectChargeHomingRight = this.m_world.createEffect("aniFxBossCharge", this.m_x, this.m_y);
    this.m_effectChargeHomingRight.setPause(!0);
    this.unitSounds = new UnitSounds("TIE");
    a = new Vector2D(421, 256);
    b = new Vector2D(421,
        656);
    c = new Vector2D(1620, 256);
    var d = new Vector2D(1620, 656);
    this.m_positionsMovement = [a, b, c, d];
    this.m_timerTotalExplosion = this.m_timerPerExplosion = this.m_currentIdMovement = 0;
    this.m_object = new ObjectTIEFighter(this.m_world.m_playerCanvas, this.m_world, 1200, 1048, this);
    this.m_world.actorManager().add(this.m_object);
    this.effectTimer = this.m_tint = this.m_countTint = this.m_timerTint = this.m_countInitialBullets = this.m_timerBullets = 0;
    this.init()
}
Application.subclass(TIEFighter, SimpleWorldActor);
TIEFighter.instance = null;
TIEFighter.TIME_PER_INITIAL_BULLETS = 200;
TIEFighter.COUNT_INITIAL_BULLETS = 7;
TIEFighter.TIME_PER_TINT = 80;
TIEFighter.COUNT_TINTS = 4;
TIEFighter.TIME_PER_EXPLOSION = 200;
TIEFighter.TIME_TOTAL_EXPLOSION = 3500;
TIEFighter.TIME_FOR_NEXT_HIT = 400;
TIEFighter.NO_BEHAVIOR = 0;
TIEFighter.BEHAVIOR_WITH_CANNON = 1;
TIEFighter.TOTAL_MOVEMENTS = 4;
TIEFighter.STATE_IDLE = 0;
TIEFighter.STATE_STAND = 100;
TIEFighter.STATE_MOVE = 101;
TIEFighter.STATE_BULLET_BURST = 102;
TIEFighter.STATE_MOVE_TO_CENTER = 103;
TIEFighter.STATE_HOMING = 104;
TIEFighter.STATE_VULNERABLE = 105;
TIEFighter.STATE_VULNERABLE_BURST = 106;
TIEFighter.VULNERABLE_EFFECT_DELAY = 1E3;
TIEFighter.ST_APPEAR = "st1";
TIEFighter.ST_STAND = "st2";
TIEFighter.ST_MOVE = "st3";
TIEFighter.ST_HIT = "st4";
TIEFighter.ST_ATTACK_BURST_PRE = "st5";
TIEFighter.ST_ATTACK_BURST = "st6";
TIEFighter.ST_ATTACK_BURST_END = "st7";
TIEFighter.ST_ATTACK_HOMING = "st8";
TIEFighter.ST_DIE = "st9";
TIEFighter.ST_VULNERABLE = "st10";
TIEFighter.DISTANCE_TO_APPEAR = 450;
TIEFighter.prototype.playMoveSound = function() {
    this.unitSounds.playState("st31")
};
TIEFighter.prototype.free = function() {
    this.m_object = null;
    this.m_effectChargeHomingLeft && (this.m_effectChargeHomingLeft.isAwaitingDelete = !0, this.m_effectChargeHomingLeft = null);
    this.m_effectChargeHomingRight && (this.m_effectChargeHomingRight.isAwaitingDelete = !0, this.m_effectChargeHomingRight = null);
    TIEFighter.instance = null;
    SimpleWorldActor.prototype.free.call(this)
};
TIEFighter.prototype.init = function() {
    this.m_character = new SimpleCharacter(0, 0, this.m_canvas);
    this.m_character.addState(TIEFighter.ST_STAND, this.skin + "_stand");
    this.m_character.addState(TIEFighter.ST_HIT, this.skin + "_hit");
    this.m_character.addState(TIEFighter.ST_MOVE, this.skin + "_intro1");
    this.m_character.addState(TIEFighter.ST_ATTACK_BURST_PRE, this.skin + "_attack1_start");
    this.m_character.addState(TIEFighter.ST_ATTACK_BURST, this.skin + "_attack1_stand");
    this.m_character.addState(TIEFighter.ST_ATTACK_BURST_END,
        this.skin + "_attack1_end");
    var a = [{
        caller: this,
        callback: this.loadHomingEffects,
        frame: 20
    }, {
        caller: this,
        callback: this.createHomingLeft,
        frame: 30
    }, {
        caller: this,
        callback: this.createHomingRight,
        frame: 59
    }];
    this.m_character.addState(TIEFighter.ST_ATTACK_HOMING, this.skin + "_attack2", a);
    a = [{
        caller: this,
        callback: this.doDieSound,
        frame: 10
    }];
    this.m_character.addState(TIEFighter.ST_DIE, this.skin + "_defeat", a);
    this.m_character.addState(TIEFighter.ST_VULNERABLE, this.skin + "_stand");
    a = [{
        caller: this,
        callback: this.doShake,
        frame: 35
    }];
    this.m_character.addState(TIEFighter.ST_APPEAR, this.skin + "_intro", a);
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    HudPlatform.instance.setEnergyBoss(1E3)
};
TIEFighter.prototype.doShake = function() {
    this.m_state !== TIEFighter.ST_APPEAR && this.unitSounds.playState(this.m_state);
    Global.game.onShake(10, 15, 300)
};
TIEFighter.prototype.doBigExplosion = function() {
    this.m_world.createContainerEffect("aniFxEnemyExplote", this.m_x, this.m_y, 3.5);
    Application.instance.playSound("SND_BOSS_OBSTACLE_DESTROY")
};
TIEFighter.prototype.updatePlayerCoop = function() {
    this.m_playerRef = this.m_world.player();
    HudPlatform.instance.stopTimingOut()
};
TIEFighter.prototype.createBulletToObject = function() {
    this.unitSounds.playState(TIEFighter.ST_ATTACK_BURST);
    var a = this.m_object.m_x - 855,
        b = this.m_object.m_y - 200,
        c = Math.sqrt(a * a + b * b),
        d = Common.randomInt(-8, 8) / 100,
        a = Math.acos(a / c) + d,
        b = this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_PLAYER, "aniFxBoss02Bullet01", 855, 200, 1200, 0 > b ? -a : a, 1.3 * Application.config.tie_fighter.speedBurstBullet, Application.config.tie_fighter.damageBurstBullet, "aniFxBoss03Hit");
    this.m_world.m_playerCanvas.addChild(b.clip)
};
TIEFighter.prototype.createBullet = function() {
    this.unitSounds.playState(TIEFighter.ST_ATTACK_BURST);
    var a = this.m_clip.mcWeaponR ? this.m_clip.mcWeaponR.position.x * this.scale : 0,
        b = this.m_clip.mcWeaponR ? this.m_clip.mcWeaponR.position.y * this.scale : 0,
        c = this.m_playerRef.m_x - (this.m_x + a),
        d = this.m_playerRef.m_y - 50 - (this.m_y + b),
        e = Math.sqrt(c * c + d * d),
        f = Common.randomInt(-5, 5) / 100,
        c = Math.acos(c / e) + f,
        d = this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_ENEMY_NO_CAMERA, "aniFxBoss02Bullet01", this.m_x + a, this.m_y +
            b, 1200, 0 > d ? -c : c, Application.config.tie_fighter.speedBurstBullet, Application.config.tie_fighter.damageBurstBullet, "aniFxBoss03Hit");
    this.m_world.m_playerCanvas.addChild(d.clip);
    this.m_world.createContainerEffect("aniFxBoss02Shoot", this.m_x + a, this.m_y + b, .4);
    a = this.m_clip.mcWeaponL ? this.m_clip.mcWeaponL.position.x * this.scale : 0;
    b = this.m_clip.mcWeaponL ? this.m_clip.mcWeaponL.position.y * this.scale : 0;
    c = this.m_playerRef.m_x - (this.m_x + a);
    d = this.m_playerRef.m_y - 50 - (this.m_y + b);
    e = Math.sqrt(c * c + d * d);
    f = Common.randomInt(-5,
        5) / 100;
    c = Math.acos(c / e) + f;
    c = 0 > d ? -c : c;
    d = this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_ENEMY_NO_CAMERA, "aniFxBoss02Bullet01", this.m_x + a, this.m_y + b, 1200, c, Application.config.tie_fighter.speedBurstBullet, Application.config.tie_fighter.damageBurstBullet, "aniFxBoss03Hit");
    this.m_world.m_playerCanvas.addChild(d.clip);
    this.m_world.createContainerEffect("aniFxBoss02Shoot", this.m_x + a, this.m_y + b, .4)
};
TIEFighter.prototype.loadHomingEffects = function() {
    this.m_effectChargeHomingLeft.setPause(!1);
    this.m_effectChargeHomingRight.setPause(!1)
};
TIEFighter.prototype.createHomingLeft = function() {
    this.unitSounds.playState(TIEFighter.ST_ATTACK_HOMING);
    var a = this.m_clip.mcWeaponL ? this.m_clip.mcWeaponL.position.x * this.scale : 0,
        b = this.m_clip.mcWeaponL ? this.m_clip.mcWeaponL.position.y * this.scale : 0,
        c = Common.randomInt(-6, 6) / 100,
        c = Application.config.tie_fighter.speedHoming + c,
        d = Common.randomInt(70, 110);
    this.m_world.m_actorManager.bulletManager.createAtdpMissile(this.m_x + a, this.m_y + b, Application.config.tie_fighter.damageHoming, Bullet.NAME_SKIN_BULLET_ENEMY,
        c, d, !1, Bullet.FX_IMPACT_GRENADE);
    this.m_world.createEffect("aniFxBoss01Shoot", this.m_x + a, this.m_y + b);
    this.m_effectChargeHomingLeft.setPause(!0)
};
TIEFighter.prototype.createHomingRight = function() {
    this.unitSounds.playState(TIEFighter.ST_ATTACK_HOMING);
    var a = this.m_clip.mcWeaponR ? this.m_clip.mcWeaponR.position.x * this.scale : 0,
        b = this.m_clip.mcWeaponR ? this.m_clip.mcWeaponR.position.y * this.scale : 0,
        c = Common.randomInt(-6, 6) / 100,
        c = Application.config.tie_fighter.speedHoming + c,
        d = Common.randomInt(70, 110);
    this.m_world.m_actorManager.bulletManager.createAtdpMissile(this.m_x + a, this.m_y + b, Application.config.tie_fighter.damageHoming, Bullet.NAME_SKIN_BULLET_ENEMY,
        c, d, !1, Bullet.FX_IMPACT_GRENADE);
    this.m_world.createEffect("aniFxBoss01Shoot", this.m_x + a, this.m_y + b);
    this.m_effectChargeHomingRight.setPause(!0)
};
TIEFighter.prototype.onEndAppear = function() {
    this.m_world.m_camera.m_lockState = Camera.LOCK_OFF
};
TIEFighter.prototype.onEndAnimation = function(a) {
    switch (a) {
        case TIEFighter.ST_APPEAR:
            this.setStateBoss(TIEFighter.STATE_STAND);
            this.m_world.m_camera.doBlendWithTarget(this.m_world.m_player, 60, -150, 10, !0, this, this.onEndAppear, null);
            break;
        case TIEFighter.ST_MOVE:
            this.m_moveAnimFinished = !0; - 900 > this.m_speed.x && -900 > this.m_speed.y && (this.m_bossState === TIEFighter.STATE_MOVE ? this.setStateBoss(TIEFighter.STATE_BULLET_BURST) : this.m_bossState === TIEFighter.STATE_MOVE_TO_CENTER && this.setStateBoss(TIEFighter.STATE_HOMING));
            break;
        case TIEFighter.ST_ATTACK_BURST_PRE:
            this.gotoState(TIEFighter.ST_ATTACK_BURST);
            this.m_timerBurst = Application.config.tie_fighter.timePerBurst;
            break;
        case TIEFighter.ST_ATTACK_BURST_END:
            this.m_currentIdMovement = this.m_currentIdMovement + 1 >= this.m_positionsMovement.length ? 0 : this.m_currentIdMovement + 1;
            (this.m_isFinishedMoves = 0 === this.m_currentIdMovement ? !0 : !1) ? this.setStateBoss(TIEFighter.STATE_MOVE_TO_CENTER): this.setStateBoss(TIEFighter.STATE_VULNERABLE_BURST);
            break;
        case TIEFighter.ST_ATTACK_HOMING:
            this.gotoState(TIEFighter.ST_STAND);
            break;
        case TIEFighter.ST_HIT:
            this.m_bossState === TIEFighter.STATE_VULNERABLE || this.m_bossState === TIEFighter.STATE_VULNERABLE_BURST ? this.gotoState(TIEFighter.ST_VULNERABLE) : this.gotoState(TIEFighter.ST_STAND);
            break;
        case TIEFighter.ST_DIE:
            this.m_world.m_camera.doBlendWithTarget(this.m_world.m_player, 60, -150, 5, !0, null, null, null), this.m_playerRef.onWin(!1)
    }
};
TIEFighter.prototype.onHit = function(a) {
    if (this.m_state === TIEFighter.ST_DIE || this.m_state === TIEFighter.ST_HIT) return !1;
    this.completeHit = !0;
    this.m_timerToHit = TIEFighter.TIME_FOR_NEXT_HIT;
    a = a > this.health ? this.health : a;
    this.health -= a;
    PlayerSettings.instance.updatePlayerBossDamage(a, this.m_initialHealth);
    Application.info("boss health: " + this.health);
    100 * this.health / this.m_initialHealth <= Application.config.tie_fighter.healthThreshold && this.m_behavior === TIEFighter.BEHAVIOR_WITH_CANNON && Application.info("half life");
    0 >= this.health ? (this.health = 0, this.gotoState(TIEFighter.ST_DIE), this.unitSounds.playState(TIEFighter.ST_DIE), this.m_timerPerExplosion = 10, this.m_timerTotalExplosion = TIEFighter.TIME_TOTAL_EXPLOSION, this.m_effectChargeHomingLeft.setPause(!0), this.m_effectChargeHomingRight.setPause(!0), HudPlatform.instance.setEnergyBoss(1)) : (a = Math.ceil(this.health / this.m_initialHealth * 999) + 1, HudPlatform.instance.setEnergyBoss(a), this.unitSounds.playState(TIEFighter.ST_HIT), this.m_bossState === HeadAtat.STATE_STAND && this.gotoState(HeadAtat.ST_HIT),
        this.onTint(16728642), this.m_timerTint = TIEFighter.TIME_PER_TINT, this.m_countTint = TIEFighter.COUNT_TINTS);
    return !0
};
TIEFighter.prototype.onTint = function(a) {
    this.m_clip.setTint(a);
    this.m_tint = a
};
TIEFighter.prototype.gotoStand = function() {
    this.gotoState(TIEFighter.ST_STAND)
};
TIEFighter.prototype.defeat = function() {
    this.health = 0;
    this.gotoState(TIEFighter.ST_DIE);
    HudPlatform.instance.setEnergyBoss(1);
    this.m_timerPerExplosion = 10;
    this.m_timerTotalExplosion = TIEFighter.TIME_TOTAL_EXPLOSION
};
TIEFighter.prototype.gotoState = function(a) {
    switch (a) {
        case TIEFighter.ST_DIE:
            this.m_world.m_playerCanvas.addChild(this.m_canvas), this.m_world.m_playerCanvas.removeChild(this.m_world.m_player.m_canvas), this.m_world.m_playerCanvas.addChild(this.m_world.m_player.m_canvas), this.m_world.m_objectsCanvas[0].removeChild(this.m_canvas)
    }
    SimpleWorldActor.prototype.gotoState.call(this, a);
    switch (a) {
        case TIEFighter.ST_MOVE:
            this.m_moveAnimFinished = !1;
            this.m_clip.loop = !1;
            break;
        case TIEFighter.ST_DIE:
            this.m_clip.loop = !1
    }
    if (0 < this.m_timerTint) this.onTint(this.m_tint)
};
TIEFighter.prototype.onEndLock = function() {
    this.m_timerBullets = TIEFighter.TIME_PER_INITIAL_BULLETS;
    this.m_countInitialBullets = TIEFighter.COUNT_INITIAL_BULLETS
};
TIEFighter.prototype.onObjectBreak = function() {
    this.m_canAppear = !0;
    this.gotoState(TIEFighter.ST_APPEAR)
};
TIEFighter.prototype.update = function(a) {
    if (this.m_state === TIEFighter.ST_DIE && !this.m_clip.m_stopped) {
        var b = this.m_clip.head;
        if (b) {
            var c = this.m_world.getFloorCollision(this.m_x, this.m_y).y;
            b.y + this.m_y + 100 >= c && (this.m_world.createContainerEffect("aniFxEnemyExplote", this.m_x, b.y + this.m_y, 3.5), Application.instance.playSound("SND_BOSS_OBSTACLE_DESTROY"), this.m_character.addState(TIEFighter.ST_DIE, "mcBoss4_explode"), this.m_state = -1, this.gotoState(TIEFighter.ST_DIE), this.m_clip.loop = !1, this.m_clip.gotoAndPlay(35),
                this.m_y = c - 50, Global.game.onShake(4, 10, 200))
        }
    }
    0 < this.m_timerBullets && (this.m_timerBullets -= a, 0 >= this.m_timerBullets && (this.createBulletToObject(), this.m_timerBullets = TIEFighter.TIME_PER_INITIAL_BULLETS, --this.m_countInitialBullets, 0 >= this.m_countInitialBullets && (this.m_timerBullets = this.m_countInitialBullets = 0)));
    if (this.m_canAppear) {
        0 < this.m_timerTint && (this.m_timerTint -= a, 0 >= this.m_timerTint && (--this.m_countTint, 0 < this.m_countTint ? (b = this.m_tint === (this.completeHit ? 16728642 : 16711937) ? 16777215 : this.completeHit ?
            16728642 : 16711937, this.m_clip.alpha = this.completeHit ? 1 : .7, this.onTint(b), this.m_timerTint = TIEFighter.TIME_PER_TINT) : (this.m_clip.alpha = 1, this.onTint(16777215), this.m_timerTint = 0)));
        SimpleWorldActor.prototype.update.call(this, a);
        0 < this.m_timerToHit && (this.m_timerToHit -= a, this.m_timerToHit = 0 > this.m_timerToHit ? 0 : this.m_timerToHit);
        if (0 >= this.m_timerToHit)
            if (this.m_world.m_player.clipSpecialAttack) {
                if (SDisplayObjectContainer.hitTestByBounds(this.m_clip, this.m_clip.getCollision(SimpleWorldActor.COLLISION),
                        this.m_world.m_player.clipSpecialAttack, this.m_world.m_player.clipSpecialAttack.getCollision(SimpleWorldActor.COLLISION_SPECIAL))) this.onHit(this.m_playerRef.data.specialDamagetoBoss)
            } else this.hitCollisions(SimpleWorldActor.COLLISION, this.m_world.m_player, SimpleWorldActor.COLLISION_ATTACK) && this.onHit(this.m_playerRef.data.regularDamageToBoss) && (this.m_clip.mcHead ? (b = this.m_clip.mcHead.position.x * this.scale, this.m_world.createEffect("aniFxPlayerHit", this.m_x + b, this.m_playerRef.m_y - 80)) : this.m_world.createEffect("aniFxPlayerHit",
                this.m_x, this.m_playerRef.m_y - 80), Global.game.onShake(4, 10, 200));
        this.m_state === TIEFighter.ST_ATTACK_HOMING && (this.m_effectChargeHomingLeft && (b = this.m_clip.mcWeaponL ? this.m_clip.mcWeaponL.position.x * this.scale : 0, c = this.m_clip.mcWeaponL ? this.m_clip.mcWeaponL.position.y * this.scale : 0, this.m_effectChargeHomingLeft.fix(this.m_x + b, this.m_y + c)), this.m_effectChargeHomingRight && (b = this.m_clip.mcWeaponR ? this.m_clip.mcWeaponR.position.x * this.scale : 0, c = this.m_clip.mcWeaponR ? this.m_clip.mcWeaponR.position.y * this.scale :
            0, this.m_effectChargeHomingRight.fix(this.m_x + b, this.m_y + c)));
        this.updateStates(a);
        this.checkPlayerNearby()
    } else 700 <= this.m_world.m_player.m_x && this.m_world.m_camera.m_lockState === Camera.LOCK_OFF && this.m_world.m_camera.doBlendWithPos(980, 640, this.m_world.m_camera.fixOffsetX, 0, 5, !0, this, this.onEndLock, null)
};
TIEFighter.prototype.updateStates = function(a) {
    if (this.m_state === TIEFighter.ST_DIE) {
        if (0 < this.m_timerTotalExplosion) {
            if (0 < this.m_timerPerExplosion && (this.m_timerPerExplosion -= a, 0 >= this.m_timerPerExplosion)) {
                this.m_timerPerExplosion = TIEFighter.TIME_PER_EXPLOSION;
                var b = Common.randomInt(this.m_x + 0 - 80, this.m_x + 0 + 80),
                    c = Common.randomInt(this.m_y + -100 - 80, this.m_y + -100 + 80),
                    d = Common.randomInt(50, 100);
                this.m_world.createContainerEffect("aniFxEnemyExplote", b, c, d / 100);
                Global.game.createExplotionShader(b - this.m_world.m_camera.m_x,
                    c - this.m_world.m_camera.m_y - 60, 8);
                Application.instance.playSound("SND_BOSS_OBSTACLE_DESTROY")
            }
            this.m_timerTotalExplosion -= a;
            0 >= this.m_timerTotalExplosion && (this.m_timerTotalExplosion = this.m_timerPerExplosion = 0)
        }
    } else switch (this.m_behavior) {
        case TIEFighter.BEHAVIOR_WITH_CANNON:
            switch (this.m_bossState) {
                case TIEFighter.STATE_STAND:
                    0 < this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && (Common.shuffleArray(this.m_positionsMovement), this.m_isFinishedMoves = !1, this.setStateBoss(TIEFighter.STATE_MOVE)));
                    break;
                case TIEFighter.STATE_MOVE:
                    if (-900 > this.m_speed.x && -900 > this.m_speed.y) break;
                    this.m_x += this.m_speed.x * a;
                    this.m_y += this.m_speed.y * a;
                    a = 0 <= this.m_speed.x && this.m_x >= this.m_positionsMovement[this.m_currentIdMovement].x;
                    b = 0 >= this.m_speed.x && this.m_x <= this.m_positionsMovement[this.m_currentIdMovement].x;
                    c = 0 <= this.m_speed.y && this.m_y >= this.m_positionsMovement[this.m_currentIdMovement].y;
                    d = 0 >= this.m_speed.y && this.m_y <= this.m_positionsMovement[this.m_currentIdMovement].y;
                    (a || b) && (c || d) && (this.m_x = this.m_positionsMovement[this.m_currentIdMovement].x,
                        this.m_y = this.m_positionsMovement[this.m_currentIdMovement].y, this.m_speed.x = -999, this.m_speed.y = -999, this.m_moveAnimFinished && this.setStateBoss(TIEFighter.STATE_BULLET_BURST));
                    break;
                case TIEFighter.STATE_BULLET_BURST:
                    this.m_state === TIEFighter.ST_ATTACK_BURST && 0 < this.m_timerBurst && (this.m_timerBurst -= a, 0 >= this.m_timerBurst && (this.createBullet(), this.m_timerBurst = Application.config.tie_fighter.timePerBurst, this.m_countBulletsBurst--, 0 >= this.m_countBulletsBurst && this.gotoState(TIEFighter.ST_ATTACK_BURST_END)));
                    break;
                case TIEFighter.STATE_MOVE_TO_CENTER:
                    if (-900 > this.m_speed.x && -900 > this.m_speed.y) break;
                    this.m_x += this.m_speed.x * a;
                    this.m_y += this.m_speed.y * a;
                    a = 0 <= this.m_speed.x && this.m_x >= this.m_initX;
                    b = 0 >= this.m_speed.x && this.m_x <= this.m_initX;
                    c = 0 <= this.m_speed.y && this.m_y >= this.m_initY;
                    d = 0 >= this.m_speed.y && this.m_y <= this.m_initY;
                    (a || b) && (c || d) && (this.m_x = this.m_initX, this.m_y = this.m_initY, this.m_speed.x = -999, this.m_speed.y = -999, this.m_moveAnimFinished && this.setStateBoss(TIEFighter.STATE_HOMING));
                    break;
                case TIEFighter.STATE_HOMING:
                    0 <
                        this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(TIEFighter.STATE_VULNERABLE));
                    break;
                case TIEFighter.STATE_VULNERABLE:
                    0 < this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(TIEFighter.STATE_STAND));
                    this.doVulnerableEffect(a);
                    break;
                case TIEFighter.STATE_VULNERABLE_BURST:
                    0 < this.m_timerToNextState && (this.m_timerToNextState -= a, 0 >= this.m_timerToNextState && this.setStateBoss(TIEFighter.STATE_MOVE)), this.doVulnerableEffect(a)
            }
    }
};
TIEFighter.prototype.doVulnerableEffect = function(a) {
    this.effectTimer += a;
    this.effectTimer > TIEFighter.VULNERABLE_EFFECT_DELAY && (this.effectTimer = 0, (a = this.m_clip.getCollision("mcCollision")) && this.m_world.createEffect("aniFxBoss03Damage", this.m_x + a.x + .5 * a.w, this.m_y + a.y + .5 * a.w))
};
TIEFighter.prototype.checkPlayerNearby = function() {
    var a = this.m_x - this.m_playerRef.m_x,
        b = this.m_y - (this.m_playerRef.m_y - 100);
    200 > (0 > a ? -a : a) && 100 > (0 > b ? -b : b) && (PlatformGame.playerNearEnemy = !0)
};
TIEFighter.prototype.setStateBoss = function(a) {
    this.m_bossState = a;
    switch (a) {
        case TIEFighter.STATE_STAND:
            this.m_timerToNextState = Application.config.tie_fighter.timeStateStand;
            this.gotoState(TIEFighter.ST_STAND);
            break;
        case TIEFighter.STATE_MOVE:
            var b = this.m_positionsMovement[this.m_currentIdMovement].x - this.m_x;
            a = this.m_positionsMovement[this.m_currentIdMovement].y - this.m_y;
            var c = Math.sqrt(b * b + a * a),
                b = Math.acos(b / c);
            this.m_speed.x = Math.cos(b) * this.m_speedMovement;
            this.m_speed.y = Math.sin(0 > a ? -b : b) * this.m_speedMovement;
            a = this.m_positionsMovement[this.m_currentIdMovement].y;
            1620 === this.m_positionsMovement[this.m_currentIdMovement].x && 256 === a ? (this.m_character.addState(TIEFighter.ST_MOVE, this.skin + "_intro3"), this.unitSounds.playState("st33")) : (a = Common.randomInt(1, 2), 1 === a ? this.m_character.addState(TIEFighter.ST_MOVE, this.skin + "_intro1", [{
                caller: this,
                callback: this.playMoveSound,
                frame: 25
            }]) : (this.m_character.addState(TIEFighter.ST_MOVE, this.skin + "_intro" + a), this.unitSounds.playState("st3" + a)));
            this.gotoState(TIEFighter.ST_MOVE);
            break;
        case TIEFighter.STATE_BULLET_BURST:
            this.gotoState(TIEFighter.ST_ATTACK_BURST_PRE);
            this.m_countBulletsBurst = Application.config.tie_fighter.numberOfBullets;
            break;
        case TIEFighter.STATE_MOVE_TO_CENTER:
            b = this.m_initX - this.m_x;
            a = this.m_initY - this.m_y;
            c = Math.sqrt(b * b + a * a);
            b = Math.acos(b / c);
            this.m_speed.x = Math.cos(b) * this.m_speedMovement;
            b = 0 > a ? -b : b;
            this.m_speed.y = Math.sin(b) * this.m_speedMovement;
            a = 0 <= this.m_speed.x && 0 >= this.m_speed.y ? Common.randomInt(1, 3) : Common.randomInt(1, 2);
            1 === a ? this.m_character.addState(TIEFighter.ST_MOVE,
                this.skin + "_intro1", [{
                    caller: this,
                    callback: this.playMoveSound,
                    frame: 25
                }]) : (this.m_character.addState(TIEFighter.ST_MOVE, this.skin + "_intro" + a), this.unitSounds.playState("st3" + a));
            this.gotoState(TIEFighter.ST_MOVE);
            break;
        case TIEFighter.STATE_HOMING:
            this.gotoState(TIEFighter.ST_ATTACK_HOMING);
            this.m_timerToNextState = Application.config.tie_fighter.timeHoming;
            break;
        case TIEFighter.STATE_VULNERABLE:
            this.gotoState(TIEFighter.ST_VULNERABLE);
            this.m_timerToNextState = Application.config.tie_fighter.timeVulnerable;
            break;
        case TIEFighter.STATE_VULNERABLE_BURST:
            this.gotoState(TIEFighter.ST_VULNERABLE), this.m_timerToNextState = Application.config.tie_fighter.timeVulnerableAfterBurst
    }
};
TIEFighter.prototype.doDieSound = function() {
    this.unitSounds.playState(TIEFighter.ST_DIE)
};

function ObjectTIEFighter(a, b, c, d, e) {
    SimpleWorldActor.call(this, a, b, c, d);
    ObjectTIEFighter.instance = this;
    this.skin = "mcBoss4_structure";
    this.isEnemy = !0;
    this.m_tieFighterRef = e;
    this.init()
}
Application.subclass(ObjectTIEFighter, SimpleWorldActor);
ObjectTIEFighter.ST_STAND = "st1";
ObjectTIEFighter.ST_BREAK = "st2";
ObjectTIEFighter.prototype.free = function() {
    this.m_tieFighterRef = ObjectTIEFighter.instance = null;
    SimpleWorldActor.prototype.free.call(this)
};
ObjectTIEFighter.prototype.init = function() {
    this.m_character = new SimpleCharacter(0, 0, this.m_canvas);
    this.m_character.addState(ObjectTIEFighter.ST_STAND, this.skin + "_stand");
    this.m_character.addState(ObjectTIEFighter.ST_BREAK, this.skin + "_break");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.gotoState(ObjectTIEFighter.ST_STAND)
};
ObjectTIEFighter.prototype.doShake = function() {
    Global.game.onShake(6, 9, 150)
};
ObjectTIEFighter.prototype.onEndAnimation = function(a) {
    switch (a) {
        case ObjectTIEFighter.ST_BREAK:
            this.m_tieFighterRef.onObjectBreak(), this.isAwaitingDelete = !0
    }
};
ObjectTIEFighter.prototype.onHit = function(a) {
    this.doBreak();
    this.m_world.createContainerEffect("aniFxEnemyExplote", this.m_x, this.m_y - 250, 1.5)
};
ObjectTIEFighter.prototype.doBreak = function() {
    this.gotoState(ObjectTIEFighter.ST_BREAK)
};

function SentinelDroid(a, b, c, d) {
    Stormtrooper.call(this, a, b, c, "Darktrooper", d);
    this.isJumpWarning = this.isResting = this.onAttackCoolDown = !1;
    this.jumpState = SentinelDroid.GROUNDED;
    this.hoverGoal = {
        x: 0,
        y: 0
    };
    this.attackType = "";
    this.vY = this.shootingAngle = 0;
    this.m_move = null;
    this.navFloor = new NavFloor(b, this, this.m_x, this.m_world.getFloorCollision(this.m_x, this.m_y).y, d ? 500 : 800, 600);
    2 > this.navFloor.points.length && (this.navFloor.points[this.m_limits.left()] = this.m_y, this.navFloor.points[this.m_limits.right()] =
        this.m_y, this.navFloor.setMinMax());
    this.m_state = SentinelDroid.ST_HOLD;
    this.m_rangeDetection = 0 < this.config.fireRange ? this.config.fireRange : 600;
    this.shadowClip = null;
    this.shadowClip = PoolClips.instance.getClip("fxShadow_zeb");
    this.shadowClip.gotoAndStop(1);
    this.shadowClip.visible = !1;
    a.addChild(this.shadowClip);
    this.xJumpDistance = 100;
    this.isConquerGenerated && (this.gotoState(Stormtrooper.ST_APPEAR), this.setLookAtLeft(.5 < Math.random()))
}
Application.subclass(SentinelDroid, Stormtrooper);
SentinelDroid.ST_JUMPUP = "st_202";
SentinelDroid.ST_JUMPAIR = "st_209";
SentinelDroid.ST_JUMPDOWN = "st_210";
SentinelDroid.ST_ATTACKBLASTER = "st_203";
SentinelDroid.ST_ATTACKMISSILES = "st_204";
SentinelDroid.ST_FALL = "st_205";
SentinelDroid.ST_HOVERIDLE = "st_206";
SentinelDroid.ST_CHARGINGMISSILE = "st_207";
SentinelDroid.ST_EXPELHIT = "st_208";
SentinelDroid.ST_HOLD = "holding";
SentinelDroid.USEBLASTER = "blaster";
SentinelDroid.USEMISSILES = "missiles";
SentinelDroid.GROUNDED = "grounded";
SentinelDroid.JUMP_UP = "jump_up";
SentinelDroid.JUMP_DOWN = "jump_down";
SentinelDroid.JUMP_IN_AIR = "jump_in_air";
SentinelDroid.ATTACK_DELAY = 500;
SentinelDroid.NAV_POINT_INTERVAL = 15;
SentinelDroid.HOVER_HEIGHT = 25;
SentinelDroid.HOVER_BACK = 80;
SentinelDroid.GRAVITY = .03;
SentinelDroid.ANGLE_MARGIN_ERROR = .0785;
SentinelDroid.prototype.updateShadow = function(a) {
    var b = !1;
    if (this.m_state === SentinelDroid.ST_JUMPAIR || this.m_state === SentinelDroid.ST_JUMPUP) {
        var c = this.m_world.getFloorCollision(this.m_x, this.m_y);
        c && (b = !0, this.shadowClip.position.x = c.x - this.m_world.m_camera.m_x, this.shadowClip.position.y = c.y - this.m_world.m_camera.m_y, this.shadowClip.scale.x = this.shadowClip.scale.y = SMath.setRange(1 - (c.y - this.m_y) / 300, 1, .5), this.shadowClip.alpha = SMath.setRange(1 - (c.y - this.m_y) / 300, 1, .25), this.shadowClip.update(a))
    }
    this.shadowClip.visible =
        b
};
SentinelDroid.prototype.getFloorPos = function(a, b) {
    for (var c = 0, d = b, e = WorldCollisionLayer.CELL_EMPTY; 800 > c && e === WorldCollisionLayer.CELL_EMPTY;) d += 10, e = this.m_world.getCellInPosition(a, d), c += 10;
    return 800 <= c ? null : {
        x: a,
        y: 24 * ~~(d / 24)
    }
};
SentinelDroid.prototype.init = function() {
    this.config = this.getConfig(this.classname);
    this.m_health = this.config.health;
    this.skin = "chr_dark";
    this.m_character = new SimpleCharacter(this.m_npc.x, this.m_npc.y, this.m_canvas);
    this.m_character.addState(Stormtrooper.ST_STAND, this.skin + "_stand");
    this.m_character.addState(Stormtrooper.ST_PATROL, this.skin + "_walk");
    this.m_character.addState(Stormtrooper.ST_WARNING, this.skin + "_warning");
    this.m_character.addState(SentinelDroid.ST_CHARGINGMISSILE, this.skin + "_charging");
    this.m_character.addState(SentinelDroid.ST_EXPELHIT, this.skin + "_onhit");
    this.m_character.addState(BaseEnemy.ST_HIT, this.skin + "_onhit");
    this.m_character.addState(BaseEnemy.ST_DIE, this.skin + "_defeat");
    this.m_character.addState(Stormtrooper.ST_APPEAR, this.skin + "_appear", [{
        caller: this,
        callback: this.onAppear,
        frame: 15
    }]);
    this.m_character.addState(SentinelDroid.ST_JUMPUP, this.skin + "_jumpUp", [{
        caller: this,
        callback: this.doJump,
        frame: 4
    }]);
    this.m_character.addState(SentinelDroid.ST_JUMPAIR, this.skin + "_jump");
    this.m_character.addState(SentinelDroid.ST_JUMPDOWN, this.skin + "_jumpGround");
    this.m_character.addState(SentinelDroid.ST_FALL, this.skin + "_jumpGround");
    this.m_character.addState(SentinelDroid.ST_ATTACKBLASTER, this.skin + "_attackBlaster", [{
        caller: this,
        callback: this.createBullet,
        frame: 4
    }]);
    this.m_character.onEndAnimation(this, this.onEndAnimation)
};
SentinelDroid.prototype.update = function(a) {
    this.m_move ? (this.m_move.update(a), this.m_move.m_finish ? this.m_move = null : (this.m_x = this.m_move.getX(), this.m_y = this.m_move.getY())) : (this.currentDetection = this.getDetectionType(), this.updateStates(a));
    this.m_clip && (this.updateShadow(a), BaseEnemy.prototype.update.call(this, a))
};
SentinelDroid.prototype.isPlayerInAppearRange = function() {
    return (new Vector2D(this.m_x - this.m_world.player().getX(), this.m_y - this.m_world.player().getY())).length() <= .5 * this.m_rangeDetection ? !0 : !1
};
SentinelDroid.prototype.doJump = function() {
    if (!this.m_move) {
        this.jumpState = SentinelDroid.JUMP_UP;
        var a = this.navFloor.jumpDirection === NavFloor.JUMP_UP ? .5 * this.xJumpDistance : this.xJumpDistance;
        this.navFloor.updateCurrentNavKey(this.m_x);
        a = this.navFloor.getClosestNavKey(this.m_x + (this.m_toLeft ? -a : a));
        this.m_move = new ParametricParabolicMovement(this.m_x, this.m_y, a, this.navFloor.points[a]);
        this.m_move.onComplete(this, this.onCompleteRegularJump)
    }
};
SentinelDroid.prototype.onCompleteRegularJump = function() {
    this.gotoState(SentinelDroid.ST_JUMPDOWN);
    this.navFloor.updateCurrentNavKey(this.m_x)
};
SentinelDroid.prototype.doPatrol = function(a) {
    this.navFloor.shouldJump(this.m_x, this.m_y, this.m_toLeft, 200) ? this.gotoState(SentinelDroid.ST_JUMPUP) : (this.navFloor.updateCurrentNavKey(this.m_x), this.m_x - 25 <= this.navFloor.minNavPoint && this.setLookAtLeft(!1), this.m_x + 25 >= this.navFloor.maxNavPoint && this.setLookAtLeft(!0));
    this.m_x += this.m_toLeft ? -this.config.speed * a : this.config.speed * a
};
SentinelDroid.prototype.onAppear = function() {
    Global.game.onShake(2, 10, 300)
};
SentinelDroid.prototype.onEndAnimation = function(a) {
    this.currentDetection = this.getDetectionType();
    switch (a) {
        case Stormtrooper.ST_APPEAR:
            this.setState(Stormtrooper.ST_STAND, this.m_toLeft);
            break;
        case BaseEnemy.ST_HIT:
        case SentinelDroid.ST_EXPELHIT:
            this.m_isInvulnerable = !1;
            this.gotoState(Stormtrooper.ST_STAND);
            break;
        case SentinelDroid.ST_ATTACKMISSILES:
            this.gotoState(Stormtrooper.ST_STAND);
            this.m_bulletsInARowCount += 1;
            this.m_bulletsInARowCount >= this.config.bulletsInARow ? (this.isResting = !1, this.onAttackCoolDown = !0, this.createTimer(4 * this.config.shootFreq, this.resetAttack), this.m_bulletsInARowCount = 0) : (this.isResting = !0, this.createTimer(4 * this.config.shootFreq, this.gotoMissileState));
            break;
        case SentinelDroid.ST_ATTACKBLASTER:
            this.m_bulletsInARowCount += 1;
            this.m_bulletsInARowCount >= this.config.bulletsInARow && (this.onAttackCoolDown = !0, this.createTimer(this.config.shootFreq, this.resetAttack), this.m_bulletsInARowCount = 0, this.gotoState(Stormtrooper.ST_STAND));
            break;
        case BaseEnemy.ST_DIE:
            this.wave && (this.wave.notifyKill(),
                this.wave = null);
            this.m_world.m_player.sentinelDroidsKilled++;
            2 <= this.m_world.m_player.sentinelDroidsKilled && (this.m_world.m_player.sentinelDroidsKilled = 0, this.m_world.m_actorManager.addDrop(this.m_x, this.m_y, 7));
            this.isAwaitingDelete = !0;
            this.m_character.clip.stop();
            this.shadowClip && this.m_canvas.removeChild(this.shadowClip);
            break;
        case SentinelDroid.ST_CHARGINGMISSILE:
            this.m_character.addState(SentinelDroid.ST_ATTACKMISSILES, this.skin + "_attackMissiles", [{
                caller: this,
                callback: this.createMissile,
                frame: 4
            }]);
            this.gotoState(SentinelDroid.ST_ATTACKMISSILES);
            break;
        case Stormtrooper.ST_WARNING:
            this.isJumpWarning ? (this.isJumpWarning = !1, this.jumpToPlayer()) : this.currentDetection === Stormtrooper.PLAYER_ON_FIRERANGE ? this.gotoState(SentinelDroid.ST_ATTACKBLASTER) : this.gotoState(Stormtrooper.ST_STAND);
            break;
        case SentinelDroid.ST_JUMPUP:
            this.gotoState(SentinelDroid.ST_JUMPAIR);
            break;
        case SentinelDroid.ST_JUMPDOWN:
            this.currentDetection === Stormtrooper.PLAYER_ON_FIRERANGE ? this.gotoState(SentinelDroid.ST_CHARGINGMISSILE) :
                this.gotoState(Stormtrooper.ST_PATROL)
    }
};
SentinelDroid.prototype.gotoMissileState = function() {
    this.gotoState(SentinelDroid.ST_ATTACKMISSILES)
};
SentinelDroid.prototype.forceAppear = function() {
    BaseEnemy.prototype.setState.call(this, Stormtrooper.ST_APPEAR, this.m_world.m_player.m_x < this.m_x)
};
SentinelDroid.prototype.updateStates = function(a) {
    switch (this.m_state) {
        case SentinelDroid.ST_HOLD:
            this.isPlayerInAppearRange() && this.forceAppear();
            break;
        case Stormtrooper.ST_STAND:
            this.isResting || (this.createTimer(this.config.timeRest, this.setPatrol), this.isResting = !0);
            break;
        case Stormtrooper.ST_PATROL:
            this.doPatrol(a);
            this.currentDetection === Stormtrooper.PLAYER_ON_FIRERANGE && (this.isJumpOnCooldown || (this.isJumpWarning = !0), this.setState(Stormtrooper.ST_WARNING, this.m_world.m_player.m_x < this.m_x));
            break;
        case SentinelDroid.ST_HOVERIDLE:
            this.currentDetection === Stormtrooper.PLAYER_ON_SIGHT ? (this.isJumpWarning = !0, this.setState(Stormtrooper.ST_WARNING, this.m_world.m_player.m_x < this.m_x)) : this.gotoState(Stormtrooper.ST_STAND);
            break;
        case SentinelDroid.ST_FALL:
            5 >= this.navFloor.getCurrentNavYPos() - this.m_y ? (this.m_y = this.navFloor.getCurrentNavYPos(), Global.game.onShake(2, 10, 300), this.gotoState(Stormtrooper.ST_STAND)) : (this.m_y += this.vY, this.vY += SentinelDroid.GRAVITY * a)
    }
};
SentinelDroid.prototype.jumpToPlayer = function() {
    if (!this.m_move && !this.isJumpOnCooldown) {
        var a = this.navFloor.getClosestNavKey(this.m_world.m_player.m_x),
            b = this.m_x > a ? this.m_x - a : a - this.m_x;
        this.navFloor.updateCurrentNavKey(a);
        var c = this.navFloor.getCurrentNavYPos(),
            d = this.m_y > c ? this.m_y - c : c - this.m_y;
        100 < b && 200 > d ? (this.m_move = new ParametricParabolicMovement(this.m_x, this.m_y, a, c, SentinelDroid.GRAVITY, .1), this.m_move.onComplete(this, this.onCompleteJumpToPlayer), this.isJumpOnCooldown = !0, this.createTimer(20 *
            this.config.timeRest, this.resetJump), this.setState(SentinelDroid.ST_JUMPUP, a < this.m_x), this.m_state = SentinelDroid.ST_HOVERIDLE) : this.getDetectionType() === Stormtrooper.PLAYER_ON_FIRERANGE ? (this.gotoState(SentinelDroid.ST_ATTACKBLASTER), this.attackType = SentinelDroid.USEBLASTER, this.startAttack()) : this.gotoState(Stormtrooper.ST_PATROL)
    }
};
SentinelDroid.prototype.onCompleteJumpToPlayer = function() {
    this.m_state != BaseEnemy.ST_HIT && BaseEnemy.ST_DIE && ((this.setLookAtLeft(this.m_world.m_player.m_x < this.m_x), Global.game.onShake(2, 10, 300), this.onCompleteRegularJump(), !this.m_world.m_actorManager.bulletManager.missilesAvailable() || this.currentDetection !== Stormtrooper.PLAYER_ON_SIGHT && this.currentDetection !== Stormtrooper.PLAYER_ON_FIRERANGE) ? this.currentDetection === Stormtrooper.PLAYER_ON_FIRERANGE && (this.attackType = SentinelDroid.USEBLASTER, this.startAttack()) :
        (this.attackType = SentinelDroid.USEMISSILES, this.startAttack()))
};
SentinelDroid.prototype.startAttack = function() {
    var a = this.m_world.m_player.m_x > this.m_x ? this.m_world.m_player.m_x - this.m_x : this.m_x - this.m_world.m_player.m_x,
        b = this.m_world.m_player.m_y - 80 - this.m_y;
    this.shootingAngle = Math.acos(a / Math.sqrt(a * a + b * b));
    this.shootingAngle = 0 > b ? -this.shootingAngle : this.shootingAngle;
    switch (this.attackType) {
        case SentinelDroid.USEBLASTER:
            (this.shootingAngle >= -SentinelDroid.ANGLE_MARGIN_ERROR && this.shootingAngle <= SentinelDroid.ANGLE_MARGIN_ERROR || this.shootingAngle <= SentinelDroid.ANGLE_MARGIN_ERROR -
                3.14 && this.shootingAngle >= 3.14 - SentinelDroid.ANGLE_MARGIN_ERROR) && this.gotoState(Stormtrooper.ST_STAND);
            break;
        case SentinelDroid.USEMISSILES:
            this.shootingAngle = this.m_toLeft ? 3.14 - this.shootingAngle : this.shootingAngle
    }
};
SentinelDroid.prototype.onExpel = function() {
    PoolClips.instance.releaseClip(this.shadowClip);
    this.m_world.m_player.sentinelDroidsKilled++;
    2 <= this.m_world.m_player.sentinelDroidsKilled && (this.m_world.m_player.sentinelDroidsKilled = 0, this.m_world.m_actorManager.addDrop(this.m_x, this.m_y, 7));
    this.m_world.createEffect("aniFxEnemyExplote", this.m_x, this.m_y - 120);
    Stormtrooper.prototype.onExpel.call(this)
};
SentinelDroid.prototype.onHit = function(a) {
    return Stormtrooper.prototype.onHit.call(this, a) ? (this.unitSounds.playState(this.m_state), this.m_state === BaseEnemy.ST_DIE && (this.m_world.createEffect("aniFxEnemyExplote", this.m_x, this.m_y - 120), this.m_world.timerManager.removeMyTimers(this)), !0) : !1
};
SentinelDroid.prototype.getCollDamage = function() {
    return this.config.bulletDamage
};
SentinelDroid.prototype.createBullet = function() {
    this.unitSounds && this.unitSounds.playState(SentinelDroid.ST_ATTACKBLASTER);
    this.setLookAtLeft(this.m_world.m_player.m_x < this.m_x);
    var a = this.getBarrelPos(),
        b = this.m_toLeft ? 3.14 : 0,
        b = b + (.5 < Math.random() ? .05 * Math.random() : .05 * -Math.random());
    this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_ENEMY, Bullet.NAME_SKIN_BULLET_ENEMY, a.x, a.y, this.config.bulletMaxDistance, b, this.config.bulletSpeed, this.config.bulletDamage, Bullet.FX_IMPACT_LASER_ENEMY);
    this.m_world.createEffect("aniFxShootEnemy", a.x, a.y)
};
SentinelDroid.prototype.createMissile = function() {
    this.unitSounds && this.unitSounds.playState(SentinelDroid.ST_ATTACKMISSILES);
    this.setLookAtLeft(this.m_world.m_player.m_x < this.m_x);
    var a = this.getBarrelPos(),
        b = -1.57 + (this.m_toLeft ? .314 * -Math.random() : .314 * Math.random());
    this.m_world.m_actorManager.bulletManager.createMissile(a.x, a.y, this.m_world.m_player.m_x, this.navFloor.points[this.navFloor.getClosestNavKey(this.m_world.m_player.m_x)], this.config.bulletDamage, Bullet.NAME_SKIN_BULLET_ENEMY, 15 * this.config.bulletSpeed, !1, b, Bullet.FX_IMPACT_GRENADE)
};
SentinelDroid.prototype.createTimer = function(a, b) {
    this.m_world.timerManager.createTimer(a, this, b)
};
SentinelDroid.prototype.getBarrelPos = function() {
    var a = this.m_clip.barrelPos;
    return {
        x: this.m_x + (this.m_toLeft ? -1 : 1) * a.x,
        y: this.m_y + a.y
    }
};
SentinelDroid.prototype.free = function() {
    this.navFloor.free();
    Stormtrooper.prototype.free.call(this)
};
SentinelDroid.prototype.setPatrol = function() {
    this.gotoState(Stormtrooper.ST_PATROL);
    this.navFloor.updateCurrentNavKey(this.m_x);
    this.resetAttack();
    this.isResting = !1
};
SentinelDroid.prototype.onIdle = function(a) {
    a && (this.m_x = this.navFloor.getClosestNavKey(this.m_x), this.m_y = this.navFloor.getY(this.m_x), this.m_move && this.m_move.m_endCallback && this.m_move.m_endCallback.call(this.m_move.caller, this.m_move));
    Stormtrooper.prototype.onIdle.call(this, a)
};
SentinelDroid.prototype.resetAttack = function() {
    this.onAttackCoolDown = !1
};
SentinelDroid.prototype.resetJump = function() {
    this.isJumpResetting = this.isJumpOnCooldown = !1
};
SentinelDroid.prototype.canWalkBehindAfterAttack = function() {
    return !1
};
SentinelDroid.prototype.getDetectionType = function() {
    if (!this.m_world.m_player.isPlaying || this.m_world.m_player.m_state === Player.ST_PLAYER_CELEBRATE || this.m_world.m_player.waitingForCelebrate || this.m_world.m_player.disablePlayer) return Stormtrooper.PLAYER_OUT_OF_SIGHT;
    if (this.m_world.m_player.m_x + .5 * this.config.fireRange >= this.navFloor.minNavPoint && this.m_world.m_player.m_x - .5 * this.config.fireRange <= this.navFloor.maxNavPoint) {
        var a = this.m_world.m_player.m_y - 60 - (this.m_y - 100),
            a = 0 > a ? -a : a,
            b = this.m_world.m_player.m_x -
            this.m_x;
        if ((0 > b ? -b : b) <= .5 * this.config.fireRange) {
            if (150 >= a) return Stormtrooper.PLAYER_ON_FIRERANGE;
            if (a <= .5 * this.config.fireRange) return Stormtrooper.PLAYER_ON_SIGHT
        }
    }
    return -1
};

function BaseHazard(a, b, c) {
    SimpleWorldActor.call(this, a, b, c.x, c.y);
    this.m_npc = c;
    this.currentTimer = this.currentWeaponClip = this.config = null;
    this.functions = [];
    this.m_yRangeTrigger = this.m_xRangeTrigger = this.lastFrame = 0;
    this.m_toLeft = !1;
    this.isEnemy = !0;
    this.className = "hazard";
    this.m_character = new SimpleCharacter(c.x, c.y, a);
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.init()
}
Application.subclass(BaseHazard, SimpleWorldActor);
BaseHazard.ST_IDLE = "st_201";
BaseHazard.ST_DIE = "st_202";
BaseHazard.ST_BASEDIESTAND = "st_203";
BaseHazard.prototype.init = function() {};
BaseHazard.prototype.getConfig = function(a) {
    for (var b = Application.config.hazards, c = 0; c < b.length; c++)
        if (b[c].type === a) return b[c]
};
BaseHazard.prototype.free = function() {
    this.m_npc = this.functions = this.currentWeaponClip = this.m_character = null;
    SimpleWorldActor.prototype.free.call(this)
};
BaseHazard.prototype.update = function(a) {
    this.m_world.m_player.isPlaying && this.updateStates(a);
    SimpleWorldActor.prototype.update.call(this, a)
};
BaseHazard.prototype.updateStates = function(a) {};
BaseHazard.prototype.onEndAnimation = function(a) {};
BaseHazard.prototype.gotoState = function(a) {
    SimpleWorldActor.prototype.gotoState.call(this, a)
};
BaseHazard.prototype.isPlayerInRange = function(a) {
    var b = this.m_world.m_player.m_x - this.m_x;
    if (a && this.m_world.m_player.m_y - (a ? 60 : 120) <= this.m_y || !a && this.m_world.m_player.m_y - (a ? 60 : 120) >= this.m_y)
        if (a = this.m_y - (this.m_world.m_player.m_y - (a ? 0 : 120)), (0 > b ? -b : b) <= this.m_xRangeTrigger && (0 > a ? -a : a) <= this.m_yRangeTrigger) return !0;
    return !1
};
BaseHazard.prototype.createTimer = function(a, b, c, d) {
    this.currentTimer = this.m_world.timerManager.createTimer(a, b, c, d)
};
BaseHazard.prototype.removeThisTimer = function(a) {
    a && this.m_world.timerManager.removeThisTimer(a)
};
BaseHazard.prototype.onExpel = function() {};
BaseHazard.prototype.onHit = function(a) {
    if (this.m_world.m_player.clipSpecialAttack) this.onSpecialHit();
    return !0
};
BaseHazard.prototype.onSpecialHit = function() {};
BaseHazard.prototype.lerp = function(a, b, c, d) {
    return d / 1E3 * c * (b - a)
};
BaseHazard.prototype.abs = function(a) {
    return 0 > a ? -a : a
};
BaseHazard.prototype.addCustomListener = function(a, b) {
    for (var c = 0; c < b.length; c++) this.functions[a + "_" + b[c].frame] = b[c]
};
BaseHazard.prototype.updateCustomListeners = function(a) {
    this.lastFrame !== a.currentFrame && (this.lastFrame = a.currentFrame, this.functions[this.m_state + "_" + a.currentFrame] && (a = this.functions[this.m_state + "_" + a.currentFrame], a.callback.call(a.caller)))
};
BaseHazard.prototype.setState = function(a, b) {
    b = "undefined" !== typeof b ? b : !1;
    this.gotoState(a);
    this.m_toLeft = b;
    this.setFlipX(this.m_toLeft)
};
BaseHazard.prototype.checkForSpecial = function() {
    if (this.m_world.m_player.clipSpecialAttack && SDisplayObjectContainer.hitTestByBounds(this.m_clip, this.m_clip.getCollision(SimpleWorldActor.COLLISION), this.m_world.m_player.clipSpecialAttack, this.m_world.m_player.clipSpecialAttack.getCollision(SimpleWorldActor.COLLISION_SPECIAL))) this.onSpecialHit()
};

function Landmine(a, b, c) {
    BaseHazard.call(this, a, b, c);
    this.config = this.getConfig("Landmine");
    this.stepOnTrigger = c.stepOnTrigger;
    this.clipAnimationMultiplier = 1;
    this.currentTimer = null;
    this.unitSounds = new UnitSounds("Landmine");
    this.m_character.addState(BaseHazard.ST_IDLE, "landmine_idle");
    this.m_character.addState(Landmine.ST_WARNING, "landmine_warning");
    this.m_character.addState(Landmine.ST_ARMED, "landmine_armed");
    this.m_character.addState(Landmine.ST_DIE, "landmine_explode");
    this.gotoState(BaseHazard.ST_IDLE);
    this.m_xRangeTrigger = this.m_clip.getCollision("mcCollision").w / 2;
    this.m_yRangeTrigger = this.m_clip.getCollision("mcCollision").h / 2
}
Application.subclass(Landmine, BaseHazard);
Landmine.ST_ARMED = "st_102";
Landmine.ST_DIE = "st_103";
Landmine.ST_WARNING = "st_104";
Landmine.prototype.update = function(a) {
    BaseHazard.prototype.update.call(this, a);
    this.m_world.m_player.isPlaying && this.checkForPlayer();
    this.checkForSpecial()
};
Landmine.prototype.onSpecialHit = function() {
    this.forceExplode()
};
Landmine.prototype.onIdle = function(a) {
    this.m_state === BaseHazard.ST_IDLE && BaseHazard.prototype.onIdle.call(this, a)
};
Landmine.prototype.onEndAnimation = function(a) {
    BaseHazard.prototype.onEndAnimation.call(this, a);
    switch (a) {
        case Landmine.ST_WARNING:
            this.createTimer(this.config.timeBeforeExplode, this, this.explode);
            this.gotoState(Landmine.ST_ARMED);
            break;
        case Landmine.ST_DIE:
            this.isAwaitingDelete = !0
    }
};
Landmine.prototype.explodeOnCollision = function() {
    this.removeThisTimer(this.currentTimer);
    this.explode()
};
Landmine.prototype.explode = function() {
    if (this.hitTest(this.m_world.m_player) && !this.m_world.m_player.clipShield) this.m_world.m_player.onEnemyCollision(this, this.config.damage);
    this.forceExplode()
};
Landmine.prototype.forceExplode = function() {
    this.m_state !== Landmine.ST_DIE && (this.m_world.createEffect("scnFxObjectExplotion", this.m_x, this.m_y), this.gotoState(Landmine.ST_DIE))
};
Landmine.prototype.checkForPlayer = function() {
    this.hitTest(this.m_world.m_player) && (this.m_state === Landmine.ST_ARMED ? this.stepOnTrigger && this.explodeOnCollision() : this.m_state !== Landmine.ST_DIE && this.gotoState(Landmine.ST_WARNING))
};
Landmine.prototype.gotoState = function(a) {
    BaseHazard.prototype.gotoState.call(this, a);
    this.unitSounds.playState(a)
};

function FallingRock(a, b, c) {
    BaseHazard.call(this, a, b, c);
    this.config = this.getConfig("FallingObject");
    this.m_type = c.type;
    this.m_yRangeTrigger = this.rayCastToFloor();
    this.m_xRangeTrigger = this.m_npc.xRangeTrigger;
    this.vX = this.vY = 0;
    this.isFreeFalling = this.isAttacking = !1;
    this.traveledDistance = 0;
    this.triggerControlled = !0;
    a = "container" + this.m_type;
    this.m_character.addState(BaseHazard.ST_IDLE, a + "_stand");
    this.m_character.addState(BaseHazard.ST_DIE, a + "_break");
    this.m_character.addState(FallingRock.ST_ARMED,
        a + "_stand");
    this.m_character.addState(FallingRock.ST_FALLING, a + "_fall");
    this.gotoState(BaseHazard.ST_IDLE);
    this.m_world.m_actorManager.triggerSystem.registerCallback("startTrigger", this, this.setAutoFall, !1, !1)
}
Application.subclass(FallingRock, BaseHazard);
FallingRock.ST_ARMED = "st_102";
FallingRock.ST_FALLING = "st_104";
FallingRock.GRAVITY = .03;
FallingRock.VX_AFTER_COLL = .2;
FallingRock.prototype.setAutoFall = function(a) {
    this.m_npc.autoFall = !this.m_npc.autoFall
};
FallingRock.prototype.doRespawn = function() {
    this.m_x = this.m_npc.x;
    this.m_y = this.m_npc.y;
    this.m_clip.visible = !0;
    this.isFreeFalling = this.isAttacking = !1;
    this.vY = this.m_npc.vY;
    this.traveledDistance = this.vX = 0;
    this.gotoState(BaseHazard.ST_IDLE)
};
FallingRock.prototype.update = function(a) {
    this.m_world.m_player.isPlaying && (this.m_npc.autoFall ? this.m_state === BaseHazard.ST_IDLE && this.gotoState(FallingRock.ST_ARMED) : this.checkForPlayer());
    BaseHazard.prototype.update.call(this, a)
};
FallingRock.prototype.rayCastToFloor = function() {
    for (var a = 0, b = 0, c = this.m_x, d = this.m_y + 50; 0 === b && 3E3 > a;) b = this.m_world.getCellInPosition(c, d), d += 25, a += 25;
    return a + 25
};
FallingRock.prototype.checkCollisions = function() {
    if (this.m_state !== BaseHazard.ST_DIE) {
        var a = this.m_world.m_player.m_y - 120 - this.m_y;
        if (50 >= (0 > a ? -a : a) && this.hitTest(this.m_world.m_player) && (this.vY /= 3, this.vX = this.m_world.m_player.m_x < this.m_x ? FallingRock.VX_AFTER_COLL : -FallingRock.VX_AFTER_COLL, this.gotoState(BaseHazard.ST_DIE), !this.m_world.m_player.clipShield)) this.m_world.player().onEnemyCollision(this, this.m_npc.oneHitKill ? this.m_world.m_player.m_health : this.config.damage)
    }
};
FallingRock.prototype.updateStates = function(a) {
    switch (this.m_state) {
        case FallingRock.ST_FALLING:
            this.m_y += this.vY, this.m_x += this.vX * a, this.traveledDistance += this.vY, this.vY += FallingRock.GRAVITY * a, this.traveledDistance >= this.m_yRangeTrigger ? (this.gotoState(BaseHazard.ST_DIE), this.isAttacking = !1) : this.checkCollisions()
    }
};
FallingRock.prototype.onEndAnimation = function(a) {
    BaseHazard.prototype.onEndAnimation.call(this, a);
    switch (a) {
        case BaseHazard.ST_DIE:
            this.m_npc.canRespawn || this.m_npc.autoFall || this.triggerControlled ? this.m_clip.visible && (this.m_clip.visible = !1, this.createTimer(this.m_npc.respawnTime, this, this.doRespawn)) : this.isAwaitingDelete = !0;
            break;
        case FallingRock.ST_ARMED:
            this.m_npc.autoFall ? this.isFreeFalling || (this.createTimer(this.m_npc.autoFallTime, this, this.startFreeFall), this.isFreeFalling = !0) : this.startFreeFall()
    }
};
FallingRock.prototype.startFreeFall = function() {
    this.isAttacking = !0;
    this.gotoState(FallingRock.ST_FALLING)
};
FallingRock.prototype.checkForPlayer = function() {
    this.isPlayerInRange(!1) && !this.isAttacking && this.m_state !== FallingRock.ST_ARMED && this.gotoState(FallingRock.ST_ARMED)
};

function Turret(a, b, c, d) {
    BaseHazard.call(this, a, b, c);
    this.config = this.getConfig("Turret");
    this.m_npc = c;
    this.isResetting = this.isIdle = !1;
    this.canChangeState = this.isEnemy = !0;
    this.flipRelativeX = !1;
    this.aimAngle = this.initAngle = 0;
    this.unitSounds = new UnitSounds("Turret");
    this.m_health = this.config.health;
    this.m_ySensorRange = this.m_xSensorRange = this.m_sensorY = this.m_sensorX = this.m_bulletsInARowCount = this.playerAngle = this.baseAngle = this.offsetAngle = 0;
    this.weapon_die = this.weapon_damaged = this.weapon_charging =
        this.weapon_attackidle = this.weapon_attack = this.weapon_idle = this.weaponContainer = this.m_targetPoint = null;
    this.m_initScaleY = this.m_initScaleX = 0;
    this.m_oldState = BaseHazard.ST_IDLE;
    this.playerSensed = this.isAttacking = !1;
    this.playerInAimingRange = !0;
    this.setupTarget(d);
    this.initPos();
    this.initStates();
    this.maxDistance = this.rayCastDistance(this.aimAngle);
    this.setupSensor()
}
Application.subclass(Turret, BaseHazard);
Turret.ST_ATTACK = "st102";
Turret.ST_CHARGING = "st103";
Turret.ST_ATTACKIDLE = "st104";
Turret.ST_ONHIT = "st105";
Turret.ANGLE_MARGIN_ERROR = 1.57;
Turret.HALF_ARC = .3489;
Turret.MIN_SENSOR_RANGE = 400;
Turret.prototype.update = function(a) {
    this.m_world.m_player.isPlaying && (PlayerSettings.instance.isInLiberation || this.m_state === BaseHazard.ST_DIE || this.m_state === BaseHazard.ST_BASEDIESTAND || (this.sensePlayer(), this.m_npc.aimAtPlayer && this.updateAngle(a), this.m_npc.alwaysOn && (this.playerInAimingRange = !0), this.checkPlayerAttack(), this.checkPlayerNearby()), this.updateCustomListeners(this.currentWeaponClip));
    BaseHazard.prototype.update.call(this, a)
};
Turret.prototype.updateStates = function(a) {
    switch (this.m_state) {
        case BaseHazard.ST_IDLE:
            this.playerSensed && this.playerInAimingRange && this.gotoState(Turret.ST_CHARGING);
            break;
        case Turret.ST_ATTACKIDLE:
            this.isResetting || (this.playerSensed && this.playerInAimingRange ? this.isAttacking || (this.createTimer(this.m_npc.attackDelay, this, this.gotoState, Turret.ST_ATTACK), this.isAttacking = !0) : (this.m_bulletsInARowCount = 0, this.gotoState(BaseHazard.ST_IDLE)))
    }
};
Turret.prototype.updateAngle = function(a) {
    var b = this.getPivotPos();
    a = this.m_world.m_player.m_x - b.x;
    b = this.m_world.m_player.m_y - b.y;
    a = 0 > b ? 6.28 - Math.acos(a / Math.sqrt(a * a + b * b)) : Math.acos(a / Math.sqrt(a * a + b * b));
    a <= this.initAngle + Turret.HALF_ARC && a >= this.initAngle - Turret.HALF_ARC ? this.playerSensed = this.playerInAimingRange = !0 : a = this.clamp(a, this.initAngle - Turret.HALF_ARC, this.initAngle + Turret.HALF_ARC);
    this.offsetAngle = this.flipRelativeX ? 3.14 - (a - this.baseAngle) : a - this.baseAngle;
    this.currentWeaponClip.rotation =
        this.offsetAngle;
    this.aimAngle = a
};
Turret.prototype.onEndAnimation = function(a) {
    switch (a) {
        case BaseHazard.ST_DIE:
            this.gotoState(BaseHazard.ST_BASEDIESTAND)
    }
};
Turret.prototype.weaponOnEndAnimation = function() {
    switch (this.m_state) {
        case Turret.ST_CHARGING:
            this.gotoState(Turret.ST_ATTACK);
            break;
        case Turret.ST_ATTACK:
            if (this.m_npc.useFrequency && (this.m_bulletsInARowCount += 1, this.m_bulletsInARowCount < this.m_npc.bulletsInARow)) {
                this.gotoState(Turret.ST_ATTACK);
                break
            }
            this.isResetting || (this.gotoState(Turret.ST_ATTACKIDLE), this.isResetting = !0, this.createTimer(this.m_npc.attackDelay, this, this.enableAttack));
            break;
        case Turret.ST_ONHIT:
            this.canChangeState = !0;
            this.gotoState(BaseHazard.ST_IDLE);
            break;
        case BaseHazard.ST_DIE:
            this.currentWeaponClip.visible = !1, this.canChangeState = !0
    }
};
Turret.prototype.gotoState = function(a) {
    if (this.canChangeState) {
        BaseHazard.prototype.gotoState.call(this, a);
        this.currentWeaponClip && this.weaponContainer && this.weaponContainer.removeChild(this.currentWeaponClip);
        switch (a) {
            case BaseHazard.ST_IDLE:
                this.currentWeaponClip = this.weapon_idle;
                break;
            case Turret.ST_ATTACK:
                this.currentWeaponClip = this.weapon_attack;
                break;
            case Turret.ST_ATTACKIDLE:
                this.currentWeaponClip = this.weapon_attackidle;
                break;
            case Turret.ST_CHARGING:
                this.currentWeaponClip = this.weapon_charging;
                break;
            case Turret.ST_ONHIT:
                this.currentWeaponClip = this.weapon_damaged;
                break;
            case BaseHazard.ST_DIE:
                this.currentWeaponClip = this.weapon_die, this.removeThisTimer(this.currentTimer)
        }
        this.m_clip.scale.x = this.flipRelativeX ? -1 : 1;
        this.m_clip.rotation = this.baseAngle;
        if (this.weaponContainer = this.m_clip.mcArmContainer) {
            this.weaponContainer.addChild(this.currentWeaponClip);
            this.currentWeaponClip.rotation = this.offsetAngle;
            if (0 === this.m_initScaleX || 0 === this.m_initScaleY) this.m_initScaleX = this.currentWeaponClip.scale.x,
                this.m_initScaleY = this.currentWeaponClip.scale.y;
            this.currentWeaponClip.scale.x = this.m_initScaleX / Application.DPI;
            this.currentWeaponClip.scale.y = this.m_initScaleY / Application.DPI;
            this.currentWeaponClip.onEndAnimation(this, this.weaponOnEndAnimation)
        }
    }
};
Turret.prototype.lookAtPlayerAngle = function() {
    var a = this.getBarrelPos(),
        b = this.m_world.m_player.m_x - a.x,
        a = this.m_world.m_player.m_y - 60 - a.y,
        c = Math.sqrt(b * b + a * a),
        b = Math.acos(b / c);
    return 0 > a ? -b : b
};
Turret.prototype.sensePlayer = function() {
    this.playerSensed = this.m_npc.alwaysOn || !1;
    this.playerInAimingRange = !1;
    var a = this.m_world.m_player.m_x - this.m_sensorX,
        b = this.m_world.m_player.m_y - 60 - this.m_sensorY;
    (0 > a ? -a : a) <= this.m_xSensorRange && (0 > b ? -b : b) <= this.m_ySensorRange && (this.playerSensed = !0, this.checkPlayerAngle())
};
Turret.prototype.checkPlayerAngle = function() {
    var a = this.lookAtPlayerAngle();
    0 > a && (a = 6.28 + a);
    var b = a - this.aimAngle,
        c = a - (this.aimAngle + 6.28);
    (0 > b ? -b : b) <= Turret.HALF_ARC || (0 > c ? -c : c) <= Turret.HALF_ARC ? (this.playerInAimingRange = !0, this.playerAngle = a) : this.playerInAimingRange = !1
};
Turret.prototype.onExpel = function() {
    if (PlayerSettings.instance.isPlayerMelee()) this.onHit(2 * this.m_world.m_player.data.damageMelee);
    else this.onHit(2 * this.m_world.m_player.gunWeapon.data.damage)
};
Turret.prototype.checkPlayerAttack = function() {
    if (this.m_world.m_player.clipSpecialAttack && SDisplayObjectContainer.hitTestByBounds(this.m_clip, this.m_clip.getCollision(SimpleWorldActor.COLLISION), this.m_world.m_player.clipSpecialAttack, this.m_world.m_player.clipSpecialAttack.getCollision(SimpleWorldActor.COLLISION_SPECIAL))) this.onHit(100);
    else if (this.hitCollisions(SimpleWorldActor.COLLISION, this.m_world.m_player, SimpleWorldActor.COLLISION_ATTACK)) {
        var a = 0,
            a = this.m_world.m_player.isJumpAttack() ? this.m_world.m_player.data.damageSpin :
            this.m_world.m_player.data.damageMelee;
        this.onHit(a);
        Global.game.onShake(4, 10, 200)
    }
};
Turret.prototype.onHit = function(a) {
    this.m_health === this.config.health && (this.weapon_attack = Application.instance.getClip(this.skin + "0_attack2"), this.weapon_attackidle = Application.instance.getClip(this.skin + "0_attackidle2"), this.weapon_charging = Application.instance.getClip(this.skin + "0_charging2"), this.weapon_idle = Application.instance.getClip(this.skin + "0_idle2"), this.weapon_damaged = Application.instance.getClip(this.skin + "0_hit2"));
    this.m_health -= a;
    0 < this.m_health ? (this.m_state !== Turret.ST_ONHIT && (this.m_oldState =
        this.m_state), this.unitSounds.playState(Turret.ST_ONHIT), this.gotoState(Turret.ST_ONHIT)) : (this.unitSounds.playState(BaseHazard.ST_DIE), this.gotoState(BaseHazard.ST_DIE), a = this.getPivotPos(), this.m_world.createEffect("scnFxObjectExplotion", a.x, a.y), Global.game.createExplotionShader(a.x - this.m_world.m_camera.m_x, a.y - this.m_world.m_camera.m_y, 8));
    this.canChangeState = !1;
    return !0
};
Turret.prototype.fire = function() {
    this.unitSounds && this.playerInSoundRange() && this.unitSounds.playState(Turret.ST_ATTACK);
    var a = this.getBarrelPos();
    this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_ENEMY, Bullet.NAME_SKIN_BULLET_ENEMY, a.x, a.y, this.maxDistance, this.aimAngle, this.config.bulletSpeed, this.config.damage, Bullet.FX_IMPACT_LASER_ENEMY)
};
Turret.prototype.setupTarget = function(a) {
    if (a && "" !== this.m_npc.turretId)
        for (var b = 0; b < a.length; b++)
            if (a[b].turretId === this.m_npc.turretId && a[b].id === ActorManagerPlatform.HAZARD_TURRET_TARGET) {
                this.m_targetPoint = a[b];
                break
            }
};
Turret.prototype.initStates = function() {
    this.skin = "turret_s";
    this.weapon_idle = Application.instance.getClip(this.skin + "0_idle");
    this.weapon_attack = Application.instance.getClip(this.skin + "0_attack");
    this.weapon_attackidle = Application.instance.getClip(this.skin + "0_attackidle");
    this.weapon_charging = Application.instance.getClip(this.skin + "0_charging");
    this.weapon_damaged = Application.instance.getClip(this.skin + "0_hit");
    this.weapon_die = Application.instance.getClip(this.skin + "0_die");
    this.m_character.addState(BaseHazard.ST_IDLE,
        this.skin + this.m_npc.type + "_base");
    this.m_character.addState(Turret.ST_ATTACK, this.skin + this.m_npc.type + "_base");
    this.m_character.addState(Turret.ST_ATTACKIDLE, this.skin + this.m_npc.type + "_base");
    this.m_character.addState(Turret.ST_CHARGING, this.skin + this.m_npc.type + "_base");
    this.m_character.addState(Turret.ST_ONHIT, this.skin + this.m_npc.type + "_base_onhit");
    this.m_character.addState(BaseHazard.ST_DIE, this.skin + this.m_npc.type + "_base_die");
    this.m_character.addState(BaseHazard.ST_BASEDIESTAND, this.skin +
        this.m_npc.type + "_base_diestand");
    this.currentWeaponClip = this.weaponContainer = null;
    this.addCustomListener(Turret.ST_ATTACK, [{
        caller: this,
        callback: this.fire,
        frame: 3
    }]);
    this.gotoState(Turret.ST_ATTACK)
};
Turret.prototype.getClosestCollCell = function() {
    for (var a = 25, b = {
            x: this.m_x,
            y: this.m_y
        }, c = 0, d = 0; 0 === c && 1E3 >= a;)
        if (6.28 < d && (a += 25, d = 0), b.x = this.m_x + Math.cos(d) * a, b.y = this.m_y + Math.sin(d) * a, c = this.m_world.getCellInPosition(b.x, b.y), d += .314, 0 !== c) return d = 180 * d / Math.PI, d = Common.gradToRadian(45 * Math.floor((d + 22.5) / 45)), {
            pos: b,
            angle: d
        };
    Application.log("Turret in position " + this.m_x + "," + this.m_y + " never found a collision block, setting default position");
    b.x = this.m_x;
    b.y = this.m_y;
    return {
        pos: b,
        angle: 0
    }
};
Turret.prototype.initPos = function() {
    var a = this.getClosestCollCell();
    this.baseAngle = this.m_npc.manualBase ? Common.gradToRadian(this.m_npc.baseAngle) : 1.57 > a.angle ? 3.14 - (a.angle - 1.57) : a.angle - 1.57;
    this.m_npc.manualPosition || (this.m_x = a.pos.x, this.m_y = a.pos.y);
    if (this.m_targetPoint) var b = PoolClips.instance.getClip("turret_s" + this.m_npc.type + "_base"),
        a = this.m_x + (b.mcArmContainer.x * Math.cos(this.baseAngle) - b.mcArmContainer.y * Math.sin(this.baseAngle)),
        b = this.m_y + (b.mcArmContainer.y * Math.cos(this.baseAngle) -
            b.mcArmContainer.x * Math.sin(this.baseAngle)),
        a = this.m_targetPoint.x - a,
        b = this.m_targetPoint.y - b,
        a = 0 > b ? -Math.acos(a / Math.sqrt(a * a + b * b)) : Math.acos(a / Math.sqrt(a * a + b * b));
    else a = Common.gradToRadian(this.m_npc.weaponAngle);
    a > this.baseAngle + Turret.ANGLE_MARGIN_ERROR || a < this.baseAngle - Turret.ANGLE_MARGIN_ERROR ? (this.flipRelativeX = !0, this.offsetAngle = 3.14 - (a - this.baseAngle)) : this.offsetAngle = a - this.baseAngle;
    this.aimAngle = this.initAngle = 0 > a ? 6.28 + a : a
};
Turret.prototype.rayCastDistance = function(a) {
    for (var b = 0, c = 0, d = this.getPivotPos(); 0 === c && c !== WorldCollisionLayer.CELL_FULL && 1024 >= b;) c = this.m_world.getCellInPosition(d.x, d.y), d.x += 25 * Math.cos(a), d.y += 25 * Math.sin(a), b += 25;
    return b
};
Turret.prototype.setupSensor = function() {
    this.getBarrelPos();
    this.m_sensorX = this.m_x + Math.cos(this.aimAngle) * this.maxDistance * .5;
    this.m_sensorY = this.m_y + Math.sin(this.aimAngle) * this.maxDistance * .5;
    this.m_xSensorRange = this.abs(Math.cos(this.aimAngle) * this.maxDistance * .5);
    this.m_ySensorRange = this.abs(Math.sin(this.aimAngle) * this.maxDistance * .5);
    this.m_xSensorRange = this.clamp(this.m_xSensorRange, Turret.MIN_SENSOR_RANGE, this.maxDistance);
    this.m_ySensorRange = this.clamp(this.m_ySensorRange, Turret.MIN_SENSOR_RANGE,
        this.maxDistance)
};
Turret.prototype.getPivotPos = function() {
    var a = this.m_x + ((this.flipRelativeX ? -1 : 1) * this.m_clip.mcArmContainer.x * Math.cos(this.baseAngle) - this.m_clip.mcArmContainer.y * Math.sin(this.baseAngle)),
        b = this.m_y + (this.m_clip.mcArmContainer.y * Math.cos(this.baseAngle) - this.m_clip.mcArmContainer.x * Math.sin(this.baseAngle));
    return {
        x: a,
        y: b
    }
};
Turret.prototype.getBarrelPos = function() {
    var a = this.getPivotPos(),
        b = a.x + 90 * Math.cos(this.aimAngle),
        a = a.y + 90 * Math.sin(this.aimAngle);
    return {
        x: b,
        y: a
    }
};
Turret.prototype.normalizeAngle = function(a) {
    if (6.28 <= a)
        for (; 6.28 < a;) a -= 6.28;
    else if (0 > a)
        for (; 0 > a;) a += 6.28;
    return a
};
Turret.prototype.isPlayerInRange = function() {
    var a = this.m_world.m_player.m_x - this.m_sensorX,
        b = this.m_world.m_player.m_y - 60 - this.m_sensorY;
    return (0 > a ? -a : a) <= this.m_xSensorRange && (0 > b ? -b : b) <= this.m_ySensorRange && this.playerInAimingRange ? !0 : !1
};
Turret.prototype.checkPlayerNearby = function() {
    var a = this.m_x - this.m_world.m_player.m_x,
        b = this.m_y - (this.m_world.m_player.m_y - 60);
    100 > (0 > b ? -b : b) && 120 > (0 > a ? -a : a) && (PlatformGame.playerNearEnemy = !0, this.m_world.m_player.m_clip.hitTest(this.m_clip) && (this.m_world.m_player.m_x += 5 * (this.m_x > this.m_world.m_player.m_x ? -1 : 1)))
};
Turret.prototype.enableAttack = function() {
    this.isAttacking = !1;
    this.m_bulletsInARowCount = 0;
    this.isResetting = !1
};
Turret.prototype.playerInSoundRange = function() {
    var a = this.getBarrelPos();
    return a.x >= this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX && a.x <= this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX + this.m_world.m_camera.fixWidthRatio && a.y >= this.m_world.m_camera.m_y && a.y <= this.m_world.m_camera.m_y + this.m_world.m_camera.height()
};
Turret.prototype.clamp = function(a, b, c) {
    return Math.min(Math.max(a, b), c)
};
Turret.prototype.free = function() {
    this.weaponContainer && this.weaponContainer.removeChild(this.currentWeaponClip);
    this.currentWeaponClip.free();
    this.currentWeaponClip = null;
    BaseHazard.prototype.free.call(this)
};

function Spike(a, b, c, d) {
    this.isMovable = d;
    this.isStatic = c.isStatic;
    this.mobileObject = null;
    this.isMovable && (this.mobileObject = new MobilePlatform(a, b, "platform" + c.type, c, new DataMovement(c.params, c.movement)), this.mobileObject.isRangeControlled = !1);
    this.m_orthoRange = this.m_wideRange = 0;
    BaseHazard.call(this, a, b, c);
    this.config = this.getConfig("Spike");
    this.m_angle = .0174533 * this.m_npc.angle;
    this.oneHitKill = c.oneHitKill;
    this.isAttacking = this.isRearming = this.attackDisabled = !1
}
Application.subclass(Spike, BaseHazard);
Spike.ST_ATTACK = "st_102";
Spike.ST_WARNING = "st_103";
Spike.ST_WITHDRAW = "st_104";
Spike.ST_STATIC = "st_105";
Spike.prototype.init = function() {
    var a = this.isMovable ? "platform" + this.m_npc.type : "spike" + this.m_npc.type;
    this.m_character.addState(BaseHazard.ST_IDLE, a + "_idle");
    this.m_character.addState(Spike.ST_ATTACK, a + "_attack", [{
        caller: this,
        callback: this.attackPlayer,
        frame: 1
    }]);
    this.m_character.addState(Spike.ST_WARNING, a + "_warning");
    this.m_character.addState(Spike.ST_WITHDRAW, a + "_withdraw");
    this.m_character.addState(Spike.ST_STATIC, a + "_static");
    this.gotoState(this.isStatic ? Spike.ST_STATIC : BaseHazard.ST_IDLE);
    this.m_wideRange = -1 !== this.m_npc.xRangeTrigger ? this.m_npc.xRangeTrigger : PoolClips.instance.getClip(a + "_attack").getCollision("mcCollision").w / 2;
    this.m_orthoRange = -1 !== this.m_npc.yRangeTrigger ? this.m_npc.yRangeTrigger : PoolClips.instance.getClip(a + "_attack").getCollision("mcCollision").h / 2
};
Spike.prototype.gotoState = function(a) {
    BaseHazard.prototype.gotoState.call(this, a);
    this.m_clip.rotation = this.m_angle
};
Spike.prototype.onIdle = function(a) {
    BaseHazard.prototype.onIdle.call(this, a);
    if (this.mobileObject) this.mobileObject.onIdle(a)
};
Spike.prototype.update = function(a) {
    this.mobileObject && (this.mobileObject.update(a), this.m_x = this.mobileObject.m_x, this.m_y = this.mobileObject.m_y);
    BaseHazard.prototype.update.call(this, a)
};
Spike.prototype.onEndAnimation = function(a) {
    switch (a) {
        case Spike.ST_WARNING:
            this.m_clip.stop();
            break;
        case Spike.ST_ATTACK:
            this.createTimer(this.config.withdrawDelay, this, this.gotoState, Spike.ST_WITHDRAW);
            this.gotoState(Spike.ST_STATIC);
            this.isAttacking = !1;
            break;
        case Spike.ST_WITHDRAW:
            this.m_clip.stop(), this.createTimer(this.m_npc.rearmDelay, this, this.resetRearm), this.isRearming = !0
    }
};
Spike.prototype.resetRearm = function() {
    this.attackDisabled = this.isRearming = !1;
    this.gotoState(BaseHazard.ST_IDLE)
};
Spike.prototype.attackPlayer = function() {
    this.attackDisabled || this.hitTest(this.m_world.m_player) && !this.m_world.m_player.clipShield && this.m_world.player().onEnemyCollision(this, this.oneHitKill ? this.m_world.m_player.m_health : this.config.damage) && Application.instance.playSound("SND_LASER_SHOCK")
};
Spike.prototype.isHorizontal = function() {
    return 0 === this.m_npc.angle || 180 === this.m_npc.angle
};
Spike.prototype.updateStates = function(a) {
    this.hitTest(this.m_world.m_player) && this.attackPlayer();
    switch (this.m_state) {
        case BaseHazard.ST_IDLE:
            this._isPlayerInRange(2 * this.m_wideRange) && !this.isRearming && this.gotoState(Spike.ST_WARNING);
            break;
        case Spike.ST_WARNING:
            this.isAttacking || (this.createTimer(this.m_npc.attackDelay, this, this.gotoState, Spike.ST_ATTACK), this.isAttacking = !0)
    }
};
Spike.prototype._isPlayerInRange = function(a) {
    var b = this.m_world.m_player.m_x - this.m_x,
        b = 0 > b ? -b : b,
        c = this.m_y - this.m_world.m_player.m_y;
    if (this.isHorizontal()) {
        if (b <= a && (0 > c ? -c : c) <= this.m_orthoRange) return !0
    } else if (c -= 60, c = 0 > c ? -c : c, b <= this.m_orthoRange && c <= a) return !0;
    return !1
};

function GroundSaw(a, b, c) {
    BaseHazard.call(this, a, b, c);
    this.config = this.getConfig("GroundHazard");
    this.m_currentDirection = c.initialDirection || .5 < Math.random() ? 1 : -1;
    this.m_limitRight = this.m_limitLeft = 0;
    this.m_vX = c.vX;
    this.isTurning = this.isAttacking = !1;
    this.m_startX = this.m_x;
    this.m_character.addState(BaseHazard.ST_IDLE, "saw_idle");
    this.m_character.addState(GroundSaw.ST_RUNNING, "saw_running");
    this.m_character.addState(GroundSaw.ST_DIE, "saw_explode");
    this.gotoState(GroundSaw.ST_RUNNING);
    this.m_clip.onEndAnimation(this,
        this.onEndAnimation);
    this.setLimits();
    this.m_diameter = this.m_clip.getCollision("mcCollision").w / 2
}
Application.subclass(GroundSaw, BaseHazard);
GroundSaw.ST_RUNNING = "st_102";
GroundSaw.ST_DIE = "st_103";
GroundSaw.RIGHTDIRECTION = 1;
GroundSaw.LEFTDIRECTION = -1;
GroundSaw.DISTANCE_BEFORE_CHANGE_DIR = 100;
GroundSaw.prototype.onEndAnimation = function(a) {
    a === GroundSaw.ST_DIE && (this.isAwaitingDelete = !0, this.m_clip.visible = !1)
};
GroundSaw.prototype.setLimits = function() {
    for (var a = 1, b = 0; b < this.m_npc.limitLeft && 0 !== a;) b += 15, a = this.m_world.getCellInPosition(this.m_x - b, this.m_y + 7.5);
    this.m_limitLeft = b;
    b = 0;
    for (a = 1; b < this.m_npc.limitRight && 0 !== a;) b += 15, a = this.m_world.getCellInPosition(this.m_x + b, this.m_y + 7.5);
    this.m_limitRight = b
};
GroundSaw.prototype.onSpecialHit = function() {
    this.m_state !== GroundSaw.ST_DIE && (this.m_world.createEffect("scnFxObjectExplotion", this.m_x, this.m_y), this.gotoState(GroundSaw.ST_DIE))
};
GroundSaw.prototype.update = function(a) {
    this.checkForSpecial();
    if (this.m_state === GroundSaw.ST_RUNNING) switch (this.m_currentDirection) {
        case GroundSaw.RIGHTDIRECTION:
            this.m_x += this.lerp(this.m_x, this.getRight(), this.m_vX, a);
            this.m_startX + this.m_limitRight - this.m_x <= GroundSaw.DISTANCE_BEFORE_CHANGE_DIR && !this.isTurning && (this.m_currentDirection = GroundSaw.LEFTDIRECTION, this.m_toLeft = !0, this.gotoState(BaseHazard.ST_IDLE), this.isTurning = !0, this.m_world.timerManager.createTimer(500, this, this.startRunning,
                null));
            break;
        case GroundSaw.LEFTDIRECTION:
            this.m_x -= this.lerp(this.getLeft(), this.m_x, this.m_vX, a), this.m_x - (this.m_startX - this.m_limitLeft) <= GroundSaw.DISTANCE_BEFORE_CHANGE_DIR && !this.isTurning && (this.m_currentDirection = GroundSaw.RIGHTDIRECTION, this.m_toLeft = !1, this.gotoState(BaseHazard.ST_IDLE), this.isTurning = !0, this.m_world.timerManager.createTimer(500, this, this.startRunning, null))
    }
    BaseHazard.prototype.update.call(this, a);
    this.m_world.m_player.isPlaying && this.checkCollisions()
};
GroundSaw.prototype.getRight = function() {
    return this.m_startX + this.m_limitRight
};
GroundSaw.prototype.getLeft = function() {
    return this.m_startX - this.m_limitLeft
};
GroundSaw.prototype.reEnableAttack = function() {
    this.isAttacking = !1
};
GroundSaw.prototype.startRunning = function(a) {
    this.setState(GroundSaw.ST_RUNNING, this.m_toLeft);
    this.isTurning = !1
};
GroundSaw.prototype.checkCollisions = function() {
    this.isAttacking || this.m_state !== GroundSaw.ST_RUNNING || !this.m_clip.hitTest(this.m_world.m_player.m_clip) || this.m_world.m_player.clipShield || (this.m_world.player().onEnemyCollision(this, this.config.damage), this.isAttacking = !0, this.createTimer(this.config.attackDelay, this, this.reEnableAttack))
};

function DumbTrooper(a, b, c, d, e) {
    SimpleWorldActor.call(this, a, b, c, d);
    this.type = Common.randomInt(1, 3);
    this.skin = "chr_storm";
    this.isEnemy = !0;
    this.health = e;
    this.hitCounter = 1;
    this.unitSounds = new UnitSounds("Stormtrooper");
    this.config = this.getConfig("Dumbtrooper");
    this.init()
}
Application.subclass(DumbTrooper, SimpleWorldActor);
DumbTrooper.ST_STAND = "st100";
DumbTrooper.ST_WALK = "st101";
DumbTrooper.ST_ATTACK = "st102";
DumbTrooper.ST_WARNING = "st105";
DumbTrooper.ST_APPEAR = "st107";
DumbTrooper.prototype.free = function() {
    SimpleWorldActor.prototype.free.call(this)
};
DumbTrooper.prototype.init = function() {
    this.m_character = new SimpleCharacter(0, 0, this.m_canvas);
    this.m_character.addState(DumbTrooper.ST_STAND, this.skin + "_stand_" + this.type);
    this.m_character.addState(BaseEnemy.ST_HIT, this.skin + "_hit_" + this.hitCounter);
    this.m_character.addState(DumbTrooper.ST_WALK, this.skin + "_walk");
    this.m_character.addState(BaseEnemy.ST_DIE, this.skin + "_die_floor");
    this.m_character.addState(DumbTrooper.ST_ATTACK, this.skin + "_attack_" + this.type, [{
        caller: this,
        callback: this.createBullet,
        frame: 4
    }]);
    this.m_character.addState(DumbTrooper.ST_WARNING, this.skin + "_warning");
    this.m_character.addState(DumbTrooper.ST_APPEAR, this.skin + "_appear");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.gotoState(DumbTrooper.ST_STAND)
};
DumbTrooper.prototype.createBullet = function() {
    var a = this.m_x + 62 * (this.m_flipX ? -1 : 1),
        b = this.m_y - 84;
    this.unitSounds.playState(DumbTrooper.ST_ATTACK);
    var c = this.m_flipX ? 3.14 : 0,
        c = c + (.5 < Math.random() ? .05 * Math.random() : .05 * -Math.random());
    this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_ENEMY, Bullet.NAME_SKIN_BULLET_ENEMY, a, b, this.config.bulletMaxDistance, c, this.config.bulletSpeed, this.config.bulletDamage);
    this.m_world.createEffect("aniFxShootEnemy", a, b)
};
DumbTrooper.prototype.onEndAnimation = function(a) {
    switch (a) {
        case DumbTrooper.ST_ATTACK:
            this.gotoState(DumbTrooper.ST_STAND);
            break;
        case BaseEnemy.ST_HIT:
            this.gotoState(DumbTrooper.ST_STAND);
            break;
        case BaseEnemy.ST_DIE:
            this.isAwaitingDelete = !0
    }
};
DumbTrooper.prototype.onExpel = function() {
    BaseEnemy.prototype.onExpel.call(this)
};
DumbTrooper.prototype.onHit = function(a) {
    if (this.m_state === BaseEnemy.ST_DIE || this.m_state === BaseEnemy.ST_HIT && 0 !== this.m_clip.currentFrame % BaseEnemy.FRAME_CAN_HIT) return !1;
    this.health -= a;
    0 >= this.health ? (this.health = 0, this.gotoState(BaseEnemy.ST_DIE), this.unitSounds.playState(BaseEnemy.ST_DIE)) : (this.m_character.addState(BaseEnemy.ST_HIT, this.skin + "_hit_" + this.hitCounter, [{
            caller: this,
            callback: this.gotoStand,
            frame: Common.randomInt(10, 14)
        }]), this.gotoState(BaseEnemy.ST_HIT), this.unitSounds.playState(BaseEnemy.ST_HIT),
        this.hitCounter = 1 == this.hitCounter ? 2 : 1);
    return !0
};
DumbTrooper.prototype.gotoStand = function() {
    this.gotoState(DumbTrooper.ST_STAND)
};
DumbTrooper.prototype.gotoState = function(a) {
    SimpleWorldActor.prototype.gotoState.call(this, a)
};
DumbTrooper.prototype.onShoot = function() {
    this.m_state === BaseEnemy.ST_HIT || this.m_state === BaseEnemy.ST_DIE || this.m_world.m_player.disablePlayer || this.gotoState(DumbTrooper.ST_ATTACK)
};
DumbTrooper.prototype.update = function(a) {
    SimpleWorldActor.prototype.update.call(this, a);
    BaseEnemy.prototype.onCheckCollisionPlayer.call(this);
    this.m_world.m_player.m_x < this.m_x ? this.setFlipX(!0) : this.setFlipX(!1)
};
DumbTrooper.prototype.getConfig = function(a) {
    for (var b = Application.config.groundEnemies, c = 0; c < b.length; c++)
        if (b[c].type === a) return b[c]
};

function DumbTrooperController(a, b) {
    this.world = a;
    this.data = b;
    this.troopers = [];
    this.isRangeControlled = !1;
    this.m_x = this.data.x;
    this.m_y = this.data.y;
    this.frecuency = this.data.frecuency;
    this.world.actorManager().createDumbTroopers(this, this.data.x, this.data.y, this.data.health, this.data.quantity, this.data.separation)
}
DumbTrooperController.prototype.free = function() {
    this.troopers = this.data = this.world = null
};
DumbTrooperController.prototype.onIdle = function(a) {};
DumbTrooperController.prototype.update = function(a) {
    for (var b = 0, b = 0; b < this.troopers.length; b++) this.troopers[b].isAwaitingDelete && this.troopers.splice(b--, 1);
    this.frecuency -= a;
    if (0 >= this.frecuency) {
        this.troopers = Common.mixer(this.troopers);
        for (b = 0; b < this.troopers.length; b++)
            if (b < this.data.shooters && !this.troopers[b].isIdle && (a = this.world.m_player.m_y - this.m_y, 400 >= a && -400 <= a && this.world.m_player.m_state !== Player.ST_PLAYER_CELEBRATE && !this.world.m_player.waitingForCelebrate && this.world.m_player.isPlaying)) this.troopers[b].onShoot();
        this.frecuency = this.data.frecuency
    }
};

function LaserHazard(a, b, c) {
    this.m_skin = "laser";
    this.m_orientation = "";
    BaseHazard.call(this, a, b, c);
    this.isEnemy = this.isResetting = this.isAttacking = !1
}
Application.subclass(LaserHazard, BaseHazard);
LaserHazard.ST_ON = "st_101";
LaserHazard.ST_CHARGE = "st_102";
LaserHazard.ST_HITPLAYER = "st_103";
LaserHazard.ST_WITHDRAW = "st_104";
LaserHazard.ST_PRE_ON = "st_105";
LaserHazard.prototype.onEndAnimation = function(a) {
    if (!this.m_npc.alwaysOn) switch (a) {
        case LaserHazard.ST_CHARGE:
            this.gotoState(LaserHazard.ST_PRE_ON);
            this.isAttacking = !1;
            break;
        case LaserHazard.ST_WITHDRAW:
            this.gotoState(BaseHazard.ST_IDLE);
            break;
        case LaserHazard.ST_PRE_ON:
            this.gotoState(LaserHazard.ST_ON)
    }
    a === LaserHazard.ST_HITPLAYER && this.gotoState(LaserHazard.ST_ON)
};
LaserHazard.prototype.updateStates = function(a) {
    switch (this.m_state) {
        case BaseHazard.ST_IDLE:
            this.isAttacking || (this.createTimer(this.config.attackDelay, this, this.gotoState, LaserHazard.ST_CHARGE), this.isAttacking = !0);
            break;
        case LaserHazard.ST_ON:
        case LaserHazard.ST_HITPLAYER:
        case LaserHazard.ST_PRE_ON:
            this.checkHitCollisions(), this.m_npc.alwaysOn || this.isResetting || (this.createTimer(this.config.withdrawDelay, this, this.gotoState, LaserHazard.ST_WITHDRAW), this.isResetting = !0)
    }
};
LaserHazard.prototype.gotoState = function(a) {
    switch (a) {
        case BaseHazard.ST_IDLE:
            this.resetAttack()
    }
    BaseHazard.prototype.gotoState.call(this, a)
};
LaserHazard.prototype.checkHitCollisions = function() {
    var a = !1;
    if (this.m_world.m_player.clipShield) {
        var b = this.m_clip.getCollision("mcCollision"),
            c = 0,
            d = 0;
        "horizontal" === this.m_orientation ? (c = this.m_x > this.m_world.m_player.m_x ? this.m_x + .5 * b.w - this.m_world.m_player.m_x : this.m_world.m_player.m_x - (this.m_x + .5 * b.w), d = this.m_y > this.m_world.m_player.m_y ? this.m_y - (this.m_world.m_player.m_y - 60) : this.m_world.m_player.m_y - 60 - this.m_y) : (c = this.m_x > this.m_world.m_player.m_x ? this.m_x - this.m_world.m_player.m_x : this.m_world.m_player.m_x -
            this.m_x, d = this.m_y > this.m_world.m_player.m_y ? this.m_y + .5 * b.h - (this.m_world.m_player.m_y - 60) : this.m_world.m_player.m_y - 60 - (this.m_y + .5 * b.h));
        c <= .5 * b.w + PlayerPlatform.SHIELD_RANGE && d <= .5 * b.h + PlayerPlatform.SHIELD_RANGE && (a = !0)
    } else this.hitCollisions("mcCollision", this.m_world.m_player, "mcCollision") && (a = !0);
    if (a) {
        switch (this.m_npc.type) {
            case 0:
            case 1:
            case 2:
                this.m_world.m_player.m_x += 10 * (this.m_x > this.m_world.m_player.m_x ? -1 : 1);
                break;
            case 3:
            case 4:
            case 5:
                this.m_world.m_player.m_y += 10 * (this.m_y > this.m_world.m_player.m_y -
                    60 ? -1 : 1), this.m_world.m_player.m_control.m_jumpInitSpeed = 0, this.m_world.m_player.m_control.m_timeJumping = 0
        }
        this.applyHazardEffect(null !== this.m_world.m_player.clipShield)
    }
};
LaserHazard.prototype.doPureDamageToPlayer = function(a) {
    this.m_world.m_player.onEnemyCollision(this, a)
};
LaserHazard.prototype.applyHazardEffect = function(a) {
    a || this.doPureDamageToPlayer(this.m_npc.oneHitKill ? this.m_world.m_player.m_health : this.config.damage);
    Application.instance.playSound("SND_LASER_SHOCK");
    this.gotoState(LaserHazard.ST_HITPLAYER);
    this.m_clip.gotoAndPlay(1)
};
LaserHazard.prototype.toggleAlwaysOn = function(a) {
    this.m_npc.alwaysOn = a.comesFromRight;
    this.removeThisTimer(this.currentTimer);
    this.m_npc.alwaysOn ? this.gotoState(LaserHazard.ST_ON) : this.gotoState(BaseHazard.ST_IDLE)
};
LaserHazard.prototype.resetAttack = function() {
    this.isResetting = this.isAttacking = !1
};
LaserHazard.prototype.init = function() {
    this.config = this.getConfig("Laser");
    this.m_orientation = 3 > this.m_npc.type ? "vertical" : "horizontal";
    this.m_skin = "laser" + (3 > this.m_npc.type ? this.m_orientation + (this.m_npc.type + 1) : this.m_orientation + (this.m_npc.type - 2));
    this.m_character.addState(LaserHazard.ST_ON, this.m_skin + "_on_stand");
    this.m_character.addState(LaserHazard.ST_WITHDRAW, this.m_skin + "_off");
    this.m_character.addState(LaserHazard.ST_HITPLAYER, this.m_skin + "_hit");
    this.m_character.addState(LaserHazard.ST_CHARGE,
        this.m_skin + "_charge");
    this.m_character.addState(LaserHazard.ST_PRE_ON, this.m_skin + "_on");
    this.m_character.addState(BaseHazard.ST_IDLE, this.m_skin + "_off_stand");
    this.m_npc.alwaysOn ? this.gotoState(LaserHazard.ST_ON) : this.gotoState(BaseHazard.ST_IDLE);
    "" !== this.m_npc.triggerId && this.m_world.m_actorManager.triggerSystem.registerCallback(this.m_npc.triggerId, this, this.toggleAlwaysOn, null, !1);
    this.m_clip.onEndAnimation(this, this.onEndAnimation)
};

function EWebRepeaterBlaster(a, b, c, d) {
    Stormtrooper.call(this, a, b, c, "EwebRepeaterBlaster", d);
    this.m_attackTimer = this.m_bulletsInARowCount = 0;
    this.canBePushed = this.canMove = !1;
    PlayerSettings.instance.hasGrabbedAllItems() && this.canFlip() && this.flipX();
    this.gotoState(Stormtrooper.ST_STAND);
    this.setLookAtLeft(this.m_npc.lookLeft)
}
Application.subclass(EWebRepeaterBlaster, Stormtrooper);
EWebRepeaterBlaster.prototype.init = function() {
    this.m_probRespawn = this.config.probRespawn;
    this.m_timeToRespawn = this.config.timeToRespawn;
    this.m_health = this.config.health;
    this.skin = "chr_repeater";
    this.m_character = new SimpleCharacter(this.m_npc.x, this.m_npc.y, this.m_canvas);
    this.m_character.addState(Stormtrooper.ST_STAND, this.skin + "_stand");
    this.m_character.addState(BaseEnemy.ST_HIT, this.skin + "_hit");
    this.m_character.addState(BaseEnemy.ST_DIE, this.skin + "_die");
    this.m_character.addState(Stormtrooper.ST_ATTACK,
        this.skin + "_attack", [{
            caller: this,
            callback: this.createBullet,
            frame: 2
        }]);
    this.m_character.addState(EWebRepeaterBlaster.ST_CHARGEREPEATER, this.skin + "_charging", [{
        caller: this,
        callback: this.shootAtPlayer,
        frame: 5
    }]);
    this.m_character.addState(Stormtrooper.ST_ATTACKIDLE, this.skin + "_attackidle");
    this.m_character.onEndAnimation(this, this.onEndAnimation)
};
EWebRepeaterBlaster.prototype.settings = function(a, b, c, d, e, f) {
    Stormtrooper.prototype.settings.call(this, a, b, c, d, e, f);
    this.m_limits = b.getMaxFloorRange(c, d, 0)
};
EWebRepeaterBlaster.ST_CHARGEREPEATER = "st120";
EWebRepeaterBlaster.prototype.onEndAnimation = function(a) {
    this.m_isInvulnerable = !1;
    switch (a) {
        case EWebRepeaterBlaster.ST_CHARGEREPEATER:
            this.setState(Stormtrooper.ST_ATTACK, this.m_toLeft);
            break;
        case BaseEnemy.ST_HIT:
            this.setState(this.m_oldState, this.m_toLeft);
            break;
        case BaseEnemy.ST_DIE:
            this.isAwaitingDelete = !0;
            this.m_character.clip.stop();
            break;
        case Stormtrooper.ST_ATTACK:
            this.m_bulletsInARowCount += 1, this.m_bulletsInARowCount <= this.config.bulletsInARow ? (this.setState(Stormtrooper.ST_ATTACKIDLE, this.m_toLeft),
                this.m_betweenBulletsTimer = 0) : (this.m_bulletsInARowCount = 0, this.setState(Stormtrooper.ST_STAND, this.m_toLeft))
    }
};
EWebRepeaterBlaster.prototype.updateStates = function(a) {
    this.getDetectionType() === Stormtrooper.PLAYER_ON_FIRERANGE && this.isPlayerInfront() && (this.currentDetection = Stormtrooper.PLAYER_ON_FIRERANGE);
    switch (this.m_state) {
        case Stormtrooper.ST_STAND:
            this.currentDetection === Stormtrooper.PLAYER_ON_FIRERANGE && this.m_attackTimer >= this.config.shootFreq ? (this.m_attackTimer = 0, this.setState(EWebRepeaterBlaster.ST_CHARGEREPEATER, this.m_toLeft)) : this.m_attackTimer += a;
            break;
        case Stormtrooper.ST_ATTACKIDLE:
            this.m_betweenBulletsTimer +=
                a, this.m_betweenBulletsTimer >= this.config.timeBetweenBullets && this.setState(Stormtrooper.ST_ATTACK, this.m_toLeft)
    }
};
EWebRepeaterBlaster.prototype.update = function(a) {
    BaseEnemy.prototype.update.call(this, a);
    this.m_world.m_player.isPlaying && (PlayerSettings.instance.isInLiberation || this.updateStates(a))
};
EWebRepeaterBlaster.prototype.onExpel = function() {
    this.onHit(100)
};
EWebRepeaterBlaster.prototype.gotoState = function(a) {
    Stormtrooper.prototype.gotoState.call(this, a);
    if (this.m_state === BaseEnemy.ST_DIE) {
        a = this.m_x + 100 * (this.m_toLeft ? -1 : 1);
        var b = this.m_y - 85;
        this.m_world.createEffect("aniFxEnemyExplote", a, b);
        Application.instance.playSound("SND_ENEMY_EXPLOSION");
        Global.game.createExplotionShader(a - this.m_world.m_camera.m_x, b - this.m_world.m_camera.m_y, 5)
    }
};
EWebRepeaterBlaster.prototype.canFlip = function() {
    if (this.isPlayerInfront()) return !1;
    for (var a = this.m_x + 100 * (this.m_toLeft ? -1 : 1), b = this.m_y - 80, c = 0, d = null; !d && c <= this.config.bulletMaxDistance;) d = this.m_world.getCellInPosition(a, b), a += this.m_toLeft ? -10 : 10, c += 10;
    return c >= this.config.bulletMaxDistance / 2 ? !0 : d ? !1 : !0
};
EWebRepeaterBlaster.prototype.flipX = function() {
    this.m_toLeft = !this.m_toLeft;
    this.setFlipX(this.m_toLeft)
};
EWebRepeaterBlaster.prototype.raycastBehind = function() {
    for (var a = 0, b = this.m_x, c = this.m_y, d = null; !d || a >= this.config.bulletMaxDistance;) d = this.m_world.getCellInPosition(b, c), b += this.m_toLeft ? -25 : 25, a += 25;
    return a
};
EWebRepeaterBlaster.prototype.createBullet = function() {
    Application.instance.playSound(this.unitSounds.soundIds[Stormtrooper.ST_ATTACK]);
    var a = this.m_x + 177 * (this.m_toLeft ? -1 : 1),
        b = this.m_y - 85,
        c = this.m_toLeft ? 3.14 : 0,
        c = c + (.5 < Math.random() ? .05 * Math.random() : .05 * -Math.random());
    this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_ENEMY, Bullet.NAME_SKIN_BULLET_ENEMY, a, b, this.config.bulletMaxDistance, c, this.config.bulletSpeed, this.config.bulletDamage, Bullet.FX_IMPACT_LASER_ENEMY);
    this.m_world.createEffect("aniFxShootEnemy",
        a, b)
};

function Mandalorian(a, b, c) {
    this.m_bulletDamage = this.m_damage = 10;
    this.m_bulletSpeed = .5;
    this.m_bulletMaxDistance = 600;
    this.m_rangeDetection = 0;
    this.speed = {
        x: 0,
        y: 0
    };
    this.oldSpeedX = 0;
    this.hoverGoal = {
        x: 0,
        y: 0
    };
    this.flightGoal = {
        x: 0,
        y: 0
    };
    this.fallGoal = {
        x: 0,
        y: 0
    };
    this.m_character = null;
    this.bulletsInARow = this.m_shootAngle = 0;
    this.isHoverComplete = !0;
    this.freezePos = !1;
    this.m_move = null;
    BaseEnemy.call(this, a, b, c, null, 0);
    this.setDefaultViewLeft(!1);
    this.waveDoor = null;
    this.unitSounds = new UnitSounds("Mandalorian")
}
Application.subclass(Mandalorian, BaseEnemy);
Mandalorian.ST_APPEAR = "appear";
Mandalorian.ST_JUMP = "jump";
Mandalorian.ST_ATTACK_IDLE = "attackIdle";
Mandalorian.ST_PRE_ATTACK = "preAttack";
Mandalorian.ST_FALL = "fall";
Mandalorian.ST_HOLD = "onhold";
Mandalorian.HOVER_RIGHT = 50;
Mandalorian.HOVER_UP = 30;
Mandalorian.prototype.init = function() {
    this.m_className = "Mandalorian";
    this.m_data = Application.config.groundEnemies[3];
    this.m_health = this.m_data.health;
    this.m_bulletDamage = this.m_data.bulletDamage;
    this.m_bulletSpeed = this.m_data.bulletSpeed;
    this.m_rangeDetection = 0 < this.m_data.fireRange ? this.m_data.fireRange : 600;
    this.m_skin = "chr_mandalorian";
    this.m_character = new SimpleCharacter(this.m_x, this.m_y, this.m_canvas);
    this.m_character.addState(BaseEnemy.ST_STAND, this.m_skin + "_stand");
    this.m_character.addState(BaseEnemy.ST_HIT,
        this.m_skin + "_hit");
    this.m_character.addState(BaseEnemy.ST_DIE, this.m_skin + "_defeat");
    this.m_character.addState(Mandalorian.ST_APPEAR, this.m_skin + "_appear");
    this.m_character.addState(Mandalorian.ST_FALL, this.m_skin + "_walk");
    this.m_character.addState(Mandalorian.ST_JUMP, this.m_skin + "_jump");
    this.m_character.addState(Mandalorian.ST_PRE_ATTACK, this.m_skin + "_charging");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.m_state = Mandalorian.ST_HOLD
};
Mandalorian.prototype.onIdle = function(a) {
    BaseEnemy.prototype.onIdle.call(this, a);
    this.wave && a && this.gotoState(BaseEnemy.ST_DIE)
};
Mandalorian.prototype.gotoState = function(a) {
    if (!this.m_isInvulnerable && this.m_state !== BaseEnemy.ST_DIE) {
        if (this.unitSounds) switch (a) {
            case BaseEnemy.ST_HIT:
            case BaseEnemy.ST_DIE:
            case Mandalorian.ST_JUMP:
                this.unitSounds.playState(a)
        }
        BaseEnemy.prototype.gotoState.call(this, a)
    }
};
Mandalorian.prototype.onEndAnimation = function(a) {
    switch (a) {
        case Mandalorian.ST_APPEAR:
            this.setState(BaseEnemy.ST_STAND, this.m_world.player().m_x < this.m_x);
            this.waveDoor && this.waveDoor.startTimer();
            break;
        case Mandalorian.ST_PRE_ATTACK:
            this.setFlight(!0);
            break;
        case BaseEnemy.ST_ATTACK:
            this.bulletsInARow += 1;
            this.bulletsInARow >= this.m_data.bulletsInARow && (this.setFlight(!1), this.bulletsInARow = 0);
            break;
        case BaseEnemy.ST_DIE:
            this.wave && (this.wave.notifyKill(), this.wave = null);
            Application.instance.stopSound("SND_MANDALORIAN_LOOP");
            this.isAwaitingDelete = !0;
            break;
        case BaseEnemy.ST_HIT:
            this.gotoState(BaseEnemy.ST_STAND)
    }
};
Mandalorian.prototype.update = function(a) {
    this.isOnScreen() && (!Application.instance.isPlayingSound("SND_MANDALORIAN_LOOP") && Application.instance.isSoundOn() && this.m_state !== Mandalorian.ST_HOLD && Application.instance.playSound("SND_MANDALORIAN_LOOP"), this.m_move && (this.m_move.update(a), this.isFlightThroughWall(this.m_move.getX(), this.m_move.getY()) && (this.m_move.onFinish(), this.m_move.m_finish = !0), this.m_move.m_finish ? (this.m_move.free(), this.m_move = null) : (this.m_x = this.m_move.getX(), this.m_y = this.m_move.getY())),
        this.isHoverComplete || (this.isFlightThroughWall(this.m_x + Common.lerp(this.m_x, this.hoverGoal.x, .95, a), this.m_y + Common.lerp(this.m_y, this.hoverGoal.y, .95, a)) && (this.isHoverComplete = !0), this.doHover(a, this.m_state === BaseEnemy.ST_HIT || this.m_state === Mandalorian.ST_FALL)), this.freezePos || this.updateStates(a));
    this.m_clip && BaseEnemy.prototype.update.call(this, a)
};
Mandalorian.prototype.updateStates = function(a) {
    switch (this.m_state) {
        case Mandalorian.ST_HOLD:
            this.isPlayerInAppearRange() && this.forceAppear();
            break;
        case BaseEnemy.ST_STAND:
            this.isPlayerInRange() && this.gotoState(Mandalorian.ST_PRE_ATTACK)
    }
};
Mandalorian.prototype.isFlightThroughWall = function(a, b) {
    for (var c = [{
            x: -20,
            y: -125
        }, {
            x: 50,
            y: -125
        }, {
            x: 50,
            y: 0
        }, {
            x: -20,
            y: 0
        }], d = 0; d < c.length; d++) {
        var e = a + (this.m_toLeft ? -c[d].x : c[d].x),
            f = b + c[d].y;
        if (this.m_world.getCellInPosition(e, f) === WorldCollisionLayer.CELL_FULL || e < this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX || e > this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX + this.m_world.m_camera.fixWidthRatio || f < this.m_world.m_camera.m_y || f > this.m_world.m_camera.m_y + this.m_world.m_camera.m_height) return !0
    }
    return !1
};
Mandalorian.prototype.setFlight = function(a) {
    var b = this.m_clip.barrelPos || {
        x: 0,
        y: -60
    };
    a ? (this.flightGoal.x = this.m_world.m_player.m_x + (this.m_world.m_player.m_x < this.m_x ? -250 : 250), this.flightGoal.y = this.m_world.m_player.m_y - 30, this.m_move = new AcceleratedJump(this.m_x, this.m_y, this.flightGoal.x, this.flightGoal.y, this.flightGoal.x < this.m_x ? -.005 : .005, 200, b, 100)) : (this.flightGoal.x = this.m_x + (this.m_toLeft ? 250 : -250), this.flightGoal.y = this.m_y - 200, this.m_move = new AcceleratedJump(this.m_x, this.m_y, this.flightGoal.x,
        this.flightGoal.y, this.m_toLeft ? .005 : -.005, 100, b, 100));
    this.setState(Mandalorian.ST_JUMP, this.m_world.m_player.m_x < this.m_x);
    if (this.m_move) this.m_move.onComplete(this, this.onJumpComplete, a)
};
Mandalorian.prototype.onJumpComplete = function(a) {
    a ? (this.setHover(!1), this.getBarrelPos(), this.setLookAtLeft(this.m_world.m_player.m_x < this.m_x), this.prepareAttack()) : (this.setState(BaseEnemy.ST_STAND, this.m_world.m_player.m_x < this.m_x), this.setHover(!1))
};
Mandalorian.prototype.setHover = function(a) {
    var b = !1;
    "undefined" !== typeof a && (b = a);
    this.isHoverComplete = !1;
    this.hoverGoal.y = this.m_y - Mandalorian.HOVER_UP;
    this.hoverGoal.x = this.m_x + (this.m_world.m_player.m_x < this.m_x ? Mandalorian.HOVER_RIGHT * (b ? 2 : 1) : -Mandalorian.HOVER_RIGHT * (b ? 2 : 1))
};
Mandalorian.prototype.doHover = function(a, b) {
    if (!this.isHoverComplete) {
        this.m_x += Common.lerp(this.m_x, this.hoverGoal.x, .95, a);
        this.m_y += Common.lerp(this.m_y, this.hoverGoal.y, .95, a);
        var c = this.m_x - this.hoverGoal.x,
            c = 0 > c ? -c : c;
        if (20 >= c)
            if (b) this.gotoState(BaseEnemy.ST_STAND);
            else {
                var d = this.m_y - this.hoverGoal.y;
                20 >= c && 20 >= (0 > d ? -d : d) && (this.isHoverComplete = !0)
            }
    }
};
Mandalorian.prototype.onActionCommonExplode = function() {
    this.gotoState(BaseEnemy.ST_DIE);
    this.m_world.timerManager.removeMyTimers(this)
};
Mandalorian.prototype.onActionBasicHit = function() {
    this.gotoState(BaseEnemy.ST_HIT)
};
Mandalorian.prototype.prepareAttack = function() {
    var a = this.m_world.m_player.m_x - this.m_x,
        b = this.m_world.m_player.m_y - this.m_y,
        a = Math.acos(a / Math.sqrt(a * a + b * b)),
        a = 0 > b ? 6.28 - a : a,
        b = this.getAttackClipIndex(a);
    1 !== b && 5 !== b ? (this.m_character.addState(BaseEnemy.ST_ATTACK, "chr_mandalorian_attack" + this.getAttackClipIndex(a), [{
        caller: this,
        callback: this.shoot,
        frame: 4
    }]), this.gotoState(BaseEnemy.ST_ATTACK)) : this.gotoState(BaseEnemy.ST_STAND)
};
Mandalorian.prototype.rayCast = function(a, b, c, d, e, f) {
    c -= a;
    var g = d - b;
    d = Math.acos(c / Math.sqrt(c * c + g * g));
    d = 0 > g ? 6.28 - d : d;
    c = WorldCollisionLayer.CELL_EMPTY;
    for (g = 0; g < f && c === WorldCollisionLayer.CELL_EMPTY;) g += e, a += g * SMath.fastCos(d), b += g * SMath.fastSin(d), c = this.m_world.getCellInPosition(a, b);
    return c === WorldCollisionLayer.CELL_FULL
};
Mandalorian.prototype.getAttackClipIndex = function(a) {
    a = 180 * a / Math.PI;
    a = Math.floor((a + 22.5) / 45);
    this.m_shootAngle = .785 * a;
    var b = 0;
    switch (a) {
        case 0:
            b = 3;
            break;
        case 1:
            b = 4;
            break;
        case 2:
            b = 5;
            break;
        case 3:
            b = 4;
            break;
        case 4:
            b = 3;
            break;
        case 5:
            b = 2;
            break;
        case 6:
            b = 1;
            break;
        case 7:
            b = 2;
            break;
        case 8:
            b = 3
    }
    return b
};
Mandalorian.prototype.onHit = function(a) {
    if (this.m_state === BaseEnemy.ST_HIT && 0 !== this.m_clip.currentFrame % BaseEnemy.FRAME_CAN_HIT) return !1;
    this.m_move && (this.m_move = this.m_move.m_endCallback = null);
    this.setHover(!0);
    this.setLookAtLeft(this.m_world.m_player.m_x < this.m_x);
    this.m_health -= a;
    Application.log("MANDALORIAN HEALTH " + this.m_health);
    if (0 >= this.m_health) this.m_health = 0, this.onActionCommonExplode();
    else this.onActionBasicHit();
    return !0
};
Mandalorian.prototype.shoot = function() {
    this.unitSounds && this.unitSounds.playState(Stormtrooper.ST_ATTACK);
    var a = this.getBarrelPos();
    this.m_world.actorManager().bulletManager.create(Bullet.TYPE_ENEMY, Bullet.NAME_SKIN_BULLET_ENEMY, a.x, a.y, this.m_bulletMaxDistance, this.m_shootAngle, this.m_bulletSpeed, this.m_bulletDamage, Bullet.FX_IMPACT_LASER_ENEMY);
    this.m_world.createEffect("aniFxShootEnemy", a.x, a.y)
};
Mandalorian.prototype.onExpel = function() {
    this.onHit(this.m_health)
};
Mandalorian.prototype.forceAppear = function() {
    this.unitSounds.playState(Mandalorian.ST_APPEAR);
    this.setState(Mandalorian.ST_APPEAR, this.m_world.m_player.m_x < this.m_x)
};
Mandalorian.prototype.isPlayerInRange = function() {
    if (!this.m_world.m_player.isPlaying) return !1;
    var a = this.m_world.m_player.m_x - this.m_x,
        b = this.m_world.m_player.m_y - this.m_y,
        a = 0 > a ? -a : a,
        b = 0 > b ? -b : b,
        c = Math.acos(a / Math.sqrt(a * a + b * b)),
        c = this.getAttackClipIndex(0 > b ? 6.28 - c : c);
    return 1 !== c && 5 !== c ? a < .5 * Application.config.settings.APP_WIDTH && b < this.m_rangeDetection : !1
};
Mandalorian.prototype.getBarrelPos = function() {
    if (this.m_clip) {
        var a = this.m_clip.barrelPos || {
            x: 0,
            y: -60
        };
        return {
            x: this.m_x + (this.m_flipX ? -1 : 1) * a.x,
            y: this.m_y + a.y
        }
    }
    return null
};
Mandalorian.prototype.isOnScreen = function() {
    return this.m_x + 60 >= this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX && this.m_x - 60 <= this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX + this.m_world.m_camera.fixWidthRatio && this.m_y + 120 >= this.m_world.m_camera.m_y && this.m_y - 120 <= this.m_world.m_camera.m_y + this.m_world.m_camera.m_height
};
Mandalorian.prototype.onDebugDraw = function(a) {
    this.m_state === Mandalorian.ST_HOLD ? ContextGraphics.drawCircle(a, this.m_x - this.m_world.camera().getX() + Layout.left / Layout.scale, this.m_y - this.m_world.camera().getY(), .5 * this.m_rangeDetection, Common.COLOR_YELLOW, Common.COLOR_NONE) : ContextGraphics.drawRectangle(a, this.m_x - this.m_world.camera().getX() - Application.config.settings.APP_WIDTH + Layout.left / Layout.scale, this.m_y - this.m_world.camera().getY() - .5 * this.m_rangeDetection, 2 * Application.config.settings.APP_WIDTH,
        this.m_rangeDetection, 1, Common.COLOR_YELLOW, Common.COLOR_NONE)
};
Mandalorian.prototype.isPlayerInfront = function() {
    return this.m_toLeft ? this.m_x > this.m_world.m_player.m_x : this.m_x < this.m_world.m_player.m_x
};
Mandalorian.prototype.isPlayerInAppearRange = function() {
    return (new Vector2D(this.m_x - this.m_world.player().getX(), this.m_y - this.m_world.player().getY())).length() <= .5 * this.m_rangeDetection ? !0 : !1
};
Mandalorian.prototype.free = function() {
    BaseEnemy.prototype.free.call(this);
    this.unitSounds = this.m_character = this.m_move = null
};

function AcceleratedJump(a, b, c, d, e, f, g, h) {
    this.fallTime = this.impulseTime = this.aY = this.aX = this.m_y = this.m_x = 0;
    this.isAccelerating = !0;
    this.m_finish = !1;
    this.currentTime = 0;
    this.speed = {
        x: 0,
        y: 0
    };
    this.params = this.m_endCallback = this.caller = null;
    this.calculateParams(a, b, c, d, e, f, h)
}
AcceleratedJump.GRAVITY = .0025;
AcceleratedJump.prototype.update = function(a) {
    this.currentTime += a;
    this.isAccelerating && (this.currentTime + a > this.impulseTime ? (this.isAccelerating = !1, this.currentTime = 0) : (this.speed.x += this.aX * a, this.speed.y += this.aY * a));
    if (!this.isAccelerating)
        if (this.currentTime + a > this.fallTime) this.onFinish();
        else this.speed.y += AcceleratedJump.GRAVITY * a;
    this.m_finish || (this.m_y += this.speed.y * a, this.m_x += this.speed.x * a)
};
AcceleratedJump.prototype.onFinish = function() {
    this.m_finish = !0;
    this.m_endCallback && this.m_endCallback.call(this.caller, this.params)
};
AcceleratedJump.prototype.onComplete = function(a, b, c) {
    this.caller = a;
    this.m_endCallback = b;
    this.params = c
};
AcceleratedJump.prototype.free = function() {
    this.params = this.m_endCallback = this.caller = null
};
AcceleratedJump.prototype.getX = function() {
    return this.m_x
};
AcceleratedJump.prototype.getY = function() {
    return this.m_y
};
AcceleratedJump.prototype.calculateParams = function(a, b, c, d, e, f, g) {
    this.m_x = a;
    this.m_y = b;
    a = (c - (a + e * f * f / 2)) / (e * f);
    b = 1 / f * ((d - (b - (g || 200))) / a - AcceleratedJump.GRAVITY * a / 2);
    this.aX = e;
    this.aY = b;
    this.impulseTime = f;
    this.fallTime = a
};

function PlayerSettings() {
    PlayerSettings.instance = this;
    this.m_currentPlayer = PlayerSettings.TYPE_NONE;
    this.m_numberOfPlayers = 1;
    this.m_currentMap = "";
    this.sabotageState = ImperialMachine.ST_SABOTAGE_NONE;
    this.liberationState = ConquerBase.ST_CONQUER_NONE;
    this.doFinalCutscene = this.doUnlockNextWorld = !1;
    this.m_currentMission = this.unlockingWorld = -1;
    this.m_sabotagesDone = this.m_sabotagesRemaining = this.m_itemsInExtractionPoint = this.m_itemsRemaining = this.m_itemsInHand = 0;
    this.isInLiberation = !1;
    this.m_basesLiberated =
        this.m_basesRemaining = 0;
    this.specialTooltipshown = !1;
    this.resetTurnData(!1);
    this.resetMultiplayer();
    this.player2Played = this.player1Played = this.player2GotAntenna = this.player1GotAntenna = this.player2GotDamage = this.player1GotDamage = !1
}
PlayerSettings.instance = null;
PlayerSettings.TYPE_NONE = 0;
PlayerSettings.TYPE_EZRA = 1;
PlayerSettings.TYPE_KANAN = 2;
PlayerSettings.TYPE_SABINE = 3;
PlayerSettings.TYPE_HERA = 4;
PlayerSettings.TYPE_ZEB = 5;
PlayerSettings.TYPE_CHOPPER = 6;
PlayerSettings.prototype.resetTurnData = function(a) {
    1 < this.m_numberOfPlayers ? 1 > this.m_currentPlayerTurn ? (this.m_multiplayerGameNumber = this.m_currentPlayerTurn = 1, this.setPlayer(Global.playersForGame[this.m_currentPlayerTurn - 1])) : 1 === this.m_multiplayerGameNumber && (this.m_currentPlayerTurn = 1 === this.m_currentPlayerTurn ? 2 : 1, this.m_multiplayerGameNumber = 2, this.setPlayer(Global.playersForGame[this.m_currentPlayerTurn - 1])) : this.m_currentPlayerTurn = 1;
    a && 2 === this.m_multiplayerGameNumber || (this.m_basesLiberated =
        this.m_basesRemaining = this.m_sabotagesDone = this.m_sabotagesRemaining = this.m_itemsInExtractionPoint = this.m_itemsRemaining = this.m_itemsInHand = 0, 1 === this.m_numberOfPlayers && (this.player1Won = !1, this.damageToBossP1 = 0));
    this.isLastMultiplayerPlayer() || (this.isInLiberation = !1)
};
PlayerSettings.prototype.resetMultiplayer = function() {
    this.timerPlayer2 = this.timerPlayer1 = this.m_multiplayerGameNumber = this.m_currentPlayerTurn = 0;
    this.player2GotAntenna = this.player1GotAntenna = this.player2LoseByHealth = this.player1LoseByHealth = this.player2Played = this.player1Played = this.player2Won = this.player1Won = !1;
    this.m_sabotagesDoneCoop = this.m_sabotagesRemainingCoop = this.m_itemsRemainingCoop = this.m_itemsInHandCoop = this.basesLiberatedPlayer2 = this.basesLiberatedPlayer1 = this.sabotagesPlayer2 = this.sabotagesPlayer1 =
        this.collectedItemsPlayer2 = this.collectedItemsPlayer1 = this.damageToBossP2 = this.damageToBossP1 = 0;
    this.isInLiberation = !1
};
PlayerSettings.prototype.setCurrentTurn = function(a) {
    this.m_currentPlayerTurn = a
};
PlayerSettings.prototype.getCurrentTurn = function() {
    return this.m_currentPlayerTurn
};
PlayerSettings.prototype.isLastMultiplayerPlayer = function() {
    return this.m_multiplayerGameNumber === this.m_numberOfPlayers
};
PlayerSettings.prototype.isPlayerRange = function() {
    return this.m_currentPlayer == PlayerSettings.TYPE_SABINE || this.m_currentPlayer == PlayerSettings.TYPE_HERA || this.m_currentPlayer == PlayerSettings.TYPE_CHOPPER || this.m_currentPlayer == PlayerSettings.TYPE_ZEB
};
PlayerSettings.prototype.isPlayerMelee = function() {
    return this.m_currentPlayer == PlayerSettings.TYPE_EZRA || this.m_currentPlayer == PlayerSettings.TYPE_KANAN
};
PlayerSettings.prototype.isMultiplayer = function() {
    return 1 < this.m_numberOfPlayers
};
PlayerSettings.prototype.setCurrentMap = function(a) {
    this.m_currentMap = a
};
PlayerSettings.prototype.getCurrentMap = function() {
    return this.m_currentMap
};
PlayerSettings.prototype.setPlayer = function(a) {
    this.m_currentPlayer = a;
    Global.playerSelected = this.m_currentPlayer
};
PlayerSettings.prototype.getPlayer = function() {
    return this.m_currentPlayer
};
PlayerSettings.prototype.setNumberPlayers = function(a) {
    this.m_numberOfPlayers = a
};
PlayerSettings.prototype.getNumberPlayers = function() {
    return this.m_numberOfPlayers
};
PlayerSettings.prototype.updatePlayerState = function(a) {
    1 === this.m_currentPlayerTurn ? this.player1Won = a : this.player2Won = a
};
PlayerSettings.prototype.updatePlayerBossDamage = function(a, b) {
    1 === this.m_currentPlayerTurn ? (this.damageToBossP1 += a, this.damageToBossP1 = Math.min(this.damageToBossP1, b)) : (this.damageToBossP2 += a, this.damageToBossP2 = Math.min(this.damageToBossP2, b))
};
PlayerSettings.prototype.playerWithSecondTurn = function() {
    var a = 0;
    return a = 1 === this.m_currentPlayerTurn ? 2 === this.m_multiplayerGameNumber ? 1 : 2 : 2 === this.m_multiplayerGameNumber ? 2 : 1
};
PlayerSettings.prototype.addItemsRemaining = function(a) {
    this.m_itemsRemaining += a
};
PlayerSettings.prototype.addItemsRemainingCoop = function(a) {
    this.m_itemsRemainingCoop += a
};
PlayerSettings.prototype.getTotalItems = function() {
    return this.m_itemsRemaining + this.m_itemsInHand
};
PlayerSettings.prototype.getTotalItemsCoop = function() {
    return this.m_itemsRemainingCoop + this.m_itemsInHandCoop
};
PlayerSettings.prototype.getCollectedItems = function() {
    return this.m_itemsInHand
};
PlayerSettings.prototype.getCollectedItemsCoop = function() {
    return this.m_itemsInHandCoop
};
PlayerSettings.prototype.getBothPlayersTotalItems = function() {
    return this.getTotalItems() + this.getTotalItemsCoop()
};
PlayerSettings.prototype.getBothPlayersCollectedItems = function() {
    return this.getCollectedItems() + this.getCollectedItemsCoop()
};
PlayerSettings.prototype.obtainItem = function(a) {
    a = this.m_itemsRemaining < a ? this.m_itemsRemaining : a;
    this.m_itemsRemaining -= a;
    this.m_itemsInHand += a;
    Application.info("this.m_itemsRemaining " + this.m_itemsRemaining + " this.m_itemsInHand " + this.m_itemsInHand)
};
PlayerSettings.prototype.obtainItemCoop = function(a) {
    a = this.m_itemsRemainingCoop < a ? this.m_itemsRemainingCoop : a;
    this.m_itemsRemainingCoop -= a;
    this.m_itemsInHandCoop += a;
    Application.info("this.m_itemsRemainingCoop " + this.m_itemsRemainingCoop + " this.m_itemsInHandCoop " + this.m_itemsInHandCoop)
};
PlayerSettings.prototype.hasGrabbedAllItems = function() {
    return 0 === this.m_itemsRemaining && 0 < this.m_itemsInHand
};
PlayerSettings.prototype.hasGrabbedAllItemsCoop = function() {
    return 0 === this.m_itemsRemainingCoop && 0 < this.m_itemsInHandCoop
};
PlayerSettings.prototype.updateItemsInExtractionPoint = function() {
    this.m_itemsInExtractionPoint += this.m_itemsInHand;
    Application.info("this.m_itemsInExtractionPoint " + this.m_itemsInExtractionPoint);
    this.m_itemsInHand = 0
};
PlayerSettings.prototype.updateItemsInExtractionPointCoop = function() {
    this.m_itemsInExtractionPoint += this.m_itemsInHandCoop;
    Application.info("this.m_itemsInExtractionPoint " + this.m_itemsInExtractionPoint);
    this.m_itemsInHandCoop = 0
};
PlayerSettings.prototype.updateCollectedItems = function(a) {
    1 === this.m_currentPlayerTurn ? (this.collectedItemsPlayer1 = this.getCollectedItems(), this.timerPlayer1 = a) : (this.collectedItemsPlayer2 = this.getCollectedItems(), this.timerPlayer2 = a)
};
PlayerSettings.prototype.updateCollectedItemsCoop = function(a) {
    1 === this.m_currentPlayerTurn ? (this.collectedItemsPlayer1 = 1 === this.m_multiplayerGameNumber ? this.getCollectedItems() + this.getCollectedItemsCoop() : this.getCollectedItems() - this.collectedItemsPlayer2 + this.getCollectedItemsCoop(), this.timerPlayer1 = a) : (this.collectedItemsPlayer2 = 1 === this.m_multiplayerGameNumber ? this.getCollectedItems() + this.getCollectedItemsCoop() : this.getCollectedItems() - this.collectedItemsPlayer1 + this.getCollectedItemsCoop(),
        this.timerPlayer2 = a)
};
PlayerSettings.prototype.getRemainingObjects = function() {
    if (2 !== this.m_multiplayerGameNumber) return 0;
    var a = 0;
    return a = 1 === this.m_currentPlayerTurn ? this.collectedItemsPlayer2 : this.collectedItemsPlayer1
};
PlayerSettings.prototype.resetItems = function() {
    var a = this.m_itemsInHand;
    this.m_itemsRemaining += a;
    this.m_itemsInHand -= a;
    Application.info("resetItems---\x3e this.m_itemsRemaining " + this.m_itemsRemaining + " this.m_itemsInHand " + this.m_itemsInHand)
};
PlayerSettings.prototype.addSabotagesRemaining = function(a) {
    this.m_sabotagesRemaining += a
};
PlayerSettings.prototype.addSabotagesRemainingCoop = function(a) {
    this.m_sabotagesRemainingCoop += a
};
PlayerSettings.prototype.getTotalSabotages = function() {
    return this.m_sabotagesRemaining + this.m_sabotagesDone
};
PlayerSettings.prototype.getTotalSabotagesCoop = function() {
    return this.m_sabotagesRemainingCoop + this.m_sabotagesDoneCoop
};
PlayerSettings.prototype.getSabotagesDone = function() {
    return this.m_sabotagesDone
};
PlayerSettings.prototype.getSabotagesDoneCoop = function() {
    return this.m_sabotagesDoneCoop
};
PlayerSettings.prototype.getBothPlayersTotalSabotages = function() {
    return this.getTotalSabotages() + this.getTotalSabotagesCoop()
};
PlayerSettings.prototype.getBothPlayersSabotagesDone = function() {
    return this.getSabotagesDone() + this.getSabotagesDoneCoop()
};
PlayerSettings.prototype.doSabotage = function(a) {
    a = this.m_sabotagesRemaining < a ? this.m_sabotagesRemaining : a;
    this.m_sabotagesRemaining -= a;
    this.m_sabotagesDone += a;
    Application.info("this.m_sabotagesRemaining " + this.m_sabotagesRemaining + " this.m_sabotagesDone " + this.m_sabotagesDone)
};
PlayerSettings.prototype.doSabotageCoop = function(a) {
    a = this.m_sabotagesRemainingCoop < a ? this.m_sabotagesRemainingCoop : a;
    this.m_sabotagesRemainingCoop -= a;
    this.m_sabotagesDoneCoop += a;
    Application.info("this.m_sabotagesRemainingCoop " + this.m_sabotagesRemainingCoop + " this.m_sabotagesDoneCoop " + this.m_sabotagesDoneCoop)
};
PlayerSettings.prototype.hasSabotagedAll = function() {
    return 0 === this.m_sabotagesRemaining && 0 < this.m_sabotagesDone
};
PlayerSettings.prototype.hasSabotagedAllCoop = function() {
    return 0 === this.m_sabotagesRemainingCoop && 0 < this.m_sabotagesDoneCoop
};
PlayerSettings.prototype.updateSabotages = function(a) {
    1 === this.m_currentPlayerTurn ? (this.sabotagesPlayer1 = this.getSabotagesDone(), this.timerPlayer1 = a) : (this.sabotagesPlayer2 = this.getSabotagesDone(), this.timerPlayer2 = a)
};
PlayerSettings.prototype.updateSabotagesCoop = function(a) {
    1 === this.m_currentPlayerTurn ? (this.sabotagesPlayer1 = 1 === this.m_multiplayerGameNumber ? this.getSabotagesDone() + this.getSabotagesDoneCoop() : this.getSabotagesDone() - this.sabotagesPlayer2 + this.getSabotagesDoneCoop(), this.timerPlayer1 = a) : (this.sabotagesPlayer2 = 1 === this.m_multiplayerGameNumber ? this.getSabotagesDone() + this.getSabotagesDoneCoop() : this.getSabotagesDone() - this.sabotagesPlayer1 + this.getSabotagesDoneCoop(), this.timerPlayer2 = a)
};
PlayerSettings.prototype.addBasesRemaining = function(a) {
    this.m_basesRemaining += a
};
PlayerSettings.prototype.getTotalBases = function() {
    return this.m_basesRemaining + this.m_basesLiberated
};
PlayerSettings.prototype.getBasesLiberated = function() {
    return this.m_basesLiberated
};
PlayerSettings.prototype.resetBasesLiberated = function() {
    this.m_basesLiberated = 0
};
PlayerSettings.prototype.doLiberation = function(a) {
    a = this.m_basesRemaining < a ? this.m_basesRemaining : a;
    this.m_basesRemaining -= a;
    this.m_basesLiberated += a;
    Application.info("this.m_basesRemaining " + this.m_basesRemaining + " this.m_basesLiberated " + this.m_basesLiberated)
};
PlayerSettings.prototype.hasLiberatedAll = function() {
    return MissionManager.instance.isCooperative() ? this.m_basesLiberated === this.getTotalBases() : 0 === this.m_basesRemaining && 0 < this.m_basesLiberated
};
PlayerSettings.prototype.updateLiberatedBases = function(a) {
    1 === this.m_currentPlayerTurn ? (this.basesLiberatedPlayer1 = this.getBasesLiberated(), this.timerPlayer1 = a) : (this.basesLiberatedPlayer2 = this.getBasesLiberated(), this.timerPlayer2 = a)
};
PlayerSettings.prototype.updateLiberatedBasesCoop = function(a) {
    1 === this.m_currentPlayerTurn ? (this.basesLiberatedPlayer1 = 1 === this.m_multiplayerGameNumber ? this.getBasesLiberated() : this.getBasesLiberated() - this.basesLiberatedPlayer2, this.timerPlayer1 = a) : (this.basesLiberatedPlayer2 = 1 === this.m_multiplayerGameNumber ? this.getBasesLiberated() : this.getBasesLiberated() - this.basesLiberatedPlayer1, this.timerPlayer2 = a)
};
PlayerSettings.prototype.updateBossTime = function(a) {
    1 === this.m_currentPlayerTurn ? this.timerPlayer1 = a : this.timerPlayer2 = a
};
PlayerSettings.prototype.bulletPosition = function(a) {
    var b = new Point(0, 0);
    switch (a) {
        case PlayerSettings.TYPE_SABINE:
            b.x = 60;
            b.y = 105;
            break;
        case PlayerSettings.TYPE_HERA:
            b.x = 70;
            b.y = 110;
            break;
        case PlayerSettings.TYPE_ZEB:
            b.x = 80;
            b.y = 95;
            break;
        case PlayerSettings.TYPE_CHOPPER:
            b.x = 50 * window.config.settings.chopper_scale_override / 100, b.y = 60 * window.config.settings.chopper_scale_override / 100
    }
    return b
};
PlayerSettings.prototype.bulletPositionJump = function(a) {
    var b = new Point(0, 0);
    switch (a) {
        case PlayerSettings.TYPE_SABINE:
            b.x = 45;
            b.y = 105;
            break;
        case PlayerSettings.TYPE_HERA:
            b.x = 45;
            b.y = 105;
            break;
        case PlayerSettings.TYPE_ZEB:
            b.x = 60;
            b.y = 95;
            break;
        case PlayerSettings.TYPE_CHOPPER:
            b.x = 50, b.y = 60
    }
    return b
};
PlayerSettings.prototype.remainingItemsLessThan = function(a) {
    return MissionManager.instance.isCooperative() ? this.m_itemsRemainingCoop + this.m_itemsRemaining < a : this.m_itemsRemaining < a
};
PlayerSettings.prototype.sabotageRemainingLessThan = function(a) {
    return MissionManager.instance.isCooperative() ? this.m_sabotagesRemainingCoop + this.m_sabotagesRemaining < a : this.m_sabotagesRemaining < a
};
PlayerSettings.prototype.conquerBaseLessThan = function(a) {
    return this.m_basesRemaining < a
};
PlayerSettings.prototype.getStars = function(a, b) {
    return this.isMultiplayer() ? Global.data.data.starsMulti[4 * (a - 1) + (b - 1)] : Global.data.data.starsSingle[4 * (a - 1) + (b - 1)]
};
PlayerSettings.prototype.setStars = function(a, b, c) {
    b = this.getMapMissionIndex(b, c);
    this.isMultiplayer() ? a > Global.data.data.starsMulti[b] && (Global.data.data.starsMulti[b] = a) : a > Global.data.data.starsSingle[b] && (Global.data.data.starsSingle[b] = a);
    Global.data.save();
    this.unlockNextMap();
    this.doFinalCutscene = this.isFinalCutscene()
};
PlayerSettings.prototype.isFinalCutscene = function() {
    if (3 !== Global.level) return !1;
    var a = this.isMultiplayer() ? Global.data.data.starsMulti : Global.data.data.starsSingle;
    if ("undefined" !== typeof a) {
        for (var b = 0; 4 > b; b++)
            if (-1 === a[8 + b]) return !1;
        return !0
    }
    return !1
};
PlayerSettings.prototype.unlockNextMap = function() {
    if (3 !== Global.level) {
        var a = Global.level - 1;
        if (1 === Global.data.data.unlockPlanets[a + 1]) return this.resetUnlocking(), !1;
        for (var b = this.isMultiplayer() ? Global.data.data.starsMulti : Global.data.data.starsSingle, c = 0; 4 > c; c++)
            if (-1 === b[4 * a + c]) return this.resetUnlocking(), !1;
        this.setUnlockPlanet(a + 1);
        return !0
    }
};
PlayerSettings.prototype.setUnlockPlanet = function(a) {
    this.doUnlockNextWorld = !0;
    this.unlockingWorld = a + 1;
    Global.data.data.unlockPlanets[a] = 1;
    Global.data.save()
};
PlayerSettings.prototype.isPlanetUnlocked = function(a) {
    return MissionManager.instance.isVersus() ? !0 : 1 === Global.data.data.unlockPlanets[a - 1]
};
PlayerSettings.prototype.resetUnlocking = function() {
    this.doUnlockNextWorld = !1;
    this.unlockingWorld = -1
};
PlayerSettings.prototype.getLatestUnlocked = function() {
    for (var a = Global.data.data.unlockPlanets.length - 1; 0 <= a; a--)
        if (1 === Global.data.data.unlockPlanets[a]) return a;
    return 0
};
PlayerSettings.prototype.getMapMissionIndex = function(a, b) {
    return 4 * (a - 1) + (b / 100 - 1)
};
PlayerSettings.prototype.isFirstPlay = function() {
    return 0 === Global.data.data.tutorial
};
PlayerSettings.prototype.checkAchievement = function() {
    for (var a = [], b = 1; 9 >= b; b++) Global.data.dataArcade.trophies["trophy" + b].achieved || a.push(b);
    for (var c = 0; c < a.length; c++) {
        switch (a[c]) {
            case 1:
                for (var d = 0, b = 0; b < Global.data.data.starsMulti.length && !(-1 !== Global.data.data.starsMulti[b] && (d += 1, 4 <= d)); b++);
                4 <= d && (GuiGame.instance.addAchievPopup(1), Global.data.dataArcade.trophies.trophy1.achieved = !0);
                break;
            case 2:
                d = !0;
                for (b = 0; b < Global.data.data.usedCharacters.length; b++) 0 === Global.data.data.usedCharacters[b] &&
                    (d = !1);
                d && (GuiGame.instance.addAchievPopup(2), Global.data.dataArcade.trophies.trophy2.achieved = !0);
                break;
            case 3:
                d = !0;
                for (b = 0; 3 > b; b++)
                    if (-1 === Global.data.data.starsMulti[4 * b + 3] && -1 === Global.data.data.starsSingle[4 * b + 3]) {
                        d = !1;
                        break
                    }
                d && (GuiGame.instance.addAchievPopup(3), Global.data.dataArcade.trophies.trophy3.achieved = !0);
                break;
            case 5:
                b = !0;
                3 !== Global.data.data.starsMulti[11] && 3 !== Global.data.data.starsSingle[11] && (b = !1);
                b && (GuiGame.instance.addAchievPopup(5), Global.data.dataArcade.trophies.trophy5.achieved = !0);
                break;
            case 6:
                for (b = 0; 3 > b; b++) {
                    for (var e = d = 0, f = 0; 4 > f; f++) 3 === Global.data.data.starsSingle[4 * b + f] && d++, 3 === Global.data.data.starsMulti[4 * b + f] && e++;
                    if (4 === e || 4 === d) {
                        GuiGame.instance.addAchievPopup(6);
                        Global.data.dataArcade.trophies.trophy6.achieved = !0;
                        break
                    }
                }
                break;
            case 7:
                d = !0;
                for (b = 0; b < Global.data.data.starsMulti.length; b++)
                    if (-1 === Global.data.data.starsMulti[b]) {
                        d = !1;
                        break
                    }
                d && (GuiGame.instance.addAchievPopup(7), Global.data.dataArcade.trophies.trophy7.achieved = !0);
                break;
            case 9:
                d = !0;
                for (b = 0; 12 > b; b++)
                    if (3 !==
                        Global.data.data.starsMulti[b] && 3 !== Global.data.data.starsSingle[b]) {
                        d = !1;
                        break
                    }
                d && (GuiGame.instance.addAchievPopup(9), Global.data.dataArcade.trophies.trophy9.achieved = !0)
        }
        Global.data.save()
    }
};
PlayerSettings.prototype.setUsedCharacter = function(a) {
    Global.data.data.usedCharacters[a] = 1;
    Global.data.save()
};
PlayerSettings.prototype.setUsedPowerUp = function(a) {
    1 !== Global.data.data.usedPowerups[a] && (Global.data.data.usedPowerups[a] = 1, Global.data.save())
};
PlayerSettings.prototype.checkPowerUpAchievement = function() {
    if (!Global.data.dataArcade.trophies.trophy4.achieved) {
        for (var a = !0, b = 0; b < Global.data.data.usedPowerups.length; b++)
            if (1 !== Global.data.data.usedPowerups[b]) {
                a = !1;
                break
            }
        a && (GuiGame.instance.addAchievPopup(4), Global.data.dataArcade.trophies.trophy4.achieved = !0);
        Global.data.save()
    }
};
PlayerSettings.prototype.calculateScore = function() {
    var a = MissionManager.instance.getMissionId();
    this.m_currentMission = Settings.instance.getMission(a);
    var b = 0,
        c = 0,
        d = 0,
        e = 0,
        f = 0,
        g = 0,
        a = !1,
        h = PlayerSettings.instance.timerPlayer1,
        k = PlayerSettings.instance.timerPlayer2;
    MissionManager.instance.isCooperative() && (h = k = .5 * (h + k));
    var m = 0,
        h = this.getTimerScore(h),
        l = m = 0,
        k = this.getTimerScore(k),
        l = 0;
    MissionManager.instance.isCooperative() ? (this.player1Played || (k += h, m = h = 0), this.player2Played || (h += k, l = k = 0)) : (h = PlayerSettings.instance.player1Won ?
        h : 0, k = PlayerSettings.instance.player2Won ? k : 0);
    var p = 0,
        q = 0,
        n = {
            firstPlaceId: 0,
            timeFirstPlace: 0,
            secondPlaceId: 0,
            timeSecondPlace: 0,
            scoreFirstPlace: 0,
            scoreSecondPlace: 0,
            itemsPlayer01: 0,
            itemsPlayer02: 0
        };
    switch (MissionManager.instance.getMissionType()) {
        case MissionManager.MISSION_COLLECTION:
            m = PlayerSettings.instance.collectedItemsPlayer1 * this.m_currentMission.pointsObtainedPerObject;
            l = PlayerSettings.instance.collectedItemsPlayer2 * this.m_currentMission.pointsObtainedPerObject;
            m += h;
            l += k;
            m === l && MissionManager.instance.isVersus() &&
                (Math.floor(PlayerSettings.instance.timerPlayer1 / 1E3) === Math.floor(PlayerSettings.instance.timerPlayer2 / 1E3) ? a = !0 : (PlayerSettings.instance.timerPlayer1 < PlayerSettings.instance.timerPlayer2 && (m += 200), PlayerSettings.instance.timerPlayer2 < PlayerSettings.instance.timerPlayer1 && (l += 200)));
            this.setParams(m, l, n, PlayerSettings.instance.collectedItemsPlayer1, PlayerSettings.instance.collectedItemsPlayer2);
            b = n.firstPlaceId;
            c = n.timeFirstPlace;
            d = n.secondPlaceId;
            e = n.timeSecondPlace;
            f = n.scoreFirstPlace;
            g = n.scoreSecondPlace;
            p = n.itemsPlayer01;
            q = n.itemsPlayer02;
            break;
        case MissionManager.MISSION_LIBERATION:
            m = PlayerSettings.instance.basesLiberatedPlayer1 * this.m_currentMission.pointsObtainedPerObject;
            l = PlayerSettings.instance.basesLiberatedPlayer2 * this.m_currentMission.pointsObtainedPerObject;
            m += h;
            l += k;
            m === l && MissionManager.instance.isVersus() && (Math.floor(PlayerSettings.instance.timerPlayer1 / 1E3) === Math.floor(PlayerSettings.instance.timerPlayer2 / 1E3) ? a = !0 : (PlayerSettings.instance.timerPlayer1 < PlayerSettings.instance.timerPlayer2 &&
                (m += 200), PlayerSettings.instance.timerPlayer2 < PlayerSettings.instance.timerPlayer1 && (l += 200)));
            this.setParams(m, l, n, PlayerSettings.instance.basesLiberatedPlayer1, PlayerSettings.instance.basesLiberatedPlayer2);
            b = n.firstPlaceId;
            c = n.timeFirstPlace;
            d = n.secondPlaceId;
            e = n.timeSecondPlace;
            f = n.scoreFirstPlace;
            g = n.scoreSecondPlace;
            p = n.itemsPlayer01;
            q = n.itemsPlayer02;
            break;
        case MissionManager.MISSION_SABOTAGE:
            m = PlayerSettings.instance.sabotagesPlayer1 * this.m_currentMission.pointsObtainedPerObject + (PlayerSettings.instance.player1GotAntenna ?
                4 * this.m_currentMission.pointsObtainedPerObject : 0);
            l = PlayerSettings.instance.sabotagesPlayer2 * this.m_currentMission.pointsObtainedPerObject + (PlayerSettings.instance.player2GotAntenna ? 4 * this.m_currentMission.pointsObtainedPerObject : 0);
            m += h;
            l += k;
            m === l && MissionManager.instance.isVersus() && (Math.floor(PlayerSettings.instance.timerPlayer1 / 1E3) === Math.floor(PlayerSettings.instance.timerPlayer2 / 1E3) ? a = !0 : (PlayerSettings.instance.timerPlayer1 < PlayerSettings.instance.timerPlayer2 && (m += 200), PlayerSettings.instance.timerPlayer2 <
                PlayerSettings.instance.timerPlayer1 && (l += 200)));
            this.setParams(m, l, n, PlayerSettings.instance.sabotagesPlayer1, PlayerSettings.instance.sabotagesPlayer2);
            b = n.firstPlaceId;
            c = n.timeFirstPlace;
            d = n.secondPlaceId;
            e = n.timeSecondPlace;
            f = n.scoreFirstPlace;
            g = n.scoreSecondPlace;
            p = n.itemsPlayer01;
            q = n.itemsPlayer02;
            break;
        case MissionManager.MISSION_BOSS_BATTLE:
            var s = "",
                r = 0;
            switch (Global.level) {
                case 1:
                    s = "atdp";
                    break;
                case 2:
                    s = "atat";
                    break;
                case 3:
                    s = "tie_fighter"
            }
            switch (MissionManager.instance.getGameMode()) {
                case MissionManager.GAME_SINGLEPLAYER:
                    r =
                        Application.config[s].initHealth;
                    break;
                case MissionManager.GAME_COOPERATIVE:
                    r = Application.config[s].initHealthCoop;
                    break;
                case MissionManager.GAME_VERSUS:
                    r = Application.config[s].initHealthVS
            }
            m = Math.round(PlayerSettings.instance.damageToBossP1 / r * this.m_currentMission.pointsObtainedPerObject);
            l = Math.round(PlayerSettings.instance.damageToBossP2 / r * this.m_currentMission.pointsObtainedPerObject);
            m += h;
            l += k;
            m === l && MissionManager.instance.isVersus() && (Math.floor(PlayerSettings.instance.timerPlayer1 / 1E3) ===
                Math.floor(PlayerSettings.instance.timerPlayer2 / 1E3) ? a = !0 : (PlayerSettings.instance.timerPlayer1 < PlayerSettings.instance.timerPlayer2 && (m += 200), PlayerSettings.instance.timerPlayer2 < PlayerSettings.instance.timerPlayer1 && (l += 200)));
            this.setParams(m, l, n, PlayerSettings.instance.damageToBossP1, PlayerSettings.instance.damageToBossP2);
            var b = n.firstPlaceId,
                c = n.timeFirstPlace,
                d = n.secondPlaceId,
                e = n.timeSecondPlace,
                f = n.scoreFirstPlace,
                g = n.scoreSecondPlace,
                p = n.itemsPlayer01,
                q = n.itemsPlayer02,
                s = Math.min(Math.round(100 *
                    p / r), 100),
                t = Math.min(Math.round(100 * q / r), 100),
                u = Math.ceil(99 * p / r) + 1,
                r = Math.ceil(99 * q / r) + 1
    }
    return {
        m_currentMission: this.m_currentMission,
        scoreTotal1: m,
        scoreTotal2: l,
        isDraw: a,
        firstPlaceId: b,
        timeFirstPlace: c,
        secondPlaceId: d,
        timeSecondPlace: e,
        scoreFirstPlace: f,
        scoreSecondPlace: g,
        itemsPlayer01: p,
        itemsPlayer02: q,
        percent1: s,
        percent2: t,
        frame1: u,
        frame2: r
    }
};
PlayerSettings.prototype.getTimerScore = function(a) {
    var b = 0;
    MissionManager.instance.isVersus() ? (b = this.m_currentMission.timeForPointsVS - this.m_currentMission.timeForMaxPointsVS, a <= this.m_currentMission.timeForMaxPointsVS ? b = this.m_currentMission.maxPointsTimer : a > this.m_currentMission.timeForPointsVS ? b = 0 : (b = (this.m_currentMission.timeForPointsVS - a) / b * this.m_currentMission.maxPointsTimer, b = Math.floor(b))) : (b = this.m_currentMission.timeForPointsCoop - this.m_currentMission.timeForMaxPointsCoop, a <= this.m_currentMission.timeForMaxPointsCoop ?
        b = this.m_currentMission.maxPointsTimer : a > this.m_currentMission.timeForPointsCoop ? b = 0 : (b = (this.m_currentMission.timeForPointsCoop - a) / b * this.m_currentMission.maxPointsTimer, b = Math.floor(b)));
    return b
};
PlayerSettings.prototype.setParams = function(a, b, c, d, e) {
    a > b ? (c.itemsPlayer01 = d, c.itemsPlayer02 = e, c.firstPlaceId = 1, c.timeFirstPlace = PlayerSettings.instance.timerPlayer1, c.secondPlaceId = 2, c.timeSecondPlace = PlayerSettings.instance.timerPlayer2, c.scoreFirstPlace = a, c.scoreSecondPlace = b) : a < b ? (c.itemsPlayer01 = e, c.itemsPlayer02 = d, c.firstPlaceId = 2, c.timeFirstPlace = PlayerSettings.instance.timerPlayer2, c.secondPlaceId = 1, c.timeSecondPlace = PlayerSettings.instance.timerPlayer1, c.scoreFirstPlace = b, c.scoreSecondPlace =
        a) : PlayerSettings.instance.timerPlayer1 <= PlayerSettings.instance.timerPlayer2 ? (c.itemsPlayer01 = d, c.itemsPlayer02 = e, c.firstPlaceId = 1, c.timeFirstPlace = PlayerSettings.instance.timerPlayer1, c.secondPlaceId = 2, c.timeSecondPlace = PlayerSettings.instance.timerPlayer2, c.scoreFirstPlace = a, c.scoreSecondPlace = b) : (c.itemsPlayer01 = e, c.itemsPlayer02 = d, c.firstPlaceId = 2, c.timeFirstPlace = PlayerSettings.instance.timerPlayer2, c.secondPlaceId = 1, c.timeSecondPlace = PlayerSettings.instance.timerPlayer1, c.scoreFirstPlace = b,
        c.scoreSecondPlace = a)
};

function MissionManager() {
    MissionManager.instance = this;
    this.m_gameMode = MissionManager.GAME_NONE;
    this.m_missionType = MissionManager.MISSION_NONE;
    this.m_missionId = ""
}
MissionManager.instance = null;
MissionManager.GAME_NONE = 0;
MissionManager.GAME_SINGLEPLAYER = 500;
MissionManager.GAME_COOPERATIVE = 200;
MissionManager.GAME_VERSUS = 300;
MissionManager.MISSION_NONE = 0;
MissionManager.MISSION_TUTORIAL = 10;
MissionManager.MISSION_COLLECTION = 100;
MissionManager.MISSION_LIBERATION = 200;
MissionManager.MISSION_SABOTAGE = 300;
MissionManager.MISSION_BOSS_BATTLE = 400;
MissionManager.prototype.setGameMode = function(a) {
    this.m_gameMode = a
};
MissionManager.prototype.getGameMode = function() {
    return this.m_gameMode
};
MissionManager.prototype.isSinglePlayer = function() {
    return this.m_gameMode === MissionManager.GAME_SINGLEPLAYER
};
MissionManager.prototype.isCooperative = function() {
    return this.m_gameMode === MissionManager.GAME_COOPERATIVE
};
MissionManager.prototype.isVersus = function() {
    return this.m_gameMode === MissionManager.GAME_VERSUS
};
MissionManager.prototype.setMissionType = function(a) {
    return this.m_missionType = a
};
MissionManager.prototype.getMissionType = function() {
    return this.m_missionType
};
MissionManager.prototype.setMissionId = function(a) {
    return this.m_missionId = a
};
MissionManager.prototype.getMissionId = function() {
    return this.m_missionId
};
MissionManager.prototype.isMissionTutorial = function() {
    return this.m_missionType === MissionManager.MISSION_TUTORIAL
};
MissionManager.prototype.isMissionCollection = function() {
    return this.m_missionType === MissionManager.MISSION_COLLECTION
};
MissionManager.prototype.isMissionLiberation = function() {
    return this.m_missionType === MissionManager.MISSION_LIBERATION
};
MissionManager.prototype.isMissionSabotage = function() {
    return this.m_missionType === MissionManager.MISSION_SABOTAGE
};
MissionManager.prototype.isMissionBossBattle = function() {
    return this.m_missionType === MissionManager.MISSION_BOSS_BATTLE
};
MissionManager.prototype.isMissionRequirementComplete = function() {
    switch (this.m_missionType) {
        case MissionManager.MISSION_COLLECTION:
            return this.isCooperative() ? PlayerSettings.instance.hasGrabbedAllItems() && PlayerSettings.instance.hasGrabbedAllItemsCoop() : PlayerSettings.instance.hasGrabbedAllItems();
        case MissionManager.MISSION_LIBERATION:
            return PlayerSettings.instance.hasLiberatedAll();
        case MissionManager.MISSION_SABOTAGE:
            return this.isCooperative() ? PlayerSettings.instance.hasSabotagedAll() && PlayerSettings.instance.hasSabotagedAllCoop() &&
                (PlatformGame.instance.world.m_actorManager.m_antenna && PlatformGame.instance.world.m_actorManager.m_antenna.isAwaitingDelete || !PlatformGame.instance.world.m_actorManager.m_antenna) : PlayerSettings.instance.hasSabotagedAll() && (PlatformGame.instance.world.m_actorManager.m_antenna && PlatformGame.instance.world.m_actorManager.m_antenna.isAwaitingDelete || !PlatformGame.instance.world.m_actorManager.m_antenna);
        case MissionManager.MISSION_BOSS_BATTLE:
            switch (Global.level) {
                case 1:
                    if (!Atdp.instance || Atdp.instance.m_state ===
                        Atdp.ST_DIE) return !0;
                    break;
                case 2:
                    if (!HeadAtat.instance || HeadAtat.instance.m_state === HeadAtat.ST_DEFEAT) return !0;
                    break;
                case 3:
                    if (!TIEFighter.instance || TIEFighter.instance.m_state === TIEFighter.ST_DIE) return !0
            }
    }
    return !1
};
MissionManager.prototype.free = function() {
    MissionManager.instance = null
};

function GunWeapon(a) {
    this.player = a;
    this.gun = 0;
    this.clip = this.data = null;
    this.nameClipBullet = "";
    this["clipGun" + GunWeapon.GUN_BASIC] = Application.instance.getClip("mcGun" + (PlayerSettings.instance.m_currentPlayer === PlayerSettings.TYPE_HERA ? "Hera" : "Sabine"));
    this["clipGun" + GunWeapon.GUN_MULTI] = Application.instance.getClip("mcGun" + (PlayerSettings.instance.m_currentPlayer === PlayerSettings.TYPE_HERA ? "Hera" : "Sabine"));
    this["clipGun" + GunWeapon.GUN_EXPLOSIVE] = Application.instance.getClip("mcGun" + (PlayerSettings.instance.m_currentPlayer ===
        PlayerSettings.TYPE_HERA ? "Hera" : "Sabine"));
    this.angles = {};
    this.angles["gun" + GunWeapon.GUN_BASIC] = [0];
    this.angles["gun" + GunWeapon.GUN_MULTI] = [Common.gradToRadian(340), 0, Common.gradToRadian(20)];
    this.angles["gun" + GunWeapon.GUN_EXPLOSIVE] = [0];
    this.bulletSubType = 0;
    this.bulletFxImpactName = "";
    this.setGun(GunWeapon.GUN_BASIC);
    this.useCounter = 0
}
GunWeapon.GUN_BASIC = 0;
GunWeapon.GUN_MULTI = 1;
GunWeapon.GUN_EXPLOSIVE = 2;
GunWeapon.NAME_FX_SHOOT_LASER = "aniFxShootPlayer";
GunWeapon.prototype.setGun = function(a, b) {
    this.gun = a;
    this.clip = this["clipGun" + this.gun];
    this.data = window.config.weapons[this.gun];
    this.useCounter = b || 999999999;
    this.nameClipBullet = this.data.clipBullet;
    switch (this.gun) {
        case GunWeapon.GUN_BASIC:
        case GunWeapon.GUN_MULTI:
            this.bulletSubType = Bullet.SUB_TYPE_PLAYER_LASER;
            this.bulletFxImpactName = Bullet.FX_IMPACT_LASER_PLAYER;
            break;
        case GunWeapon.GUN_EXPLOSIVE:
            this.bulletSubType = Bullet.SUB_TYPE_PLAYER_EXPLOSIVE, this.bulletFxImpactName = Bullet.FX_IMPACT_EXPLOSIVE
    }
    Global.playerSelected ===
        PlayerSettings.TYPE_CHOPPER && (this.nameClipBullet = "aniFxChopperPlayerBasicAttack", this.bulletSubType = this.gun === GunWeapon.GUN_EXPLOSIVE ? Bullet.SUB_TYPE_PLAYER_ELECTRICITY_EXPLOSIVE : Bullet.SUB_TYPE_PLAYER_ELECTRICITY, this.bulletFxImpactName = this.gun === GunWeapon.GUN_EXPLOSIVE ? Bullet.FX_IMPACT_EXPLOSIVE : Bullet.FX_IMPACT_ELECTRICITY);
    this.player.updateGunClip()
};
GunWeapon.prototype.clearGunClips = function() {
    for (var a = 0; 3 > a; a++) this["clipGun" + a].parent && this["clipGun" + a].parent.removeChild(this["clipGun" + a])
};
GunWeapon.prototype.shoot = function(a, b, c) {
    var d = 0;
    this.gun === GunWeapon.GUN_EXPLOSIVE ? Application.instance.playSound("SND_PLAYER_HERA_SHOTGUN") : this.player.unitSounds.playState(PlayerPlatform.ST_PLAYER_SHOOT);
    for (var e = 0; e < this.angles["gun" + this.gun].length; e++) d = this.angles["gun" + this.gun][e] + (.5 < Math.random() ? .05 * Math.random() : .05 * -Math.random()), this.player.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_PLAYER, this.nameClipBullet, a, b, this.data.range, d + (c ? 3.14159 : 0), this.data.speed, this.data.damage,
        this.bulletFxImpactName, this.bulletSubType);
    Global.playerSelected !== PlayerSettings.TYPE_CHOPPER && this.player.m_world.createEffect(GunWeapon.NAME_FX_SHOOT_LASER, a, b);
    this.gun === GunWeapon.GUN_BASIC && this.useCounter--
};
GunWeapon.prototype.free = function() {
    this.data = null
};

function PlayerEzra(a, b, c, d, e) {
    PlayerPlatform.call(this, a, b, c, d, e);
    this.unitSounds = new UnitSounds("Ezra");
    this.m_control = new PlayerControl(this, window[e].playerEzra);
    this.m_skinBase = this.data.skinBase;
    this.m_control.activeDoubleJump(!0);
    this.m_character = new SimpleCharacter(c, d, this.m_canvas);
    this.m_character.addState(Player.ST_PLAYER_STAND, this.m_skinBase + "_stand");
    this.m_character.addState(Player.ST_PLAYER_JUMP_UP, this.m_skinBase + "_jump_up");
    this.m_character.addState(Player.ST_PLAYER_JUMP_DOWN, this.m_skinBase +
        "_jump");
    this.m_character.addState(Player.ST_PLAYER_JUMP_SPECIAL, this.m_skinBase + "_jump2");
    this.m_character.addState(Player.ST_PLAYER_WALK, this.m_skinBase + "_run");
    this.m_character.addState(Player.ST_PLAYER_HIT, this.m_skinBase + "_hit");
    this.m_character.addState(Player.ST_PLAYER_LOSE, this.m_skinBase + "_defeat");
    this.m_character.addState(Player.ST_PLAYER_WIN, this.m_skinBase + "_outro", [{
        caller: this,
        callback: this.playExtraction,
        frame: 50
    }]);
    this.m_character.addState(Player.ST_PLAYER_LAND, this.m_skinBase + "_jump_ground");
    this.m_character.addState(Player.ST_PLAYER_CELEBRATE, this.m_skinBase + "_win");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.gotoState(Player.ST_PLAYER_STAND);
    this.createCorners();
    this.oldFrame = -1;
    this.shootSelect = 1;
    this.anglesSpecialShoot1 = [];
    this.anglesSpecialShoot2 = [];
    a = 0;
    b = Common.gradToRadian(15);
    c = Common.gradToRadian(0);
    for (a = 0; 7 > a; a++) this.anglesSpecialShoot1.push(b - Common.gradToRadian(35 * a)), this.anglesSpecialShoot2.push(c - Common.gradToRadian(30 * a))
}
Application.subclass(PlayerEzra, PlayerPlatform);
PlayerEzra.prototype.free = function() {
    PlayerPlatform.prototype.free.call(this)
};
PlayerEzra.prototype.update = function(a) {
    PlayerPlatform.prototype.update.call(this, a);
    this.clipSpecialAttack && 20 <= this.clipSpecialAttack.currentFrame && 60 >= this.clipSpecialAttack.currentFrame && this.oldFrame !== this.clipSpecialAttack.currentFrame && (this.oldFrame = this.clipSpecialAttack.currentFrame, 0 == this.clipSpecialAttack.currentFrame % 10 && this.shootSpecial(this.m_x, this.m_y - 80))
};
PlayerEzra.prototype.setFlipX = function(a) {
    this.m_skinBase_orientation = (this.m_flipX = a) ? "_b" : "";
    a = this.m_clip.currentFrame;
    this.m_character.addState(Player.ST_PLAYER_STAND, this.m_skinBase + "_stand" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_UP, this.m_skinBase + "_jump_up" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_DOWN, this.m_skinBase + "_jump" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_SPECIAL, this.m_skinBase +
        "_jump2" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_WALK, this.m_skinBase + "_run" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_HIT, this.m_skinBase + "_hit" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_LOSE, this.m_skinBase + "_defeat" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_WIN, this.m_skinBase + "_outro" + this.m_skinBase_orientation, [{
        caller: this,
        callback: this.playExtraction,
        frame: 50
    }]);
    this.m_character.addState(Player.ST_PLAYER_LAND,
        this.m_skinBase + "_jump_ground" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_CELEBRATE, this.m_skinBase + "_win" + this.m_skinBase_orientation);
    this.m_character.gotoState(this.m_state);
    this.m_clip = this.m_character.clip;
    this.m_clip.scale.x = this.m_scaleX;
    this.m_clip.scale.y = this.m_scaleY;
    this.m_clip.gotoAndPlay(a)
};
PlayerEzra.prototype.shootSpecial = function(a, b) {
    this.shootSelect = 1 === this.shootSelect ? 2 : 1;
    for (var c = 1 === this.shootSelect ? this.anglesSpecialShoot1 : this.anglesSpecialShoot2, d = 0, e = 0, f = 0, g = 0; g < c.length; g++) f = c[g] + (.5 < Math.random() ? Math.random() * (1 === this.shootSelect ? Common.gradToRadian(18) : Common.gradToRadian(14)) : -Math.random() * (1 === this.shootSelect ? Common.gradToRadian(18) : Common.gradToRadian(14))), d = 90 * Math.cos(f), e = 90 * Math.sin(f), this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_PLAYER,
        "mcBulletPlayer", a + d, b + e, 800, f, 1, 50, Bullet.FX_IMPACT_LASER_PLAYER, Bullet.SUB_TYPE_PLAYER_LASER), 0 === g % 2 && this.m_world.createEffect(GunWeapon.NAME_FX_SHOOT_LASER, a + d, b + e)
};

function PlayerKanan(a, b, c, d, e) {
    PlayerPlatform.call(this, a, b, c, d, e);
    this.unitSounds = new UnitSounds("Kanan");
    this.m_control = new PlayerControl(this, window[e].playerKanan);
    this.m_skinBase = this.data.skinBase;
    this.m_control.activeDoubleJump(!0);
    this.m_character = new SimpleCharacter(c, d, this.m_canvas);
    this.m_character.addState(Player.ST_PLAYER_STAND, this.m_skinBase + "_stand");
    this.m_character.addState(Player.ST_PLAYER_JUMP_UP, this.m_skinBase + "_jump_up");
    this.m_character.addState(Player.ST_PLAYER_JUMP_DOWN,
        this.m_skinBase + "_jump");
    this.m_character.addState(Player.ST_PLAYER_JUMP_SPECIAL, this.m_skinBase + "_jump2");
    this.m_character.addState(Player.ST_PLAYER_WALK, this.m_skinBase + "_run");
    this.m_character.addState(Player.ST_PLAYER_HIT, this.m_skinBase + "_hit");
    this.m_character.addState(Player.ST_PLAYER_LOSE, this.m_skinBase + "_defeat");
    this.m_character.addState(Player.ST_PLAYER_WIN, this.m_skinBase + "_outro", [{
        caller: this,
        callback: this.playExtraction,
        frame: 50
    }]);
    this.m_character.addState(Player.ST_PLAYER_LAND, this.m_skinBase +
        "_jump_ground");
    this.m_character.addState(Player.ST_PLAYER_CELEBRATE, this.m_skinBase + "_win");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.gotoState(Player.ST_PLAYER_STAND);
    this.createCorners()
}
Application.subclass(PlayerKanan, PlayerPlatform);
PlayerKanan.prototype.free = function() {
    PlayerPlatform.prototype.free.call(this)
};
PlayerKanan.prototype.update = function(a) {
    PlayerPlatform.prototype.update.call(this, a);
    if (this.clipSpecialAttack && (35 == this.clipSpecialAttack.currentFrame && Global.game.createExplotionShader(this.m_x - this.m_world.m_camera.m_x, this.m_y - this.m_world.m_camera.m_y, 12), 45 == this.clipSpecialAttack.currentFrame && Global.game.createExplotionShader(this.m_x - this.m_world.m_camera.m_x, this.m_y - this.m_world.m_camera.m_y, 12), 25 == this.clipSpecialAttack.currentFrame)) Global.game.onShake(10, 10, 1E3)
};
PlayerKanan.prototype.setFlipX = function(a) {
    this.m_skinBase_orientation = (this.m_flipX = a) ? "_b" : "";
    a = this.m_clip.currentFrame;
    this.m_character.addState(Player.ST_PLAYER_STAND, this.m_skinBase + "_stand" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_UP, this.m_skinBase + "_jump_up" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_DOWN, this.m_skinBase + "_jump" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_SPECIAL, this.m_skinBase +
        "_jump2" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_WALK, this.m_skinBase + "_run" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_HIT, this.m_skinBase + "_hit" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_LOSE, this.m_skinBase + "_defeat" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_WIN, this.m_skinBase + "_outro" + this.m_skinBase_orientation, [{
        caller: this,
        callback: this.playExtraction,
        frame: 50
    }]);
    this.m_character.addState(Player.ST_PLAYER_LAND,
        this.m_skinBase + "_jump_ground" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_CELEBRATE, this.m_skinBase + "_win" + this.m_skinBase_orientation);
    this.m_character.gotoState(this.m_state);
    this.m_clip = this.m_character.clip;
    this.m_clip.scale.x = this.m_scaleX;
    this.m_clip.scale.y = this.m_scaleY;
    this.m_clip.gotoAndPlay(a)
};

function PlayerSabine(a, b, c, d, e) {
    PlayerPlatform.call(this, a, b, c, d, e);
    this.unitSounds = new UnitSounds("Sabine");
    this.m_control = new PlayerControl(this, window[e].playerSabine);
    this.bulletPosition = PlayerSettings.instance.bulletPosition(PlayerSettings.TYPE_SABINE);
    this.bulletPositionJump = PlayerSettings.instance.bulletPositionJump(PlayerSettings.TYPE_SABINE);
    this.frameShootFunctions = [{
        caller: this,
        callback: this.gunShoot,
        frame: 4
    }, {
        caller: this,
        callback: this.shootSecondGun,
        frame: 8
    }];
    this.frameShootUpBody = 8;
    this.gunWeapon = new GunWeapon(this);
    this.m_skinBase = this.data.skinBase;
    this.m_control.activeDoubleJump(!0);
    this.m_character = new SimpleCharacter(c, d, this.m_canvas);
    this.m_character.addState(Player.ST_PLAYER_STAND, this.m_skinBase + "_stand");
    this.m_character.addState(Player.ST_PLAYER_JUMP_UP, this.m_skinBase + "_jump_up");
    this.m_character.addState(Player.ST_PLAYER_JUMP_DOWN, this.m_skinBase + "_jump");
    this.m_character.addState(Player.ST_PLAYER_JUMP_SPECIAL, this.m_skinBase + "_jump2");
    this.m_character.addState(Player.ST_PLAYER_WALK,
        this.m_skinBase + "_run");
    this.m_character.addState(PlayerPlatform.ST_PLAYER_MOVE_SHOOT, this.m_skinBase + "_run");
    this.m_character.addState(Player.ST_PLAYER_HIT, this.m_skinBase + "_hit");
    this.m_character.addState(Player.ST_PLAYER_LOSE, this.m_skinBase + "_defeat");
    this.m_character.addState(Player.ST_PLAYER_WIN, this.m_skinBase + "_outro", [{
        caller: this,
        callback: this.playExtraction,
        frame: 50
    }]);
    this.m_character.addState(Player.ST_PLAYER_LAND, this.m_skinBase + "_jump_ground");
    this.m_character.addState(Player.ST_PLAYER_CELEBRATE,
        this.m_skinBase + "_win");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.gotoState(Player.ST_PLAYER_STAND);
    this.m_timerForJetpack = 0;
    this.m_impulseJetpack = this.data.forceJetpack;
    this.canLaunchGranades = this.fixShoot = !0;
    this.frameCounter = 0;
    this.createCorners()
}
Application.subclass(PlayerSabine, PlayerPlatform);
PlayerSabine.prototype.verticalVerlet = function(a, b) {
    var c = this.m_inGlide ? this.m_impulseJetpack : this.m_y - b + this.m_control.gravity * a * a;
    c < -this.m_control.maxVerletUpDisplace ? c = -this.m_control.maxVerletUpDisplace : c > this.m_control.maxVerletDownDisplace && (c = this.m_control.maxVerletDownDisplace);
    this.m_y += c
};
PlayerSabine.prototype.finishJumpUp = function() {
    this.m_state === Player.ST_PLAYER_JUMP_SPECIAL && (this.onGlide(!0), this.m_timerForJetpack = this.data.timeJetpack)
};
PlayerSabine.prototype.update = function(a) {
    0 < this.m_timerForJetpack && this.m_inGlide && (this.m_timerForJetpack -= a, 0 >= this.m_timerForJetpack && (this.m_timerForJetpack = 0, this.onGlide(!1)));
    this.clipUpBody && this.m_isActionMove && this.fixShoot && 4 === this.clipUpBody.currentFrame && (this.shootSecondGun(), this.fixShoot = !1);
    if (this.clipSpecialAttack && (24 == this.clipSpecialAttack.currentFrame && this.canLaunchGranades && (this.m_world.createEffect("aniFxSabineGranade", this.m_x, this.m_y - 200), this.canLaunchGranades = !1),
            35 < this.clipSpecialAttack.currentFrame)) {
        if (0 === this.frameCounter) Global.game.onShake(8, 10, 1E3);
        if (0 === this.frameCounter % 3) {
            var b = .5 < Math.random() ? Common.random(this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX + 200, this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX + .5 * this.m_world.m_camera.fixWidthRatio - 300) : Common.random(this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX + .5 * this.m_world.m_camera.fixWidthRatio + 300, this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX +
                    this.m_world.m_camera.fixWidthRatio - 200),
                c = Common.random(this.m_world.m_camera.m_y + 100, this.m_world.m_camera.m_y - 100 + Application.APP_HEIGHT);
            this.m_world.createEffect("aniFxBulletExplotion", b, c);
            Global.game.createExplotionShader(b - this.m_world.m_camera.m_x, c - this.m_world.m_camera.m_y - 60, 8)
        }
        this.frameCounter++
    }
    PlayerPlatform.prototype.update.call(this, a)
};
PlayerSabine.prototype.setFlipX = function(a) {
    this.m_skinBase_orientation = (this.m_flipX = a) ? "_b" : "";
    var b = this.m_clip.currentFrame;
    this.m_character.addState(Player.ST_PLAYER_STAND, this.m_skinBase + "_stand" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_UP, this.m_skinBase + "_jump_up" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_DOWN, this.m_skinBase + "_jump" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_SPECIAL, this.m_skinBase +
        "_jump2" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_WALK, this.m_skinBase + "_run" + this.m_skinBase_orientation);
    this.m_character.addState(PlayerPlatform.ST_PLAYER_MOVE_SHOOT, this.m_skinBase + "_run" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_HIT, this.m_skinBase + "_hit" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_LOSE, this.m_skinBase + "_defeat" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_WIN,
        this.m_skinBase + "_outro" + this.m_skinBase_orientation, [{
            caller: this,
            callback: this.playExtraction,
            frame: 50
        }]);
    this.m_character.addState(Player.ST_PLAYER_LAND, this.m_skinBase + "_jump_ground" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_CELEBRATE, this.m_skinBase + "_win" + this.m_skinBase_orientation);
    this.m_character.gotoState(this.m_state);
    this.m_clip = this.m_character.clip;
    this.m_clip.scale.x = this.m_scaleX;
    this.m_clip.scale.y = this.m_scaleY;
    this.m_clip.gotoAndPlay(b);
    PlayerPlatform.prototype.setFlipX.call(this,
        a);
    this.clipUpBody && this.clipUpBody.gunContainer && this.clipUpBody.gunContainer.addChild(this.gunWeapon.clip)
};
PlayerSabine.prototype.onRemoveSpecialAttack = function() {
    PlayerPlatform.prototype.onRemoveSpecialAttack.call(this);
    this.canLaunchGranades = !0;
    this.frameCounter = 0
};
PlayerSabine.prototype.shootSecondGun = function() {
    var a = this.m_clip.name,
        a = "_b" === a.substr(a.length - 2, 2);
    this.unitSounds.playState(PlayerPlatform.ST_PLAYER_SHOOT);
    var b = window.config.weapons[GunWeapon.GUN_BASIC],
        c = 0 === this.m_control.forceX() ? 0 : 50,
        c = this.m_x + (a ? -(43 + c) : 43 + c),
        d = this.m_y - 105,
        e = .5 < Math.random() ? .05 * Math.random() : .05 * -Math.random();
    this.m_world.m_actorManager.bulletManager.create(Bullet.TYPE_PLAYER, b.clipBullet, c, d, b.range, e + (a ? 3.14159 : 0), b.speed, b.damage, Bullet.FX_IMPACT_LASER_PLAYER,
        Bullet.SUB_TYPE_PLAYER_LASER);
    this.m_world.createEffect(GunWeapon.NAME_FX_SHOOT_LASER, c, d)
};
PlayerSabine.prototype.onEndShootWalking = function() {
    PlayerPlatform.prototype.onEndShootWalking.call(this);
    this.fixShoot = !0
};
PlayerSabine.prototype.free = function() {
    PlayerPlatform.prototype.free.call(this)
};

function PlayerHera(a, b, c, d, e) {
    PlayerPlatform.call(this, a, b, c, d, e);
    this.unitSounds = new UnitSounds("Hera");
    this.m_control = new PlayerControl(this, window[e].playerHera);
    this.bulletPosition = PlayerSettings.instance.bulletPosition(PlayerSettings.TYPE_HERA);
    this.bulletPositionJump = PlayerSettings.instance.bulletPositionJump(PlayerSettings.TYPE_HERA);
    this.frameShootFunctions = [{
        caller: this,
        callback: this.gunShoot,
        frame: 4
    }];
    this.frameShootUpBody = 4;
    this.gunWeapon = new GunWeapon(this);
    this.m_skinBase = this.data.skinBase;
    this.m_control.activeDoubleJump(!0);
    this.m_character = new SimpleCharacter(c, d, this.m_canvas);
    this.m_character.addState(Player.ST_PLAYER_STAND, this.m_skinBase + "_stand");
    this.m_character.addState(Player.ST_PLAYER_JUMP_UP, this.m_skinBase + "_jump_up");
    this.m_character.addState(Player.ST_PLAYER_JUMP_DOWN, this.m_skinBase + "_jump");
    this.m_character.addState(Player.ST_PLAYER_JUMP_SPECIAL, this.m_skinBase + "_jump2");
    this.m_character.addState(Player.ST_PLAYER_WALK, this.m_skinBase + "_run");
    this.m_character.addState(PlayerPlatform.ST_PLAYER_MOVE_SHOOT,
        this.m_skinBase + "_run");
    this.m_character.addState(Player.ST_PLAYER_HIT, this.m_skinBase + "_hit");
    this.m_character.addState(Player.ST_PLAYER_LOSE, this.m_skinBase + "_defeat");
    this.m_character.addState(Player.ST_PLAYER_WIN, this.m_skinBase + "_outro", [{
        caller: this,
        callback: this.playExtraction,
        frame: 50
    }]);
    this.m_character.addState(Player.ST_PLAYER_LAND, this.m_skinBase + "_jump_ground");
    this.m_character.addState(Player.ST_PLAYER_CELEBRATE, this.m_skinBase + "_win");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.gotoState(Player.ST_PLAYER_STAND);
    this.createCorners();
    this.canLaunchRays = !0;
    this.m_effectCounter = 0;
    this.bWingFx = null
}
Application.subclass(PlayerHera, PlayerPlatform);
PlayerHera.EFFECT_TIME = 2200;
PlayerHera.prototype.update = function(a) {
    PlayerPlatform.prototype.update.call(this, a);
    if (this.bWingFx && (32 === this.clipSpecialAttack.currentFrame && this.clipSpecialAttack.stop(), this.m_effectCounter += a, this.m_effectCounter >= PlayerHera.EFFECT_TIME)) this.onEndHeraSpecial();
    this.clipSpecialAttack && (this.clipSpecialAttack.alpha = 50 < this.specialTimer % 100 ? .4 : .7, this.specialTimer += a, 12 === this.clipSpecialAttack.currentFrame && (this.unitSounds.playState("special"), this.canLaunchRays && (this.bWingFx = this.m_world.createEffect("aniFxHeraPlayerBwingShootSpecialAttack",
        this.m_world.m_camera.m_x + .5 * Application.APP_WIDTH, this.m_world.m_camera.m_y + .5 * Application.APP_HEIGHT), this.canLaunchRays = !1)))
};
PlayerHera.prototype.onEndHeraSpecial = function() {
    this.bWingFx = null;
    this.m_effectCounter = 0;
    this.unitSounds.playState("specialWing");
    this.m_world.createEffect("hera_bwing", this.m_world.m_camera.m_x + .5 * Application.APP_WIDTH, this.m_world.m_camera.m_y);
    this.clipSpecialAttack.resume();
    Global.game.onShake(5, 5, 750)
};
PlayerHera.prototype.setFlipX = function(a) {
    this.m_skinBase_orientation = (this.m_flipX = a) ? "_b" : "";
    var b = this.m_clip.currentFrame;
    this.m_character.addState(Player.ST_PLAYER_STAND, this.m_skinBase + "_stand" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_UP, this.m_skinBase + "_jump_up" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_DOWN, this.m_skinBase + "_jump" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_SPECIAL, this.m_skinBase +
        "_jump2" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_WALK, this.m_skinBase + "_run" + this.m_skinBase_orientation);
    this.m_character.addState(PlayerPlatform.ST_PLAYER_MOVE_SHOOT, this.m_skinBase + "_run" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_HIT, this.m_skinBase + "_hit" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_LOSE, this.m_skinBase + "_defeat" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_WIN,
        this.m_skinBase + "_outro" + this.m_skinBase_orientation, [{
            caller: this,
            callback: this.playExtraction,
            frame: 50
        }]);
    this.m_character.addState(Player.ST_PLAYER_LAND, this.m_skinBase + "_jump_ground" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_CELEBRATE, this.m_skinBase + "_win" + this.m_skinBase_orientation);
    this.m_character.gotoState(this.m_state);
    this.m_clip = this.m_character.clip;
    this.m_clip.scale.x = this.m_scaleX;
    this.m_clip.scale.y = this.m_scaleY;
    this.m_clip.gotoAndPlay(b);
    PlayerPlatform.prototype.setFlipX.call(this,
        a);
    this.clipUpBody && this.clipUpBody.gunContainer && this.clipUpBody.gunContainer.addChild(this.gunWeapon.clip)
};
PlayerHera.prototype.onRemoveSpecialAttack = function() {
    PlayerPlatform.prototype.onRemoveSpecialAttack.call(this);
    this.canLaunchRays = !0
};
PlayerHera.prototype.free = function() {
    PlayerPlatform.prototype.free.call(this)
};

function PlayerZeb(a, b, c, d, e) {
    PlayerPlatform.call(this, a, b, c, d, e);
    this.unitSounds = new UnitSounds("Zeb");
    this.m_control = new PlayerControl(this, window[e].playerZeb);
    this.bulletPosition = PlayerSettings.instance.bulletPosition(PlayerSettings.TYPE_ZEB);
    this.bulletPositionJump = PlayerSettings.instance.bulletPositionJump(PlayerSettings.TYPE_ZEB);
    this.frameShootFunctions = [{
        caller: this,
        callback: this.gunShoot,
        frame: 4
    }];
    this.frameShootUpBody = 4;
    this.gunWeapon = new GunWeapon(this);
    this.m_skinBase = this.data.skinBase;
    this.m_control.activeDoubleJump(!0);
    this.m_character = new SimpleCharacter(c, d, this.m_canvas);
    this.m_character.addState(Player.ST_PLAYER_STAND, this.m_skinBase + "_stand");
    this.m_character.addState(Player.ST_PLAYER_JUMP_UP, this.m_skinBase + "_jump_up");
    this.m_character.addState(Player.ST_PLAYER_JUMP_DOWN, this.m_skinBase + "_jump");
    this.m_character.addState(Player.ST_PLAYER_JUMP_SPECIAL, this.m_skinBase + "_jump2");
    this.m_character.addState(Player.ST_PLAYER_WALK, this.m_skinBase + "_run");
    this.m_character.addState(PlayerPlatform.ST_PLAYER_MOVE_SHOOT,
        this.m_skinBase + "_run");
    this.m_character.addState(Player.ST_PLAYER_HIT, this.m_skinBase + "_hit");
    this.m_character.addState(Player.ST_PLAYER_LOSE, this.m_skinBase + "_defeat");
    this.m_character.addState(Player.ST_PLAYER_WIN, this.m_skinBase + "_outro", [{
        caller: this,
        callback: this.playExtraction,
        frame: 50
    }]);
    this.m_character.addState(Player.ST_PLAYER_LAND, this.m_skinBase + "_jump_ground");
    this.m_character.addState(Player.ST_PLAYER_CELEBRATE, this.m_skinBase + "_win");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.gotoState(Player.ST_PLAYER_STAND);
    this.createCorners()
}
Application.subclass(PlayerZeb, PlayerPlatform);
PlayerZeb.prototype.update = function(a) {
    PlayerPlatform.prototype.update.call(this, a);
    if (this.clipSpecialAttack) {
        if (22 == this.clipSpecialAttack.currentFrame) Global.game.onShake(10, 10, 1E3);
        30 == this.clipSpecialAttack.currentFrame && Global.game.createExplotionShader(this.m_x - this.m_world.m_camera.m_x, this.m_y - this.m_world.m_camera.m_y, 12);
        40 == this.clipSpecialAttack.currentFrame && Global.game.createExplotionShader(this.m_x - this.m_world.m_camera.m_x, this.m_y - this.m_world.m_camera.m_y, 12)
    }
};
PlayerZeb.prototype.setFlipX = function(a) {
    this.m_skinBase_orientation = (this.m_flipX = a) ? "_b" : "";
    var b = this.m_clip.currentFrame;
    this.m_character.addState(Player.ST_PLAYER_STAND, this.m_skinBase + "_stand" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_UP, this.m_skinBase + "_jump_up" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_DOWN, this.m_skinBase + "_jump" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_JUMP_SPECIAL, this.m_skinBase +
        "_jump2" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_WALK, this.m_skinBase + "_run" + this.m_skinBase_orientation);
    this.m_character.addState(PlayerPlatform.ST_PLAYER_MOVE_SHOOT, this.m_skinBase + "_run" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_HIT, this.m_skinBase + "_hit" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_LOSE, this.m_skinBase + "_defeat" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_WIN,
        this.m_skinBase + "_outro" + this.m_skinBase_orientation, [{
            caller: this,
            callback: this.playExtraction,
            frame: 50
        }]);
    this.m_character.addState(Player.ST_PLAYER_LAND, this.m_skinBase + "_jump_ground" + this.m_skinBase_orientation);
    this.m_character.addState(Player.ST_PLAYER_CELEBRATE, this.m_skinBase + "_win" + this.m_skinBase_orientation);
    this.m_character.gotoState(this.m_state);
    this.m_clip = this.m_character.clip;
    this.m_clip.scale.x = this.m_scaleX;
    this.m_clip.scale.y = this.m_scaleY;
    this.m_clip.gotoAndPlay(b);
    PlayerPlatform.prototype.setFlipX.call(this,
        a)
};
PlayerZeb.prototype.free = function() {
    PlayerPlatform.prototype.free.call(this)
};

function PlayerChopper(a, b, c, d, e) {
    PlayerPlatform.call(this, a, b, c, d, e);
    this.unitSounds = new UnitSounds("Chopper");
    this.m_control = new PlayerControl(this, window[e].playerChopper);
    this.bulletPosition = PlayerSettings.instance.bulletPosition(PlayerSettings.TYPE_CHOPPER);
    this.bulletPositionJump = PlayerSettings.instance.bulletPositionJump(PlayerSettings.TYPE_CHOPPER);
    this.frameShootFunctions = [{
        caller: this,
        callback: this.gunShoot,
        frame: 5
    }];
    this.frameShootUpBody = 5;
    this.idleTimer = 0;
    this.gunWeapon = new GunWeapon(this);
    this.m_skinBase = this.data.skinBase;
    this.m_control.activeDoubleJump(!0);
    this.m_character = new SimpleCharacter(c, d, this.m_canvas);
    this.m_character.addState(Player.ST_PLAYER_STAND, this.m_skinBase + "_stand");
    this.m_character.addState(Player.ST_PLAYER_JUMP_UP, this.m_skinBase + "_jump_up");
    this.m_character.addState(Player.ST_PLAYER_JUMP_DOWN, this.m_skinBase + "_jump");
    this.m_character.addState(Player.ST_PLAYER_JUMP_SPECIAL, this.m_skinBase + "_jump2");
    this.m_character.addState(Player.ST_PLAYER_WALK, this.m_skinBase +
        "_run");
    this.m_character.addState(PlayerPlatform.ST_PLAYER_MOVE_SHOOT, this.m_skinBase + "_run");
    this.m_character.addState(Player.ST_PLAYER_HIT, this.m_skinBase + "_hit");
    this.m_character.addState(Player.ST_PLAYER_LOSE, this.m_skinBase + "_defeat");
    this.m_character.addState(Player.ST_PLAYER_WIN, this.m_skinBase + "_outro", [{
        caller: this,
        callback: this.playExtraction,
        frame: 50
    }]);
    this.m_character.addState(Player.ST_PLAYER_LAND, this.m_skinBase + "_jump_ground");
    this.m_character.addState(Player.ST_PLAYER_CELEBRATE, this.m_skinBase +
        "_win");
    this.m_character.addState(PlayerChopper.ST_IDLE, this.m_skinBase + "_iddle");
    this.m_character.onEndAnimation(this, this.onEndAnimation);
    this.gotoState(Player.ST_PLAYER_STAND);
    this.m_timerForJetpack = 0;
    this.m_impulseJetpack = this.data.forceJetpack;
    this.createCorners();
    this.useSeparatedAnimations = !1
}
Application.subclass(PlayerChopper, PlayerPlatform);
PlayerChopper.IDLE_TIME = 2E3;
PlayerChopper.ST_IDLE = "st_301";
PlayerChopper.prototype.onEndAnimation = function(a) {
    PlayerPlatform.prototype.onEndAnimation.call(this, a);
    switch (a) {
        case PlayerChopper.ST_IDLE:
            this.gotoState(Player.ST_PLAYER_STAND)
    }
};
PlayerChopper.prototype.verticalVerlet = function(a, b) {
    var c = this.m_inGlide ? this.m_impulseJetpack : this.m_y - b + this.m_control.gravity * a * a;
    c < -this.m_control.maxVerletUpDisplace ? c = -this.m_control.maxVerletUpDisplace : c > this.m_control.maxVerletDownDisplace && (c = this.m_control.maxVerletDownDisplace);
    this.m_y += c
};
PlayerChopper.prototype.finishJumpUp = function() {
    this.m_state === Player.ST_PLAYER_JUMP_SPECIAL && (this.onGlide(!0), this.m_timerForJetpack = this.data.timeJetpack)
};
PlayerChopper.prototype.update = function(a) {
    this.isHolding || (this.idleTimer = this.m_state === Player.ST_PLAYER_STAND ? this.idleTimer + a : 0, this.idleTimer >= PlayerChopper.IDLE_TIME && (this.idleTimer = 0, this.gotoState(PlayerChopper.ST_IDLE)), 0 < this.m_timerForJetpack && this.m_inGlide && (this.m_timerForJetpack -= a, 0 >= this.m_timerForJetpack && (this.m_timerForJetpack = 0, this.onGlide(!1))), PlayerPlatform.prototype.update.call(this, a), this.m_state === Player.ST_PLAYER_WALK ? Application.instance.playSound("SND_CHOPPER_ROLL") :
        Application.instance.stopSound("SND_CHOPPER_ROLL"))
};
PlayerChopper.prototype.onRemoveSpecialAttack = function() {
    PlayerPlatform.prototype.onRemoveSpecialAttack.call(this)
};
PlayerChopper.prototype.free = function() {
    PlayerPlatform.prototype.free.call(this)
};

function OOCManager(a) {
    this.m_world = a;
    this.oocArray = []
}
OOCManager.prototype.registerActor = function(a, b, c) {
    a = new OutOfCamera(this.m_world, a, b, c);
    this.oocArray.push(a);
    return a
};
OOCManager.IMPERIAL_ANTENNA = -ActorManagerPlatform.IMPERIAL_MACHINE;
OOCManager.EXTRACTION_POINT = -ActorManagerPlatform.ITEM_EXTRACTION_POINT;
OOCManager.GHOSTING = -999;
OOCManager.prototype.update = function(a) {
    for (var b = !1, c = this.oocArray.length - 1; 0 <= c; c--) {
        var d = this.oocArray[c];
        d && (d.update(a), b = d.isHidden || b)
    }
    for (c = this.oocArray.length - 1; 0 <= c; c--) d = this.oocArray[c], -1 !== d.m_type && b && (d.m_character.clip.visible = !1)
};
OOCManager.prototype.removeThisActor = function(a) {
    for (var b = this.oocArray.length - 1; 0 <= b; b--) {
        var c = this.oocArray[b];
        if (c.m_actor === a) {
            c.free();
            this.oocArray.splice(b, 1);
            break
        }
    }
};
OOCManager.prototype.setActiveOfType = function(a, b) {
    for (var c = this.oocArray.length - 1; 0 <= c; c--) {
        var d = this.oocArray[c];
        d.m_type === a && d.isActive !== b && ("undefined" !== typeof d.m_actor.m_created && d.m_actor.m_created || "undefined" === typeof d.m_actor.m_created) && ("undefined" !== typeof d.m_actor.showOOC ? d.m_actor.showOOC = b : d.isActive = b, b ? d.calculatePos() : d.m_character.clip.visible = !1)
    }
};
OOCManager.prototype.activatePlanetHints = function(a) {
    this.toggleAll(!1);
    for (var b = this.oocArray.slice(0), c = [], d = b.length - 1; 0 <= d; d--)(b[d].m_type === OOCManager.EXTRACTION_POINT || b[d].m_type === OOCManager.IMPERIAL_ANTENNA || b[d].m_type === OOCManager.GHOSTING || b[d].hasBeenCollected || b[d].isAwaitingDelete) && b.splice(d, 1);
    if (a < b.length)
        for (d = 0; 3 > d; d++) c.push(b.splice(Common.randomInt(0, b.length - 1), 1)[0]);
    else c = b;
    for (d = c.length - 1; 0 <= d; d--) a = c[d], "undefined" !== typeof a.m_actor.showOOC && (a.m_actor.showOOC = !0),
        a.isActive = !0
};
OOCManager.prototype.forceToggleAll = function(a) {
    for (var b = this.oocArray.length - 1; 0 <= b; b--) {
        var c = this.oocArray[b];
        "undefined" !== typeof c.m_actor.showOOC && (c.m_actor.showOOC = a);
        c.isActive = a;
        c.m_character.clip.visible = a
    }
};
OOCManager.prototype.toggleAll = function(a) {
    for (var b = this.oocArray.length - 1; 0 <= b; b--) {
        var c = this.oocArray[b];
        c.m_type !== OOCManager.EXTRACTION_POINT && c.m_type !== OOCManager.IMPERIAL_ANTENNA && c.m_type !== OOCManager.GHOSTING && ("undefined" !== typeof c.m_actor.showOOC && (c.m_actor.showOOC = a), c.isActive = a, c.m_character.clip.visible = a)
    }
};

function OutOfCamera(a, b, c, d) {
    this.m_type = d || -1;
    this.m_actor = b;
    this.m_canvasIcon = this.m_clipIcon = null;
    SimpleWorldActor.call(this, a.canvasEffects, a, this.m_actor.m_x, this.m_actor.m_y);
    this.m_character = new SimpleCharacter(this.m_x, this.m_y, a.objectCanvas());
    this.isActive = !0;
    this.isHidden = this.isAwaitingDelete = !1;
    this.m_skin = c;
    this.m_camera = a.m_camera;
    this.setClip(this.m_skin);
    this.m_halfW = this.m_clip.getCollision("mcCollision").w / 2 || 32;
    this.m_halfH = this.m_clip.getCollision("mcCollision").h / 2 || 32;
    this.m_character.clip.visible = !1;
    this.m_CamW = Application.config.settings.APP_WIDTH;
    this.m_CamH = Application.config.settings.APP_HEIGHT;
    this.distanceToPlayer = 0
}
Application.subclass(OutOfCamera, SimpleWorldActor);
OutOfCamera.MIN_ALPHA = .25;
OutOfCamera.MAX_ALPHA = 1;
OutOfCamera.MIN_DISTANCE_ALPHA = 100;
OutOfCamera.MAX_DISTANCE_ALPHA = 1600;
OutOfCamera.prototype.setClip = function(a) {
    this.m_clip = PoolClips.instance.getClip("gui_hud_pointer_base");
    this.m_clipIcon = Application.instance.getClip(a);
    this.m_clipIcon.scale.x /= Application.DPI;
    this.m_clipIcon.scale.y /= Application.DPI;
    this.m_canvasIcon = this.m_clip.mcIconContainer;
    this.m_canvasIcon.addChild(this.m_clipIcon);
    this.m_canvas.addChild(this.m_clip);
    this.m_character.clip = this.m_clip
};
OutOfCamera.prototype.update = function(a) {
    "undefined" !== typeof this.m_actor.showOOC && (this.isActive = this.m_actor.showOOC);
    this.isActive && (this.m_actor.m_y <= this.m_camera.m_y + this.m_CamH && this.m_actor.m_y >= this.m_camera.m_y && this.m_actor.m_x <= this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX + this.m_world.m_camera.fixWidthRatio && this.m_actor.m_x >= this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX ? (this.m_character.clip.visible = !1, this.m_type !== OOCManager.EXTRACTION_POINT && this.m_type !==
        OOCManager.IMPERIAL_ANTENNA && this.m_type !== OOCManager.GHOSTING && (this.isHidden = !0)) : (this.m_character.clip.visible = !0, this.isHidden = !1, this.calculatePos()), this.setAlphaByDistance(!0), this.m_character && this.m_character.update(a), this.m_clip && (this.m_clip.position.x = this.m_x, this.m_clip.position.y = this.m_y))
};
OutOfCamera.prototype.setAlphaByDistance = function(a) {
    if (this.distanceToPlayer > OutOfCamera.MAX_DISTANCE_ALPHA) this.m_clip.alpha = a ? OutOfCamera.MAX_ALPHA : OutOfCamera.MIN_ALPHA;
    else if (this.distanceToPlayer < OutOfCamera.MIN_DISTANCE_ALPHA) this.m_clip.alpha = a ? OutOfCamera.MIN_ALPHA : OutOfCamera.MAX_ALPHA;
    else {
        var b = OutOfCamera.MAX_DISTANCE_ALPHA - OutOfCamera.MIN_DISTANCE_ALPHA,
            c = this.distanceToPlayer - OutOfCamera.MIN_DISTANCE_ALPHA;
        this.m_clip.alpha = a ? c / b * (OutOfCamera.MAX_ALPHA - OutOfCamera.MIN_ALPHA) + OutOfCamera.MIN_ALPHA :
            (1 - c / b) * (OutOfCamera.MAX_ALPHA - OutOfCamera.MIN_ALPHA) + OutOfCamera.MIN_ALPHA
    }
};
OutOfCamera.prototype.calculatePos = function() {
    if (this.m_actor) {
        var a = this.m_world.m_camera.m_x - this.m_world.m_camera.fixOffsetX + .5 * this.m_world.m_camera.fixWidthRatio,
            b = this.m_camera.m_y + .5 * this.m_CamH,
            c = this.m_actor.m_x - a,
            d = this.m_actor.m_y - b;
        this.distanceToPlayer = Math.sqrt(c * c + d * d);
        c = Math.acos(c / this.distanceToPlayer);
        c = 0 > d ? -c : c;
        this.m_character.clip.rotation = c;
        this.m_clipIcon.rotation = -this.m_character.clip.rotation;
        this.m_x = a + (.45 * this.m_world.m_camera.fixWidthRatio - this.m_halfH) * SMath.fastCos(c);
        this.m_y = b + (.45 * this.m_CamH - this.m_halfH) * SMath.fastSin(c)
    }
};
OutOfCamera.prototype.free = function() {
    this.m_character = null;
    this.m_canvasIcon.removeChild(this.m_clipIcon);
    this.m_canvasIcon = null;
    SimpleWorldActor.prototype.free.call(this)
};

function Generator(a, b, c) {
    SimpleWorldActor.call(this, a, b, c.x, c.y);
    this.m_npc = c;
    this.m_className = "Generator";
    this.m_isGenerating = !1;
    this.m_timer = this.m_waitTime = c.rawData.freq;
    this.m_maxEnemiesOnScreen = c.rawData.enemiesOnScreen;
    this.m_maxTotalEnemies = c.rawData.maxTotalEnemies;
    this.m_numTotalEnemies = this.m_numEnemies = 0;
    this.m_refEnemies = null;
    this.m_limits = b.getMaxFloorRange(c.x, c.y, Math.floor(c.limitLeft + c.limitRight));
    this.classPool = ["Stormtrooper", "Shocktrooper", "Mandalorian"]
}
Application.subclass(Generator, SimpleWorldActor);
Generator.prototype.update = function(a) {
    SimpleWorldActor.prototype.update.call(this, a);
    if (PlayerSettings.instance.liberationState === ConquerBase.ST_CONQUER_PROGRESS || PlayerSettings.instance.sabotageState === ImperialMachine.ST_SABOTAGE_PROGRESS)
        if (this.m_timer -= a, 0 >= this.m_timer) {
            if (null === this.m_refEnemies) {
                this.m_refEnemies = [];
                a = this.m_x - .5 * this.m_maxEnemiesOnScreen;
                for (var b = 1; b <= this.m_maxEnemiesOnScreen; b++) this.m_refEnemies.push({
                    x: a + Math.random() * this.m_maxEnemiesOnScreen,
                    y: this.m_y,
                    e: null
                })
            }
            this.m_isGenerating = !1;
            this.m_timer = this.m_waitTime;
            this.m_numEnemies++;
            this.m_numTotalEnemies++;
            this.generateNewEnemy()
        }
};
Generator.prototype.generateNewEnemy = function() {
    var a = new NpcPlatform;
    a.x = this.m_limits.x + Math.random() * this.m_limits.w;
    a.y = this.m_y;
    a.limitLeft = this.m_npc.limitLeft;
    a.limitRight = this.m_npc.limitRight;
    a.params = "";
    for (var b = null, c = 0; c < this.m_maxEnemiesOnScreen; c++)
        if (null === this.m_refEnemies[c].e) {
            var d = ~~(Math.random() * this.classPool.length),
                d = d + (d === this.classPool.length ? -1 : 0);
            switch (this.classPool[d]) {
                case "Stormtrooper":
                case "Shocktrooper":
                    b = new Stormtrooper(this.m_world.objectCanvas(), this.m_world,
                        a, this.classPool[d], !1, !0);
                    break;
                case "Mandalorian":
                    a.y -= 125, b = new Mandalorian(this.m_world.objectCanvas(), this.m_world, a), b.forceAppear()
            }
            this.m_refEnemies[c].e = b;
            b.setGenerator(this);
            this.m_world.actorManager().add(b);
            break
        }
};
Generator.prototype.notifyKill = function(a) {
    for (var b = 0; b < this.m_maxEnemiesOnScreen; b++)
        if (this.m_refEnemies[b].e === a) {
            this.m_numEnemies--;
            this.m_refEnemies[b].e = null;
            break
        }
};
Generator.prototype.free = function() {
    SimpleWorldActor.prototype.free.call(this);
    if (this.m_refEnemies)
        for (var a = 0; a < this.m_maxEnemiesOnScreen; a++) this.m_refEnemies[a].e = null;
    this.m_refEnemies = null
};

function UnitSounds(a) {
    this.soundIds = [];
    this.getSoundConfig(a)
}
UnitSounds.prototype.getSoundConfig = function(a) {
    for (var b = Application.config.unitSounds, c = 0; c < b.length; c++) b[c].unitName === a && (this.soundIds[b[c].state] = b[c].soundId)
};
UnitSounds.prototype.playState = function(a) {
    "undefined" !== typeof this.soundIds[a] && Application.instance.playSound(this.soundIds[a])
};
PIXI.Container.prototype.countChildren = function() {
    if (!this.children) return 1;
    for (var a = this.children.length, b = 0, c = this.children.length; b < c; b++) this.children[b].countChildren && (a += this.children[b].countChildren());
    return a
};
Application.warn("Greenish Games");